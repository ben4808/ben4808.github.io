{"version":3,"sources":["models/SquareType.ts","models/WordDirection.ts","AppContext.ts","lib/windowService.tsx","models/SymmetryType.ts","models/ContentType.ts","models/QualityClass.ts","lib/wordList.ts","lib/entryCandidates.ts","lib/util.ts","lib/fill.ts","lib/section.ts","lib/insertEntry.ts","lib/priorityQueue.ts","models/FillStatus.ts","lib/grid.ts","components/CluesView/CluesView.tsx","components/FillView/FillView.tsx","lib/useInterval.ts","components/Square/Square.tsx","components/Grid/Grid.tsx","lib/puzFiles.ts","components/Menu/Menu.tsx","App.tsx","index.tsx"],"names":["SquareType","WordDirection","AppContext","React","createContext","triggerUpdate","switchActiveView","_","setPuzzle","createNewPuzzle","w","h","exportPuz","window","Globals","SymmetryType","ContentType","QualityClass","filename","data","a","text","lines","split","indexWordList","words","parseWordList","wordList","wordCount","length","qcMap","qualityClasses","Map","forEach","line","tokens","trim","match","score","qualityClass","Lively","Normal","Crosswordese","word","has","push","set","queryIndexedWordList","pattern","wl","letters","i","buckets","oneVal","charCodeAt","pos1","pos2","val1","val2","twoVal","filter","entries","existingList","ch1","ch2","populateAndScoreEntryCandidates","node","isForManualFill","wordKey","fillWord","iffyWordKey","populateNoHeuristicEntryCandidates","anchorSquareKeys","anchorInfo","populateFillWordAnchors","getSquaresForWord","startGrid","anchorCombosLeft","eligibleCandidates","processAnchorCombo","getEligibleCandidates","ec","entryCandidates","sort","b","dontRecalc","undefined","getLettersFromSquares","deepClone","get","entry","getWordScore","isViable","hasBeenChained","wasChainFailure","crossScore","minCrossScore","squares","calculatedSquares","anchorKeyCounts","sq","count","squareKey","viableLetters","constraintLetterCount","combos","constraintLetters","map","sqKey","find","content","fullAlphabet","comboScores","letter1","letter2","letterFrequencies","Math","random","generateAnchorCombos","grid","combo","pop","fillWordKey","wordSquares","patternWithAnchor","insertLetterIntoPattern","isWordFull","getFilteredEntries","usedWords","manualIffyKey","maxFilteredEntryCount","processEntry","maxCount","distillIndex","batchKeys","filledCrosses","filteredEntriesCount","foundCountReduction","processedIffy","nextBatchKeys","wKey","getAllCrosses","cross","crossKey","crossSquares","crossPattern","filteredEntries","newPattern","includes","fe","reduce","newMatrix","Array","fill","letterMatrixToLetterList","existingCounts","topCrossScore","topMinCrossScore","iffyEntry","iffyWord","iffySquares","isq","idx","calSq","substring","maxIffyLength","crosses","getWordAtSquare","row","col","otherDir","direction","getUnfilledCrosses","ck","wordLength","wordScore","calculateEntryCandidateScore","anchorPattern","constraintCounts","x","curPatterns","lowestCount","index","newCurPatterns","ltr","broadenAnchorPatterns","newLetter","findIndex","updateSectionFilters","sections","getGrid","sec","candidates","can","sqKeys","mapKeys","isFilteredOut","gridSq","getSquareAtKey","canSq","isUserOrWordFilled","insertSectionCandidateIntoGrid","candidate","contentType","ChosenSection","newGrid","section","sectionId","foundDiscrepancy","candidateSq","HoverChosenSection","Autofill","forAllGridSquares","newSq","key","neighboringCrosses","generateConstraintInfoForSquares","userFilledSectionCandidates","sectionCandidateKey","generateGridSections","usedSquares","nextSectionId","fullSection","makeNewSection","isBlackSquare","isOpenSquare","newSection","iterateSection","openSquareCount","getNeighboringSquares","neighbor","Across","Down","dir","wsq","id","size","delete","stackWords","stackedNeighbors","otherKey","otherWord","isAcross","abs","start","min","end","max","sk","wordOrder","calculateSectionOrder","mapValues","secOrder","calculateWordOrder","wk","connections","wordsSort","iterateWordGroup","group","centerIndex","floor","rowOrCol","slice","acrossSortedStackWords","downSortedStackWords","longestStack","stack","curGroup","prevRowOrCol","j","newWord","newRowOrCol","neighbors","n","ret","nClear","sClear","height","wClear","eClear","width","calculateSectionCandidateScore","total","foundIffy","natoAlphabet","k","join","comboPermsQueue","comboPermsUsed","getSelectedSectionCandidates","selectedSectionCandidateKeys","scKey","getSectionWithCandidate","sc","getSectionsWithWord","processAndInsertChosenEntry","chosenEntry","HoverChosenWord","ChosenWord","newSquares","getSectionCandidatesFromKeys","removeNonmatchingSectionCandidates","endGrid","FillStatus","fillSectionWord","getSection","fillQueue","newFillQueue","heap","left","right","hasRight","swap","temp","isEmpty","peek","value","insert","item","prio","p","tmp","current","largerChild","priorityQueue","populateSeedNodes","needsNewPriority","shouldBeDeleted","calculateNodePriority","isChainNode","chainId","curChainId","activeGrid","selectWordToFill","topScore","c","pow","roll","runningTotal","chooseEntryFromCandidates","processSectionNode","sectionString","getSectionString","newSecCandidateFound","newCandidate","getEntryAtWordKey","newSectionCandidate","invalidateChainNode","newNode","makeNewNode","depth","nextFillWord","curSections","nextSections","cs","ns","selectedWordNode","parent","prevCandidate","backtracks","chainBaseNode","chainIffyCandidates","chainGoodCandidates","curNode","isSectionBase","situationScore","selectedSectionIds","activeSectionId","activeSection","connectionIds","selectedCandidate","candidateCounts","comboKey","perm","toString","shift","defaultCombo","allOnes","foundNew","newPerm","newPermKey","getNewPermutations","wasSuccess","viableLetterCounts","Iffy","populateWords","processSquare","currentWord","number","nextSq","currentNumber","isAboveBlocked","isBelowBlocked","isLeftBlocked","isRightBlocked","isUnchecked","isUncheckedStart","isCheckedStart","numberizeGrid","updateGridConstraintInfo","wordKeys","concat","isWordEmpty","entryOptions","curViableMatrix","list","matrix","letterListToLetterMatrix","newViableMatrix","arr","newVal","setLettersArrayVal","createNewGrid","type","White","isCircled","getSymmetrySquares","initSquare","r","gridSymmetry","Rotate180","Rotate90","MirrorHorizontal","MirrorVertical","MirrorNWSE","MirrorNESW","eraseGridSquare","otherDirWord","otherDirSquares","User","isInSection","csq","clearFill","eraseSectionCandidateFromGrid","getSelectedSectionCandidatesWithSquare","fillStatus","Ready","NoWordList","isUserFilled","updateManualEntryCandidates","selectedWordKey","useManualHeuristics","obj","Date","getTime","from","Object","keys","newObj","compareTuples","first","second","Black","doesWordContainSquare","func","newPuzzle","title","author","copyright","clues","notes","getSelectedWord","values","sck","initializeSessionGlobals","hoverSectionId","String","fromCharCode","CluesView","props","useState","initClueProps","clueProps","setClueProps","selectedKey","setSelectedKey","textareasRef","useRef","puzzle","prop","clue","isOpenForEditing","handleClueClick","event","target","classList","parentElement","targetKey","attributes","refIndex","textareaEl","newClueProps","propToToggle","style","display","focus","handleKeyDown","toUpperCase","newValue","targetProp","applyClueChange","handleFocus","select","renderCluesContainer","clueList","className","createRef","data-key","onClick","data-ref-index","defaultValue","onKeyDown","onFocus","ref","useEffect","updateSemaphore","acrossClues","downClues","FillView","appContext","useContext","showSectionCandidates","setShowSectionCandidates","isWordListLoading","setIsWordListLoading","isFillRunning","setIsFillRunning","setFillStatus","newStatus","getManualEntryNode","isHover","insertEntryIntoGrid","getManualSectionNode","handleEntryCandidateClick","hoverGrid","handleEntryCandidateHover","handleSectionClick","handleSectionCheckClick","handleSectionHover","handleSectionCandidateClick","eraseSc","candidateKey","handleSectionCandidateHover","callback","delay","savedCallback","setInterval","clearInterval","useInterval","Complete","selectedSymmetry","symmetryOptions","t","isNaN","Number","fillStatusStr","status","Running","getFillStatusString","wordLists","isNoEntryCandidates","selectedScKey","sectionCandidates","selectedEntry","selectedMaxIffyLength","hidden","accept","onChange","file","files","setTimeout","processWordListData","name","then","checked","htmlFor","selectedIndex","getSymmetryTypeString","confirm","document","getElementById","click","gridTemplateColumns","cursor","onMouseOut","data-word","data-iffykey","onMouseOver","toFixed","data-id","getLongest","getLongestStackWord","data-candidate-key","between","input","Square","isSelected","isInSelectedWord","isInSelectedSection","constraintSum","data-row","data-col","NotAThing","getSquareElement","Grid","selectedSquare","setSelectedSquare","advanceCursor","selSq","isSquareSelected","selectedWordDir","newSelSq","setSelWordAtSelSquare","isSquareInSection","newSelSquare","getSquareProps","selectedWord","square","qualityClassMap","suppressEnterKey","preventDefault","el","range","createRange","selectNodeContents","sel","getSelection","removeAllRanges","addRange","selectElementContents","qc","curQc","generateQualityClassMap","squareElements","sqProps","columnTemplateStyle","contentEditable","suppressContentEditableWarning","onBlur","newTitle","innerText","onFocusCapture","newAuthor","newCopyright","newDirection","uncheckedSquareDir","getUncheckedSquareDir","letterChanged","blackSquareChanged","backupCursor","res","newSquareType","tabIndex","newNotes","processPuzData","Uint8Array","arrayBuffer","blobToText","restOfFile","curChar","getNextString","sortWordsForPuz","rebusSquareMappings","rebusValues","sectionType","dlI","Uint16Array","dataLength","secI","valuesStr","str","val","v","blob","cksum_region","bytes","startPos","len","cksum","insertString","pos","insertNumber","Menu","sizeRefs","handleViewChange","newView","role","data-view-id","openView","newWidth","newHeight","gridWidth","float","gridHeight","App","activeView","setActiveView","setGridWidth","setGridHeight","setUpdateSemaphore","getAppContext","appState","setAppState","initializeGlobals","solutionPos","areCircledSquares","char","gridPos","titlePos","authorPos","copyrightPos","orderedClues","cluesPos","oc","sectionSize","checksumPos","c_cib","squaresTotal","cluePos","c_sol","c_grid","c_part","finalArray","Blob","generatePuzFile","File","url","URL","createObjectURL","puzzleLink","setAttribute","isNewPuzzle","Provider","href","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.e7dc1233.chunk.js","sourcesContent":["export enum SquareType {\r\n    White,\r\n    Black,\r\n    //Blank,\r\n}\r\n","export enum WordDirection {\r\n    Across,\r\n    Down,\r\n}\r\n","import React from \"react\";\r\nimport { Puzzle } from \"./models/Puzzle\";\r\n\r\nexport const AppContext = React.createContext({\r\n    triggerUpdate: () => {},\r\n    switchActiveView: (_: string) => {},\r\n    setPuzzle: (_: Puzzle) => {},\r\n    createNewPuzzle: (w: number, h: number) => {},\r\n    exportPuz: () => {},\r\n  });\r\n  ","import { GlobalsObj } from \"../models/GlobalsObj\";\r\n\r\ndeclare const window: any;\r\nwindow.Globals = {} as GlobalsObj;\r\nexport default window.Globals as GlobalsObj;\r\n","export enum SymmetryType {\r\n    None,\r\n    Rotate180,\r\n    Rotate90,\r\n    MirrorHorizontal,\r\n    MirrorVertical,\r\n    MirrorNWSE,\r\n    MirrorNESW,\r\n}\r\n","export enum ContentType {\r\n    User,\r\n    ChosenWord,\r\n    HoverChosenWord,\r\n    ChosenSection,\r\n    HoverChosenSection,\r\n    Autofill,\r\n}\r\n","export enum QualityClass {\r\n    NotAThing,\r\n    Iffy,\r\n    Crosswordese,\r\n    Normal,\r\n    Lively,\r\n}\r\n","import { IndexedWordList } from \"../models/IndexedWordList\";\r\nimport { QualityClass } from \"../models/QualityClass\";\r\nimport { WordList } from \"../models/WordList\";\r\nimport Globals from './windowService';\r\n\r\nexport async function processWordListData(filename: string, data: Blob): Promise<WordList | undefined> {\r\n    let lines = (await data.text()).split(\"\\n\");\r\n    let words = parseWordList(lines);\r\n    indexWordList(words, Globals.wordList);\r\n\r\n    return {\r\n        filename: filename,\r\n        wordCount: words.length,\r\n    } as WordList;\r\n}\r\n\r\nexport async function loadWordListFromLocalhost(url: string) {\r\n    var response = await fetch(url);\r\n    const lines = (await response.text()).split('\\n');\r\n    let words = parseWordList(lines);\r\n    indexWordList(words, Globals.wordList);\r\n    let filenameTokens = url.split(\"/\");\r\n    let filename = filenameTokens[filenameTokens.length - 1];\r\n\r\n    Globals.wordLists = [];\r\n    Globals.wordLists!.push({\r\n        filename: filename,\r\n        wordCount: words.length,\r\n    });\r\n\r\n    console.log(\"Word List loaded\");\r\n}\r\n\r\nfunction parseWordList(lines: string[]): string[] {\r\n    let qcMap = Globals.qualityClasses || new Map<string, QualityClass>();\r\n    let words = [] as string[];\r\n\r\n    lines.forEach(line => {\r\n        let tokens = line.trim().split(\";\");\r\n        if (tokens.length > 2) return;\r\n        if (!tokens[0].match(/^[A-Z]+$/)) return;\r\n\r\n        let score = tokens.length === 2 ? +tokens[1] : 50;\r\n        let qualityClass = score >= 100 ? QualityClass.Lively :\r\n                           score >= 50 ? QualityClass.Normal :\r\n                           QualityClass.Crosswordese;\r\n        let word = tokens[0];\r\n        if (word.length >= 2 && word.length <= 15) {\r\n            if (!qcMap.has(word)) words.push(word);\r\n            qcMap.set(word, qualityClass);\r\n        }\r\n    });\r\n\r\n    Globals.qualityClasses = qcMap;\r\n\r\n    return words;\r\n}\r\n\r\nexport function queryIndexedWordList(pattern: string): string[] {\r\n    let wl = Globals.wordList!;\r\n    let words = [] as string[];\r\n    if (pattern.length > 15) return words;\r\n    let letters = [] as [number, string][];\r\n    let length = pattern.length;\r\n    for (let i = 0; i < pattern.length; i++) {\r\n        if (pattern[i] !== \"-\") {\r\n            letters.push([i+1, pattern[i]]);\r\n        }\r\n    }\r\n\r\n    if (letters.length === 1) {\r\n        words = wl.buckets.oneVal[length-2][letters[0][0]-1][letters[0][1].charCodeAt(0)-65];\r\n    }\r\n    else if (letters.length === pattern.length) {\r\n        words = Globals.qualityClasses?.has(pattern) ? [pattern] : [];\r\n    }\r\n    else if (letters.length > 1) {\r\n        let pos1 = letters[0][0];\r\n        let pos2 = letters[1][0];\r\n        let val1 = letters[0][1];\r\n        let val2 = letters[1][1];\r\n        words = wl.buckets.twoVal[length-2][pos1-1][pos2-(pos1+1)][val1.charCodeAt(0)-65][val2.charCodeAt(0)-65];\r\n\r\n        for (let i = 2; i < letters.length; i++) {\r\n            words = words.filter(w => w[letters[i][0]-1] === letters[i][1]);\r\n        }\r\n    }\r\n\r\n    return words;\r\n}\r\n\r\nfunction indexWordList(entries: string[], existingList?: IndexedWordList) {\r\n    let buckets = existingList ? existingList.buckets : {\r\n        oneVal: [] as any[],\r\n        twoVal: [] as any[],\r\n    };\r\n\r\n    for (let length = 2; length <= 15; length++) {\r\n        buckets.oneVal.push([] as any[]);\r\n        for (let pos1 = 1; pos1 <= length; pos1++) {\r\n            buckets.oneVal[length-2].push([] as any[]);\r\n            for (let ch1 = 65; ch1 <= 90; ch1++) {\r\n                buckets.oneVal[length-2][pos1-1].push([] as string[]);\r\n            }\r\n        }\r\n    }\r\n\r\n    for (let length = 2; length <= 15; length++) {\r\n        buckets.twoVal.push([] as any[]);\r\n        for (let pos1 = 1; pos1 <= length-1; pos1++) {\r\n            buckets.twoVal[length-2].push([] as any[]);\r\n            for (let pos2 = pos1+1; pos2 <= length; pos2++) {\r\n                buckets.twoVal[length-2][pos1-1].push([] as any[]);\r\n                for (let ch1 = 65; ch1 <= 90; ch1++) {\r\n                    buckets.twoVal[length-2][pos1-1][pos2-(pos1+1)].push([] as any[]);\r\n                    for (let ch2 = 65; ch2 <= 90; ch2++) {\r\n                        buckets.twoVal[length-2][pos1-1][pos2-(pos1+1)][ch1-65].push([] as string[]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    entries.forEach(word => {\r\n        // 1-position entries\r\n        for (let pos1 = 1; pos1 <= word.length; pos1++) {\r\n            buckets.oneVal[word.length-2][pos1-1][word[pos1-1].charCodeAt(0)-65].push(word);\r\n        }\r\n\r\n        // 2-position entries\r\n        for (let pos1 = 1; pos1 < word.length; pos1++) {\r\n            for (let pos2 = pos1 + 1; pos2 <= word.length; pos2++) {\r\n                buckets.twoVal[word.length-2][pos1-1][pos2-(pos1+1)][word[pos1-1].charCodeAt(0)-65][word[pos2-1].charCodeAt(0)-65].push(word);\r\n            }\r\n        }\r\n    });\r\n\r\n    Globals.wordList = { buckets: buckets } as IndexedWordList;\r\n}\r\n","import { EntryCandidate } from \"../models/EntryCandidate\";\r\nimport { FillNode } from \"../models/FillNode\";\r\nimport { GridSquare } from \"../models/GridSquare\";\r\nimport { getAllCrosses, getEligibleCandidates, getUnfilledCrosses, getWordScore } from \"./fill\";\r\nimport { getLettersFromSquares } from \"./grid\";\r\nimport { constraintLetterCount, deepClone, fullAlphabet, getSquaresForWord, \r\n    isWordFull, letterMatrixToLetterList, squareKey, sum, wordKey, wordLength } from \"./util\";\r\nimport { queryIndexedWordList } from \"./wordList\";\r\nimport Globals from './windowService';\r\n\r\n// returns false if no viable candidates were found or iffy was set\r\nexport function populateAndScoreEntryCandidates(node: FillNode, isForManualFill: boolean): boolean {\r\n    if (isForManualFill && wordKey(node.fillWord!) === node.iffyWordKey) {\r\n        populateNoHeuristicEntryCandidates(node);\r\n        return true;\r\n    }\r\n\r\n    if (node.anchorSquareKeys.length === 0) {\r\n        let word = node.fillWord!;\r\n        let squares = getSquaresForWord(node.startGrid, word);\r\n        let anchorInfo = populateFillWordAnchors(squares);\r\n        node.anchorCombosLeft = anchorInfo.anchorCombosLeft;\r\n        node.anchorSquareKeys = anchorInfo.anchorSquareKeys;\r\n    }\r\n\r\n    let eligibleCandidates = [] as EntryCandidate[];\r\n    while(true) {\r\n        processAnchorCombo(node, isForManualFill);\r\n        eligibleCandidates = getEligibleCandidates(node);\r\n        if (node.anchorCombosLeft.length === 0) break;\r\n        if (eligibleCandidates.filter(ec => !ec.iffyWordKey).length > (isForManualFill ? 100 : 0)) break;\r\n    }\r\n\r\n    node.entryCandidates.sort((a, b) => b.score! - a.score!);\r\n    return true;\r\n}\r\n\r\nexport function populateNoHeuristicEntryCandidates(node: FillNode, dontRecalc?: boolean) {\r\n    if (dontRecalc === undefined) dontRecalc = false;\r\n    if (node.entryCandidates.length > 0 && dontRecalc) return;\r\n\r\n    let word = node.fillWord!;\r\n    let squares = deepClone(getSquaresForWord(node.startGrid, word)) as GridSquare[];\r\n    let pattern = getLettersFromSquares(squares);\r\n    let entries = queryIndexedWordList(pattern).sort((a, b) => Globals.qualityClasses!.get(b)! - Globals.qualityClasses!.get(a)!);\r\n\r\n    node.entryCandidates = [];\r\n    entries.forEach(entry => {\r\n        node.entryCandidates.push({\r\n            word: entry,\r\n            score: getWordScore(entry),\r\n            isViable: true,\r\n            hasBeenChained: false,\r\n            wasChainFailure: false,\r\n            crossScore: 0,\r\n            minCrossScore: 0,\r\n        } as EntryCandidate);\r\n    });\r\n}\r\n\r\nfunction populateFillWordAnchors(squares: GridSquare[], calculatedSquares?: Map<string, string[]>):\r\n    { anchorSquareKeys: string[], anchorCombosLeft: [string, string][] } {\r\n    let anchorKeyCounts = [] as [string, number][];\r\n\r\n    squares.forEach(sq => {\r\n        let count = (calculatedSquares && calculatedSquares.has(squareKey(sq))) ? \r\n            calculatedSquares!.get(squareKey(sq))!.length : constraintLetterCount(sq);\r\n        if (count === 0) return; // don't anchor iffy\r\n\r\n        if (anchorKeyCounts.length < 2) {\r\n            anchorKeyCounts.push([squareKey(sq), count]);\r\n            anchorKeyCounts.sort((a, b) => a[1] - b[1]);\r\n            return;\r\n        }\r\n\r\n        if (count < anchorKeyCounts[1][1]) {\r\n            anchorKeyCounts[1] = [squareKey(sq), count];\r\n            anchorKeyCounts.sort((a, b) => a[1] - b[1]);\r\n        }\r\n    });\r\n\r\n    if (anchorKeyCounts.length < 2) {\r\n        return {\r\n            anchorSquareKeys: [],\r\n            anchorCombosLeft: [],\r\n        };\r\n    }\r\n\r\n    let anchorSquareKeys = [anchorKeyCounts[0][0], anchorKeyCounts[1][0]];\r\n    let combos = generateAnchorCombos(squares, anchorSquareKeys, calculatedSquares);\r\n\r\n    return {\r\n        anchorSquareKeys: anchorSquareKeys,\r\n        anchorCombosLeft: combos,\r\n    };\r\n}\r\n\r\nconst letterFrequencies = {\r\n    \"A\": 8.2, \"B\": 1.5, \"C\": 2.8, \"D\": 4.3,\r\n    \"E\": 13, \"F\": 2.2, \"G\": 2, \"H\": 6.1,\r\n    \"I\": 7, \"J\": 0.15, \"K\": 0.77, \"L\": 4,\r\n    \"M\": 2.4, \"N\": 6.7, \"O\": 7.5, \"P\": 1.9,\r\n    \"Q\": 0.095, \"R\": 6, \"S\": 6.3, \"T\": 9.1,\r\n    \"U\": 2.8, \"V\": 0.98, \"W\": 2.4, \"X\": 0.15,\r\n    \"Y\": 2, \"Z\": 0.074,\r\n} as any;\r\n\r\nfunction generateAnchorCombos(squares: GridSquare[], anchorSquareKeys: string[], \r\n    calculatedSquares?: Map<string, string[]>): [string, string][] {\r\n    let constraintLetters = anchorSquareKeys\r\n        .map(sqKey => squares.find(sq => squareKey(sq) === sqKey)!)\r\n        .map(sq => sq.content ? [sq.content!] : (calculatedSquares && calculatedSquares.has(squareKey(sq))) ? \r\n        calculatedSquares!.get(squareKey(sq))! : sq.viableLetters || fullAlphabet);\r\n\r\n    let combos = [] as [string, string][];\r\n    let comboScores = new Map<string, number>();\r\n    for (var letter1 of constraintLetters[0]) {\r\n        for (var letter2 of constraintLetters[1]) {\r\n            combos.push([letter1, letter2]);\r\n            comboScores.set(`[${letter1},${letter2}]`, (letterFrequencies[letter1] + letterFrequencies[letter2]) * Math.random());\r\n        }\r\n    }\r\n\r\n    combos.sort((a, b) => {\r\n        return comboScores.get(`[${a[0]},${a[1]}]`)! - comboScores.get(`[${b[0]},${b[1]}]`)!;\r\n    });\r\n\r\n    return combos;\r\n}\r\n\r\nfunction processAnchorCombo(node: FillNode, isForManualFill: boolean) {\r\n    let grid = node.startGrid;\r\n    let combo = node.anchorCombosLeft.pop()!;\r\n\r\n    let fillWordKey = wordKey(node.fillWord!);\r\n    let wordSquares = getSquaresForWord(grid, node.fillWord!);\r\n    let patternWithAnchor = getLettersFromSquares(wordSquares);\r\n    node.anchorSquareKeys.forEach((sqKey, i) => {\r\n        patternWithAnchor = insertLetterIntoPattern(patternWithAnchor, combo[i], wordSquares, sqKey);\r\n    });\r\n    if (isForManualFill && isWordFull(wordSquares)) {\r\n        node.entryCandidates = [];\r\n        node.entryCandidates.push({\r\n            word: patternWithAnchor,\r\n            score: 1,\r\n            isViable: true,\r\n            hasBeenChained: false,\r\n            wasChainFailure: false,\r\n            crossScore: 0,\r\n            minCrossScore: 0,\r\n        } as EntryCandidate);\r\n        return;\r\n    }\r\n\r\n    let entries = getFilteredEntries(wordSquares, patternWithAnchor, undefined, grid.usedWords);\r\n    let iffyWordKey = isForManualFill ? Globals.manualIffyKey : node.iffyWordKey;\r\n    let maxFilteredEntryCount = entries.length > 0 ? 100_000 / entries.length : 1;\r\n    entries.forEach(entry => {\r\n        let success = processEntry(entry, maxFilteredEntryCount, iffyWordKey);\r\n\r\n        if (!success && !node.iffyWordKey && Globals.maxIffyLength! > 0) {\r\n            let crossKeys = getUnfilledCrosses(grid, node.fillWord!).map(wordKey);\r\n            crossKeys.forEach(ck => {\r\n                let cross = grid.words.get(ck)!;\r\n                if (wordLength(cross) > Globals.maxIffyLength!) return;\r\n                processEntry(entry, maxFilteredEntryCount, ck);\r\n            });\r\n        }\r\n    });\r\n\r\n    node.entryCandidates.forEach(ec => {\r\n        ec.score = calculateEntryCandidateScore(node, ec);\r\n    });\r\n\r\n    function processEntry(entry: string, maxCount: number, iffyWordKey?: string): boolean {\r\n        let isViable = true;\r\n        let distillIndex = 1;\r\n        let calculatedSquares = new Map<string, string[]>();\r\n        let crossScore = 0;\r\n        let minCrossScore = 1e8;\r\n        let usedWords = deepClone(grid.usedWords) as Map<string, boolean>;\r\n        usedWords.set(entry, true);\r\n        let batchKeys = new Map<string, boolean>();\r\n        batchKeys.set(fillWordKey, true);\r\n        let filledCrosses = new Map<string, boolean>();\r\n        let filteredEntriesCount = 0;\r\n\r\n        while(true) {\r\n            let foundCountReduction = false;\r\n            let processedIffy = false;\r\n            let nextBatchKeys = new Map<string, boolean>();\r\n    \r\n            // eslint-disable-next-line\r\n            batchKeys.forEach((_, wKey) => {\r\n                if (!isViable) return;\r\n                if (distillIndex > 1 && filteredEntriesCount > maxCount) return;\r\n\r\n                let word = grid.words.get(wKey)!;\r\n                let wordSquares = getSquaresForWord(grid, word);\r\n                if (wKey === iffyWordKey && !processedIffy) {\r\n                    wordSquares.forEach(sq => {\r\n                        if (!sq.content)\r\n                            sq.viableLetters = deepClone(fullAlphabet);\r\n                    });\r\n                    processedIffy = true;\r\n                }\r\n                if (distillIndex === 1) {\r\n                    wordSquares.forEach((sq, i) => {\r\n                        calculatedSquares.set(squareKey(sq), [entry[i]]);\r\n                    });\r\n                }\r\n\r\n                let crosses = getAllCrosses(grid, word);\r\n                crosses.forEach(cross => {\r\n                    if (!isViable) return;\r\n                    let crossKey = wordKey(cross);\r\n                    if (nextBatchKeys.has(crossKey)) return;\r\n                    if (crossKey === fillWordKey || filledCrosses.has(crossKey)) return;\r\n\r\n                    let crossSquares = getSquaresForWord(grid, cross);\r\n                    if(isWordFull(crossSquares)) return;\r\n                    let crossPattern = getLettersFromSquares(crossSquares);\r\n                    let filteredEntries = [] as string[];\r\n                    let anchorInfo = populateFillWordAnchors(crossSquares, calculatedSquares);\r\n                    if (anchorInfo.anchorCombosLeft.length > 20) {\r\n                        filteredEntriesCount += 500;\r\n                        crossScore += 300;\r\n                        if (300 < minCrossScore) minCrossScore = 300;\r\n                        return;\r\n                    }\r\n\r\n                    anchorInfo.anchorCombosLeft.forEach(combo => {\r\n                        let newPattern = crossPattern;\r\n                        anchorInfo.anchorSquareKeys.forEach((sqKey, i) => {\r\n                            newPattern = insertLetterIntoPattern(newPattern, combo[i], crossSquares, sqKey);\r\n                        });\r\n                        filteredEntries.push(...getFilteredEntries(crossSquares, newPattern, calculatedSquares, usedWords));\r\n                        if (distillIndex === 1 && anchorInfo.anchorCombosLeft.length === 1 && !newPattern.includes(\"-\")) {\r\n                            usedWords.set(newPattern, true);\r\n                            filledCrosses.set(crossKey, true);\r\n                        }\r\n                    });\r\n        \r\n                    if (filteredEntries.length === 0) {\r\n                        isViable = false;\r\n                        return;\r\n                    }\r\n                    filteredEntriesCount += filteredEntries.length;\r\n\r\n                    if (distillIndex === 1) {\r\n                        let score = sum(filteredEntries.map(fe => getWordScore(fe)));\r\n                        crossScore += score;\r\n                        if (score < minCrossScore) minCrossScore = score;\r\n                    }\r\n        \r\n                    crossSquares.forEach((sq, i) => {\r\n                        let newMatrix = Array<boolean>(26).fill(false);\r\n                        filteredEntries.forEach(entry => {\r\n                            newMatrix[entry[i].charCodeAt(0) - 65] = true;\r\n                        });\r\n                        let letters = letterMatrixToLetterList(newMatrix);\r\n\r\n                        let existingCounts = calculatedSquares.get(squareKey(sq))!;\r\n                        if (!existingCounts || existingCounts.length > letters.length)\r\n                            foundCountReduction = true;\r\n\r\n                        calculatedSquares.set(squareKey(sq), letters);\r\n                    });\r\n\r\n                    nextBatchKeys.set(crossKey, true);\r\n                });\r\n            });\r\n\r\n            //console.log(`${distillIndex} ${filteredEntriesCount}`)\r\n            if (!foundCountReduction) break;\r\n            if (!isViable) break;\r\n\r\n            batchKeys = nextBatchKeys;\r\n            distillIndex++;\r\n        }\r\n\r\n        if (!isViable) return false;\r\n\r\n        if (crossScore > node.topCrossScore) node.topCrossScore = crossScore;\r\n        if (minCrossScore > node.topMinCrossScore) node.topMinCrossScore = minCrossScore;\r\n\r\n        let iffyEntry = undefined as string | undefined;\r\n        if (iffyWordKey) {\r\n            let iffyWord = grid.words.get(iffyWordKey)!;\r\n            let iffySquares = getSquaresForWord(grid, iffyWord);\r\n            let pattern = getLettersFromSquares(iffySquares);\r\n            iffySquares.forEach((isq, idx) => {\r\n                let calSq = calculatedSquares.get(squareKey(isq));\r\n                if (!isq.content && calSq && calSq.length === 1)\r\n                    pattern = pattern.substring(0, idx) + calSq[0] + pattern.substring(idx+1);\r\n            });\r\n            iffyEntry = pattern;\r\n        }\r\n\r\n        if (iffyEntry && usedWords.has(iffyEntry)) return false;\r\n\r\n        node.entryCandidates.push({\r\n            word: entry,\r\n            score: -1,\r\n            isViable: isViable,\r\n            hasBeenChained: false,\r\n            wasChainFailure: false,\r\n            iffyEntry: iffyEntry,\r\n            iffyWordKey: iffyWordKey,\r\n            crossScore: crossScore,\r\n            minCrossScore: minCrossScore,\r\n        } as EntryCandidate);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\nfunction getFilteredEntries(squares: GridSquare[], anchorPattern: string, calculatedSquares?: Map<string, string[]>,\r\n    usedWords?: Map<string, boolean>): string[] {\r\n    let entries = [] as string[];\r\n    broadenAnchorPatterns(squares, anchorPattern, calculatedSquares).forEach(pattern => {\r\n        entries.push(...queryIndexedWordList(pattern));\r\n    });\r\n\r\n    let filteredEntries = entries.filter(entry => {\r\n        if (usedWords && usedWords.has(entry)) return false;\r\n\r\n        for (let i = 0; i < squares.length; i++) {\r\n            let sq = squares[i];\r\n            let sqKey = squareKey(sq);\r\n            \r\n            if (calculatedSquares && calculatedSquares.has(sqKey) && !calculatedSquares.get(sqKey)!.includes(entry[i])) {\r\n                return false;\r\n            }\r\n            else if (sq.viableLetters && !sq.viableLetters.includes(entry[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        \r\n        return true;\r\n    });\r\n\r\n    return filteredEntries;\r\n}\r\n\r\nfunction broadenAnchorPatterns(squares: GridSquare[], anchorPattern: string, calculatedSquares?: Map<string, string[]>): string[] {\r\n    let constraintCounts = squares.map((sq, i) => {\r\n        if (anchorPattern[i] !== \"-\") return [i, [anchorPattern[i]]] as [number, string[]];\r\n        if (calculatedSquares && calculatedSquares.has(squareKey(sq))) {\r\n            return [i, calculatedSquares.get(squareKey(sq))!] as [number, string[]];\r\n        }\r\n        return [i, sq.viableLetters || fullAlphabet] as [number, string[]];\r\n    })\r\n    .filter(x => x[1].length > 0).sort((a, b) => b[1].length - a[1].length);\r\n\r\n    let curPatterns = [anchorPattern];\r\n    while(constraintCounts.length > 0 && curPatterns.length < 12) {\r\n        let lowestCount = constraintCounts.pop()!;\r\n        if (lowestCount[1].length >= 6) \r\n            return curPatterns;\r\n\r\n        let index = lowestCount[0];\r\n        let viableLetters = lowestCount[1];\r\n        let newCurPatterns = [] as string[];\r\n        // eslint-disable-next-line\r\n        viableLetters.forEach(ltr => {\r\n            curPatterns.forEach(pattern => {\r\n                newCurPatterns.push(pattern.substring(0, index) + ltr + pattern.substring(index+1));\r\n            });\r\n        });\r\n        curPatterns = newCurPatterns;\r\n    }\r\n\r\n    return curPatterns;\r\n}\r\n\r\nfunction calculateEntryCandidateScore(node: FillNode, ec: EntryCandidate): number {\r\n    let wordScore = getWordScore(ec.word);\r\n    let crossScore = node.topCrossScore > 0 ? ec.crossScore / node.topCrossScore : 1;\r\n    let minCrossScore = node.topMinCrossScore > 0 ? ec.minCrossScore / node.topMinCrossScore : 1;\r\n    let ret = (crossScore + minCrossScore) * wordScore * (ec.iffyWordKey ? 1 : 100);\r\n    return ret;\r\n}\r\n\r\nfunction insertLetterIntoPattern(pattern: string, newLetter: string, squares: GridSquare[], sqKey: string): string {\r\n    let i = squares.findIndex(sq => squareKey(sq) === sqKey);\r\n    return pattern.substring(0, i) + newLetter + pattern.substring(i+1);\r\n}\r\n","import { GridSquare } from \"../models/GridSquare\";\r\nimport { GridState } from \"../models/GridState\";\r\nimport { GridWord } from \"../models/GridWord\";\r\nimport { SquareType } from \"../models/SquareType\";\r\nimport { WordDirection } from \"../models/WordDirection\";\r\nimport Globals from './windowService';\r\nimport { Puzzle } from \"../models/Puzzle\";\r\nimport { getLettersFromSquares } from \"./grid\";\r\nimport { ContentType } from \"../models/ContentType\";\r\nimport { Section } from \"../models/Section\";\r\nimport { SectionCandidate } from \"../models/SectionCandidate\";\r\nimport { generateGridSections } from \"./section\";\r\n\r\nexport const fullAlphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".split(\"\");\r\n\r\nexport function average(arr: number[]): number {\r\n    return arr.reduce((a,b) => a + b, 0) / arr.length;\r\n}\r\n\r\nexport function sum(arr: number[]): number {\r\n    return arr.reduce((a,b) => a + b, 0);\r\n}\r\n\r\n// https://stackoverflow.com/questions/38416020/deep-copy-in-es6-using-the-spread-syntax\r\nexport function deepClone(obj: any): any {\r\n    if(typeof obj !== 'object' || obj === null) {\r\n        return obj;\r\n    }\r\n\r\n    if(obj instanceof Date) {\r\n        return new Date(obj.getTime());\r\n    }\r\n\r\n    if(obj instanceof Map) {\r\n        return new Map(Array.from(obj.entries()));\r\n    }\r\n\r\n    if(obj instanceof Array) {\r\n        return obj.reduce((arr, item, i) => {\r\n            arr[i] = deepClone(item);\r\n            return arr;\r\n        }, []);\r\n    }\r\n\r\n    if(obj instanceof Object) {\r\n        return Object.keys(obj).reduce((newObj: any, key) => {\r\n            newObj[key] = deepClone(obj[key]);\r\n            return newObj;\r\n        }, {})\r\n    }\r\n}\r\n\r\nexport function compareTuples(first: [number, number], second: [number, number]): boolean {\r\n    return first[0] === second[0] && first[1] === second[1];\r\n}\r\n\r\nexport function isBlackSquare(sq: GridSquare): boolean {\r\n    return sq.type === SquareType.Black;\r\n}\r\n\r\nexport function otherDir(dir: WordDirection): WordDirection {\r\n    return dir === WordDirection.Across ? WordDirection.Down : WordDirection.Across;\r\n}\r\n\r\nexport function getSquaresForWord(grid: GridState, word: GridWord): GridSquare[] {\r\n    let row = word.start[0];\r\n    let col = word.start[1];\r\n    let squares = [grid.squares[row][col]];\r\n    while (!compareTuples([row, col], word.end)) {\r\n        row = word.direction === WordDirection.Across ? row : row+1;\r\n        col = word.direction === WordDirection.Across ? col+1 : col;\r\n        squares.push(grid.squares[row][col]);\r\n    }\r\n\r\n    return squares;\r\n}\r\n\r\nexport function getWordAtSquare(grid: GridState, row: number, col: number, dir: WordDirection): GridWord | undefined {\r\n    let ret = undefined as GridWord | undefined;\r\n\r\n    grid.words.forEach((word, _) => {\r\n        if (dir === WordDirection.Across && word.direction === dir && word.start[0] === row &&\r\n            word.start[1] <= col && word.end[1] >= col)\r\n            ret = word;\r\n        if (dir === WordDirection.Down && word.direction === dir && word.start[1] === col &&\r\n            word.start[0] <= row && word.end[0] >= row)\r\n            ret = word;\r\n    });\r\n\r\n    return ret;\r\n}\r\n\r\nexport function newWord(): GridWord {\r\n    return {\r\n        number: undefined,\r\n        direction: WordDirection.Across,\r\n        start: [-1, -1],\r\n        end: [-1, -1],\r\n    }\r\n}\r\n\r\nexport function doesWordContainSquare(word: GridWord, row: number, col: number): boolean {\r\n    if (word.direction === WordDirection.Across) {\r\n        return word.start[0] === row && word.start[1] <= col && word.end[1] >= col;\r\n    }\r\n    else {\r\n        return word.start[1] === col && word.start[0] <= row && word.end[0] >= row;\r\n    }\r\n}\r\n\r\nexport function isWordEmpty(squares: GridSquare[]): boolean {\r\n    return !squares.find(x => !isBlackSquare(x) && x.content);\r\n}\r\n\r\nexport function isWordFull(squares: GridSquare[]): boolean {\r\n    return !squares.find(x => !isBlackSquare(x) && !x.content);\r\n}\r\n\r\nexport function shuffleArray(array: any[]) {\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1));\r\n        [array[i], array[j]] = [array[j], array[i]];\r\n    }\r\n}\r\n\r\nexport function forAllGridSquares(grid: GridState, func: (sq: GridSquare) => void) {\r\n    grid.squares.forEach(row => {\r\n        row.forEach(sq => {\r\n            func(sq);\r\n        });\r\n    });\r\n}\r\n\r\nexport function wordLength(word: GridWord): number {\r\n    if (word.direction === WordDirection.Across)\r\n        return word.end[1] - word.start[1] + 1;\r\n    else\r\n        return word.end[0] - word.start[0] + 1;\r\n}\r\n\r\nexport function newPuzzle(): Puzzle {\r\n    return {\r\n        title: \"\",\r\n        author: \"\",\r\n        copyright: \"\",\r\n        clues: new Map<string, string>(),\r\n        notes: \"\",\r\n    } as Puzzle;    \r\n}\r\n\r\nexport function wordKey(word: GridWord): string {\r\n    return `[${word.start[0]},${word.start[1]},${word.direction === WordDirection.Across ? \"A\" : \"D\"}]`;\r\n}\r\n\r\nexport function squareKey(sq: GridSquare | undefined): string {\r\n    return sq ? `[${sq.row},${sq.col}]` : \"\";\r\n}\r\n\r\nexport function getGrid(): GridState {\r\n    return Globals.activeGrid!;\r\n}\r\n\r\nexport function getSection(): Section {\r\n    return Globals.sections!.get(Globals.activeSectionId!)!;\r\n}\r\n\r\nexport function getSelectedWord(): GridWord | undefined {\r\n    let grid = getGrid();\r\n    if (!Globals.selectedWordKey) return undefined;\r\n    return grid.words.get(Globals.selectedWordKey);\r\n}\r\n\r\nexport function mapKeys<TKey, TVal>(map: Map<TKey, TVal>): TKey[] {\r\n    return Array.from(map.keys()) || [];\r\n}\r\n\r\nexport function mapValues<TKey, TVal>(map: Map<TKey, TVal>): TVal[] {\r\n    return Array.from(map.values()) || [];\r\n}\r\n\r\nexport function isUserFilled(sq: GridSquare): boolean {\r\n    return sq.contentType === ContentType.User || sq.contentType === ContentType.ChosenWord \r\n        || sq.contentType === ContentType.ChosenSection;\r\n}\r\n\r\nexport function isUserOrWordFilled(sq: GridSquare): boolean {\r\n    return sq.contentType === ContentType.User || sq.contentType === ContentType.ChosenWord;\r\n}\r\n\r\nexport function isAcross(word: GridWord): boolean {\r\n    return word.direction === WordDirection.Across;\r\n}\r\n\r\nexport function getSquareAtKey(grid: GridState, squareKey: string): GridSquare {\r\n    let tokens = squareKey.substring(1, squareKey.length - 1).split(\",\");\r\n    return grid.squares[+tokens[0]][+tokens[1]];\r\n}\r\n\r\nexport function isPartOfIffyWord(sq: GridSquare): boolean {\r\n    if (!sq.viableLetters) return false;\r\n    return sq.viableLetters.length === 0;\r\n}\r\n\r\n// https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\r\nexport function shuffle(array: any[]) {\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1));\r\n        [array[i], array[j]] = [array[j], array[i]];\r\n    }\r\n}\r\n\r\nexport function getEntryAtWordKey(grid: GridState, wordKey: string): string {\r\n    return getLettersFromSquares(getSquaresForWord(grid, grid.words.get(wordKey)!));\r\n}\r\n\r\nexport function getSectionCandidatesFromKeys(keys: string[]): SectionCandidate[] {\r\n    return keys\r\n        .map(sck => mapValues(Globals.sections!).find(sec => sec.candidates.has(sck))?.candidates.get(sck))\r\n        .filter(sck => sck !== undefined)\r\n        .map(sck => sck!);\r\n}\r\n\r\nexport function constraintLetterCount(sq: GridSquare): number {\r\n    if (!sq.viableLetters) return 26;\r\n\r\n    return sq.viableLetters.length;\r\n}\r\n\r\nexport function isPatternFull(pattern: string): boolean {\r\n    return !pattern.includes(\"-\");\r\n}\r\n\r\nexport function getUserFilledSections(grid: GridState): Section[] {\r\n    let sectionCandidates = getSectionCandidatesFromKeys(mapKeys(grid.userFilledSectionCandidates));\r\n    return sectionCandidates.map(sc => Globals.sections!.get(sc.sectionId)!);\r\n}\r\n\r\nexport function getUserFilledSectionCandidates(grid: GridState): SectionCandidate[] {\r\n    return getSectionCandidatesFromKeys(mapKeys(grid.userFilledSectionCandidates));\r\n}\r\n\r\nexport function initializeSessionGlobals() {\r\n    let grid = getGrid();\r\n    Globals.sections = generateGridSections(grid);\r\n    Globals.activeSectionId = 0;\r\n    Globals.hoverSectionId = undefined;\r\n    Globals.selectedSectionIds = new Map<number, boolean>();\r\n    Globals.selectedSectionIds.set(0, true);\r\n    Globals.selectedSectionCandidateKeys = new Map<number, string>();\r\n}\r\n\r\nexport function letterMatrixToLetterList(matrix: boolean[]): string[] {\r\n    return matrix.map((x, i) => x ? String.fromCharCode(i + 65) : \"\").filter(x => x);\r\n}\r\n\r\nexport function letterListToLetterMatrix(list: string[]): boolean[] {\r\n    let matrix = Array<boolean>(26).fill(false);\r\n    list.forEach(ltr => {\r\n        matrix[ltr.charCodeAt(0)] = true;\r\n    });\r\n    return matrix;\r\n}\r\n","import { ContentType } from '../models/ContentType';\r\nimport { EntryCandidate } from '../models/EntryCandidate';\r\nimport { FillNode } from '../models/FillNode';\r\nimport { GridSquare } from '../models/GridSquare';\r\nimport { GridState } from '../models/GridState';\r\nimport { GridWord } from '../models/GridWord';\r\nimport { QualityClass } from '../models/QualityClass';\r\nimport { Section } from '../models/Section';\r\nimport { WordDirection } from '../models/WordDirection';\r\nimport { populateAndScoreEntryCandidates } from './entryCandidates';\r\nimport { processAndInsertChosenEntry } from './insertEntry';\r\nimport { PriorityQueue, priorityQueue } from './priorityQueue';\r\nimport { getSectionString, getSectionsWithWord, insertSectionCandidateIntoGrid, newSectionCandidate } from './section';\r\nimport { deepClone, getSquaresForWord, mapKeys, isWordFull, \r\n    getWordAtSquare, otherDir, mapValues, getSection, getGrid, wordKey } from './util';\r\nimport Globals from './windowService';\r\n\r\nexport function fillSectionWord(): boolean {\r\n    let section = getSection();\r\n    let fillQueue = section.fillQueue;\r\n    if (!fillQueue) {\r\n        let newFillQueue = priorityQueue<FillNode>();\r\n        populateSeedNodes(newFillQueue);\r\n        fillQueue = newFillQueue;\r\n        section.fillQueue = newFillQueue;\r\n    }\r\n\r\n    let node = fillQueue.peek()!;\r\n    if (!node) {\r\n        populateSeedNodes(fillQueue);\r\n        node = fillQueue.peek()!;\r\n        if (!node) {\r\n            return false;\r\n        }\r\n    }\r\n    while (node.needsNewPriority || node.shouldBeDeleted) {\r\n        node.needsNewPriority = false;\r\n        fillQueue.pop();\r\n        if (!node.shouldBeDeleted) fillQueue.insert(node, calculateNodePriority(node));\r\n        node = fillQueue.peek()!;\r\n        if (!node) return false;\r\n    }\r\n    while (node.isChainNode && node.chainId! !== Globals.curChainId!) {\r\n        fillQueue.pop();\r\n        node = fillQueue.peek()!;\r\n        if (!node) return false;\r\n    }\r\n\r\n    if (!node.isChainNode && Globals.activeGrid !== node.startGrid) {\r\n        Globals.activeGrid = node.startGrid;\r\n        return true;\r\n    }\r\n\r\n    let success = processSectionNode(node, section);\r\n    if (success) {\r\n        let sectionString = getSectionString(node.endGrid, section);\r\n        // is section filled?\r\n        if (!sectionString.includes(\"-\")) {\r\n            let newSecCandidateFound = false;\r\n            if (!section.candidates.has(sectionString)) {\r\n                let newCandidate = newSectionCandidate(node, section);\r\n                section.candidates.set(sectionString, newCandidate);\r\n                Globals.activeGrid = node.endGrid;\r\n                newSecCandidateFound = true;\r\n            }\r\n            \r\n            invalidateChainNode(node, newSecCandidateFound);\r\n            fillQueue.pop();\r\n            return true;\r\n        }\r\n\r\n        Globals.activeGrid = node.endGrid;\r\n        let newNode = makeNewNode(node.endGrid, node.depth + 1, true, node);\r\n        \r\n        if (section.id === 0) {\r\n            let nextFillWord = selectWordToFill(node, getSection());\r\n            let curSections = getSectionsWithWord(node.fillWord!);\r\n            let nextSections = getSectionsWithWord(nextFillWord!);\r\n            if (curSections.length > 0 && !curSections.find(cs => nextSections.find(ns => ns.id === cs.id))) {\r\n                newNode = makeNewNode(node.endGrid, node.depth + 1, false, node, true);\r\n                Globals.curChainId!++;\r\n            }\r\n        }\r\n        \r\n        fillQueue.insert(newNode, calculateNodePriority(newNode));\r\n    }\r\n    else {\r\n        fillQueue.pop();\r\n        if (node.isChainNode) invalidateChainNode(node);\r\n        fillSectionWord();\r\n    }\r\n\r\n    Globals.selectedWordNode = undefined;\r\n    return true;\r\n}\r\n\r\nfunction invalidateChainNode(node: FillNode, newSecCandidateFound?: boolean) {\r\n    if (newSecCandidateFound === undefined) newSecCandidateFound = false;\r\n\r\n    let parent = node.parent!;\r\n    if (!parent) return;\r\n\r\n    let prevCandidate = parent.chosenEntry!;\r\n    if (parent.isChainNode) {\r\n        if (prevCandidate)\r\n            prevCandidate.wasChainFailure = true;\r\n        parent.backtracks++;\r\n    }\r\n    else {\r\n        if (prevCandidate)\r\n            prevCandidate.hasBeenChained = true;\r\n    }\r\n\r\n    parent.chosenEntry = undefined;\r\n    parent.iffyWordKey = parent.parent ? parent.parent.iffyWordKey : undefined;\r\n    parent.endGrid = deepClone(parent.startGrid);\r\n\r\n    if (parent.backtracks >= 3) {\r\n        if (parent.parent && !parent.parent.isChainNode) {\r\n            parent.isChainNode = false;\r\n            parent.needsNewPriority = true;\r\n            Globals.curChainId!++;\r\n        }\r\n            \r\n        invalidateChainNode(parent);\r\n    }\r\n\r\n    if (newSecCandidateFound) {\r\n        if (node.iffyWordKey && node.chainBaseNode!.chainIffyCandidates < 24) {\r\n            node.chainBaseNode!.chainIffyCandidates++;\r\n            return;\r\n        }\r\n        else if (!node.iffyWordKey && node.chainBaseNode!.chainGoodCandidates < 4) {\r\n            node.chainBaseNode!.chainGoodCandidates++;\r\n            return;\r\n        }\r\n\r\n        let curNode = parent;\r\n        while (curNode.parent && (curNode.parent.isChainNode || curNode.parent.isSectionBase)) {\r\n            if (curNode.isSectionBase) curNode.shouldBeDeleted = true;\r\n            curNode = curNode.parent!;\r\n        }\r\n        curNode.isChainNode = false;\r\n        curNode.needsNewPriority = true;\r\n        Globals.curChainId!++;\r\n    }\r\n}\r\n\r\nfunction calculateNodePriority(node: FillNode): number {\r\n    let grid = node.startGrid;\r\n    let wordScore = 0;\r\n    grid.usedWords.forEach((_, word) => {\r\n        wordScore += getWordScore(word);\r\n    });\r\n\r\n    let situationScore: number;\r\n    if (node.isChainNode)\r\n        situationScore = 1e8 + 10000*(node.depth+1);\r\n    else if (node.isSectionBase)\r\n        situationScore = (10000 + node.depth) * 10000;\r\n    else\r\n        situationScore = (10000 - node.depth) * 10000;\r\n\r\n    return wordScore + situationScore;\r\n}\r\n\r\nfunction populateSeedNodes(fillQueue: PriorityQueue<FillNode>) {\r\n    let grid = getGrid();\r\n    let selectedSectionIds = [Globals.activeSectionId!]; //Globals.selectedSectionIds!.size > 0 ? mapKeys(Globals.selectedSectionIds!) : [0];\r\n    let activeSection = getSection();\r\n    let connectionIds = mapKeys(activeSection.connections)\r\n        .filter(id => selectedSectionIds.includes(id) && Globals.sections!.get(id)!.selectedCandidate === undefined\r\n            && Globals.sections!.get(id)!.candidates.size > 0)\r\n        .sort();\r\n    let candidateCounts = connectionIds.map(i => Globals.sections!.get(i)!.candidates.size);\r\n    \r\n    getNewPermutations(candidateCounts, activeSection);\r\n    activeSection.comboPermsQueue.forEach(perm => {\r\n        let node = makeNewNode(grid, 0, false, undefined);\r\n        if (perm[0] === -1) {\r\n            fillQueue.insert(node, calculateNodePriority(node));\r\n            return;\r\n        }\r\n        let wasSuccess = true;\r\n        for (let i = 0; i < perm.length; i++) {\r\n            let sortedCandidates = mapValues(Globals.sections!.get(connectionIds[i])!.candidates)\r\n                .sort((a, b) => b.score - a.score);\r\n            let candidate = sortedCandidates[perm[i]];\r\n            if (!insertSectionCandidateIntoGrid(node.startGrid, candidate, ContentType.Autofill))\r\n                wasSuccess = false;\r\n        }\r\n        if (wasSuccess)\r\n            fillQueue.insert(node, calculateNodePriority(node));\r\n    });\r\n}\r\n\r\nfunction getNewPermutations(candidateCounts: number[], section: Section) {\r\n    function comboKey(perm: number[]): string {\r\n        return \"[\" + perm.map(n => n.toString()).join(\",\") + \"]\";\r\n    }\r\n\r\n    if (section.comboPermsUsed.size > 0 && section.comboPermsQueue.length > 0 && section.comboPermsQueue[0][0] === -1)\r\n        section.comboPermsQueue.shift();\r\n    if (section.comboPermsUsed.size > 0 && section.comboPermsQueue.length === 0) return;\r\n\r\n    if (candidateCounts.length === 0) {\r\n        let defaultCombo = [-1];\r\n        section.comboPermsQueue = [defaultCombo];\r\n        section.comboPermsUsed.set(comboKey(defaultCombo), true);\r\n        return;\r\n    }\r\n\r\n    if (section.comboPermsUsed.size === 0) {\r\n        let allOnes = [] as number[];\r\n        for(let i = 0; i < candidateCounts.length; i++) allOnes.push(1);\r\n        section.comboPermsQueue = [allOnes];\r\n        section.comboPermsUsed.set(comboKey(allOnes), true);\r\n        return;\r\n    }\r\n\r\n    while(true) {\r\n        let perm = section.comboPermsQueue.shift()!;\r\n        if (!perm) break;\r\n        let foundNew = false;\r\n\r\n        for(let i = 0; i < perm.length; i++) {\r\n            if (perm[i] === candidateCounts[i] - 1) continue;\r\n    \r\n            let newPerm = deepClone(perm);\r\n            newPerm[i]++;\r\n            let newPermKey = comboKey(newPerm);\r\n            if (section.comboPermsUsed.has(newPermKey)) continue;\r\n\r\n            section.comboPermsUsed.set(newPermKey, true);\r\n            foundNew = true;\r\n            section.comboPermsQueue.push(newPerm);\r\n        }\r\n\r\n        if (foundNew) break;\r\n    }\r\n}\r\n\r\nexport function processSectionNode(node: FillNode, section: Section): boolean {\r\n    if (!node.fillWord)\r\n        node.fillWord = selectWordToFill(node, section);\r\n\r\n    if (node.anchorSquareKeys.length === 0 || node.anchorCombosLeft.length > 0) {\r\n        let areEligibleCandidates = populateAndScoreEntryCandidates(node, false);\r\n        if (!areEligibleCandidates) return false;\r\n    }\r\n\r\n    let eligibleCandidates = getEligibleCandidates(node);\r\n    if (eligibleCandidates.length > 0) {\r\n        node.chosenEntry = chooseEntryFromCandidates(eligibleCandidates);\r\n        processAndInsertChosenEntry(node);\r\n        return true;\r\n    }\r\n    \r\n    return false;\r\n}\r\n\r\nexport function makeNewNode(grid: GridState, depth: number, isChainNode: boolean, parent: FillNode | undefined, \r\n    isSectionBase?: boolean): FillNode {\r\n    return {\r\n        startGrid: deepClone(grid),\r\n        endGrid: deepClone(grid),\r\n        entryCandidates: [],\r\n        depth: depth,\r\n        isChainNode: isChainNode,\r\n        isSectionBase: !!isSectionBase,\r\n        backtracks: 0,\r\n        parent: parent,\r\n        chainBaseNode: isChainNode ? (parent!.isChainNode ? parent!.chainBaseNode : parent!) : undefined,\r\n        needsNewPriority: false,\r\n        shouldBeDeleted: false,\r\n        anchorSquareKeys: [],\r\n        anchorCombosLeft: [],\r\n        viableLetterCounts: new Map<string, Map<string, number>>(),\r\n        iffyWordKey: parent ? parent.iffyWordKey : undefined,\r\n        chainGoodCandidates: parent ? parent.chainGoodCandidates : 0,\r\n        chainIffyCandidates: parent ? parent.chainIffyCandidates : 0,\r\n        chainId: Globals.curChainId!,\r\n        topCrossScore: 0,\r\n        topMinCrossScore: 0,\r\n    } as FillNode;\r\n}\r\n\r\nfunction selectWordToFill(node: FillNode, section: Section): GridWord | undefined {\r\n    let grid = node.startGrid;\r\n\r\n    for (let key of section.wordOrder) {\r\n        let word = grid.words.get(key)!;\r\n        let squares = getSquaresForWord(grid, word);\r\n        if (wordKey(word) !== node.iffyWordKey && !isWordFull(squares))\r\n            return word;\r\n    }\r\n\r\n    return undefined;\r\n}\r\n\r\nexport function getPositionOfCross(wordSquares: GridSquare[], crossSquares: GridSquare[], dir: WordDirection): number {\r\n    return dir === WordDirection.Across ? \r\n            wordSquares[0].row - crossSquares[0].row : \r\n            wordSquares[0].col - crossSquares[0].col;\r\n}\r\n\r\nexport function getAllCrosses(grid: GridState, word: GridWord): GridWord[] {\r\n    let squares = getSquaresForWord(grid, word);\r\n    let crosses = squares\r\n        .map(sq => getWordAtSquare(grid, sq.row, sq.col, otherDir(word.direction)))\r\n        .filter(w => w).map(w => w!);\r\n    return crosses.length > 0 ? crosses : [];\r\n}\r\n\r\nexport function getUnfilledCrosses(grid: GridState, word: GridWord): GridWord[] {\r\n    let squares = getSquaresForWord(grid, word);\r\n    let crosses = squares\r\n        .map(sq => getWordAtSquare(grid, sq.row, sq.col, otherDir(word.direction)))\r\n        .filter(w => w && !isWordFull(getSquaresForWord(grid, w)))\r\n        .map(w => w!);\r\n    return crosses.length > 0 ? crosses : [];\r\n}\r\n\r\nexport function getEligibleCandidates(node: FillNode): EntryCandidate[] {\r\n    if (node.isChainNode) {\r\n        return node.entryCandidates.filter(ec => ec.isViable && !ec.wasChainFailure);\r\n    }\r\n    else {\r\n        return node.entryCandidates.filter(ec => ec.isViable && !ec.hasBeenChained);\r\n    }\r\n}\r\n\r\nfunction chooseEntryFromCandidates(candidates: EntryCandidate[]): EntryCandidate {\r\n    let topScore = candidates[0].score!;\r\n    let total = 0;\r\n    candidates.forEach(c => {\r\n        total += Math.pow(c.score / topScore, 4);\r\n    });\r\n\r\n    let roll = Math.random() * total;\r\n    let runningTotal = 0;\r\n    for (let can of candidates) {\r\n        runningTotal += Math.pow(can.score / topScore, 4);\r\n        if (runningTotal >= roll)\r\n            return can;\r\n    }\r\n\r\n    return candidates[0];\r\n}\r\n\r\nexport function getWordScore(word: string): number {\r\n    let qualityClass = Globals.qualityClasses!.get(word);\r\n    if (!qualityClass) return 0;\r\n\r\n    switch(qualityClass) {\r\n        case QualityClass.Lively: return 12;\r\n        case QualityClass.Normal: return 9;\r\n        case QualityClass.Crosswordese: return 3;\r\n        case QualityClass.Iffy: return 1;\r\n    }\r\n}\r\n","import { ContentType } from \"../models/ContentType\";\r\nimport { FillNode } from \"../models/FillNode\";\r\nimport { GridSquare } from \"../models/GridSquare\";\r\nimport { GridState } from \"../models/GridState\";\r\nimport { GridWord } from \"../models/GridWord\";\r\nimport { Section } from \"../models/Section\";\r\nimport { SectionCandidate } from \"../models/SectionCandidate\";\r\nimport { WordDirection } from \"../models/WordDirection\";\r\nimport { getAllCrosses, getWordScore } from \"./fill\";\r\nimport { generateConstraintInfoForSquares, getLettersFromSquares } from \"./grid\";\r\nimport { forAllGridSquares, getEntryAtWordKey, getGrid, getSquaresForWord, getWordAtSquare, getSquareAtKey, isAcross, \r\n    isBlackSquare, mapKeys, squareKey, wordKey, wordLength, mapValues, isUserOrWordFilled, deepClone } from \"./util\";\r\nimport Globals from './windowService';\r\n\r\nexport function updateSectionFilters() {\r\n    let sections = Globals.sections!;\r\n    let grid = getGrid();\r\n    sections.forEach(sec => {\r\n        sec.candidates.forEach((can, _) => {\r\n            let sqKeys = mapKeys(sec.squares);\r\n            can.isFilteredOut = false;\r\n            for (let sqKey of sqKeys) {\r\n                let gridSq = getSquareAtKey(grid, sqKey);\r\n                let canSq = getSquareAtKey(can.grid, sqKey);\r\n                if (isUserOrWordFilled(gridSq) && canSq.content !== gridSq.content)\r\n                    can.isFilteredOut = true;\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\nexport function getSectionString(grid: GridState, section: Section): string {\r\n    let ret = [] as string[];\r\n    mapKeys(section.squares).sort().forEach(sqKey => {\r\n        let sq = getSquareAtKey(grid, sqKey);\r\n        let content = sq.content;\r\n        ret.push(content ? content! : \"-\");\r\n    });\r\n    return ret.join(\"\");\r\n}\r\n\r\n// returns whether it was a success\r\nexport function insertSectionCandidateIntoGrid(grid: GridState, candidate: SectionCandidate, contentType?: ContentType): boolean {\r\n    if (contentType === undefined) contentType = ContentType.ChosenSection;\r\n    let newGrid = deepClone(grid) as GridState;\r\n    let section = Globals.sections!.get(candidate.sectionId)!;\r\n    let foundDiscrepancy = false;\r\n    section.squares.forEach((_, sqKey) => {\r\n        let sq = getSquareAtKey(newGrid, sqKey);\r\n        let candidateSq = getSquareAtKey(candidate.grid, sqKey);\r\n        if (isUserOrWordFilled(sq) && sq.content! !== candidateSq.content!)\r\n            foundDiscrepancy = true;\r\n        sq.content = candidateSq.content;\r\n        sq.viableLetters = [sq.content!];\r\n        if (!isUserOrWordFilled(sq)) {\r\n            sq.contentType = [ContentType.HoverChosenSection, ContentType.Autofill].includes(contentType!) ? \r\n                ContentType.Autofill : ContentType.ChosenSection;\r\n        }\r\n    });\r\n    if (foundDiscrepancy) return false;\r\n    else {\r\n        forAllGridSquares(newGrid, newSq => {\r\n            grid.squares[newSq.row][newSq.col] = newSq;\r\n        });\r\n    }\r\n\r\n    section.words.forEach((_, key) => {\r\n        let word = grid.words.get(key)!;\r\n        let squares = getSquaresForWord(grid, word);\r\n        grid.usedWords.set(getLettersFromSquares(squares), true);\r\n    });\r\n\r\n    section.neighboringCrosses.forEach((_, key) => {\r\n        let word = grid.words.get(key)!;\r\n        let squares = getSquaresForWord(grid, word);\r\n        generateConstraintInfoForSquares(squares);\r\n    });\r\n\r\n    grid.userFilledSectionCandidates.set(sectionCandidateKey(section, grid), true);\r\n    return true;\r\n}\r\n\r\nexport function generateGridSections(grid: GridState): Map<number, Section> {\r\n    function iterateSection(section: Section, grid: GridState, sq: GridSquare, usedSquares: Map<string, boolean>) {\r\n        section.openSquareCount++;\r\n        usedSquares.set(squareKey(sq), true);\r\n\r\n        getNeighboringSquares(grid, sq).forEach(neighbor => {\r\n            if (!usedSquares.has(squareKey(neighbor)) && isOpenSquare(grid, neighbor)) {\r\n                iterateSection(section, grid, neighbor, usedSquares);\r\n            }\r\n\r\n            [WordDirection.Across, WordDirection.Down].forEach(dir => {\r\n                let word = getWordAtSquare(grid, neighbor.row, neighbor.col, dir)!;\r\n                if (word !== undefined && !section.words.has(wordKey(word))) {\r\n                    section.words.set(wordKey(word), true);\r\n                    let squares = getSquaresForWord(grid, word);\r\n                    squares.forEach(wsq => {\r\n                        section.squares.set(squareKey(wsq), true);\r\n                    });\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    let sections = new Map<number, Section>();\r\n    let usedSquares = new Map<string, boolean>();\r\n    let nextSectionId = 1;\r\n\r\n    // add full grid section\r\n    let fullSection = makeNewSection(0);\r\n    forAllGridSquares(grid, sq => {\r\n        if (!isBlackSquare(sq)) fullSection.squares.set(squareKey(sq), true);\r\n    });\r\n    grid.words.forEach(w => {\r\n        fullSection.words.set(wordKey(w), true);\r\n    });\r\n    sections.set(0, fullSection);\r\n\r\n    // populate sections\r\n    forAllGridSquares(grid, sq => {\r\n        if (!usedSquares.has(squareKey(sq)) && isOpenSquare(grid, sq)) {\r\n            let newSection = makeNewSection(nextSectionId);\r\n            iterateSection(newSection, grid, sq, usedSquares);\r\n            if (newSection.openSquareCount === 1) return;\r\n            sections.set(newSection.id, newSection);\r\n            nextSectionId++;\r\n        }\r\n    });\r\n    if (sections.size === 2) sections.delete(1);\r\n\r\n    // populate stackWords\r\n    sections.forEach(section => {\r\n        section.stackWords = new Map<string, boolean>();\r\n\r\n        section.words.forEach((_, key) => {\r\n            if (section.stackWords.has(key)) return;\r\n\r\n            let word = grid.words.get(key)!;\r\n            let stackedNeighbors = mapKeys(section.words).filter(otherKey => {\r\n                if (otherKey === key) return false;\r\n\r\n                let otherWord = grid.words.get(otherKey)!;\r\n                if (isAcross(word) && isAcross(otherWord) && Math.abs(word.start[0] - otherWord.start[0]) === 1) {\r\n                    let intersectionCount = Math.min(word.end[1], otherWord.end[1]) - Math.max(word.start[1], otherWord.start[1]) + 1;\r\n                    return intersectionCount >= 5;\r\n                }\r\n                if (!isAcross(word) && !isAcross(otherWord) && Math.abs(word.start[1] - otherWord.start[1]) === 1) {\r\n                    let intersectionCount = Math.min(word.end[0], otherWord.end[0]) - Math.max(word.start[0], otherWord.start[0]) + 1;\r\n                    return intersectionCount >= 5;\r\n                }\r\n                return false;\r\n            }); \r\n\r\n            if (stackedNeighbors.length > 0) {\r\n                section.stackWords.set(key, true);\r\n                stackedNeighbors.forEach(sk => {\r\n                    section.stackWords.set(sk, true);\r\n                });\r\n            }\r\n        });\r\n    });\r\n\r\n    // populate neighboringCrosses\r\n    sections.forEach(section => {\r\n        section.words.forEach((_, key) => {\r\n            let word = grid.words.get(key)!;\r\n            let crosses = getAllCrosses(grid, word);\r\n            crosses.forEach(cross => {\r\n                let crossKey = wordKey(cross);\r\n                if (!section.words.has(crossKey))\r\n                    section.neighboringCrosses.set(crossKey, true);\r\n            });\r\n        });\r\n    });\r\n\r\n    // calculate word order\r\n    sections.forEach(section => {\r\n        if (section.id === 0) {\r\n            let wordOrder = [] as string[];\r\n            let usedWords = new Map<string, boolean>();\r\n            let orderedSections = calculateSectionOrder(mapValues(sections));\r\n            orderedSections.forEach(id => {\r\n                if (id === 0 && sections.size > 1) return;\r\n                let secOrder = calculateWordOrder(grid, sections.get(id)!);\r\n                wordOrder.push(...secOrder.filter(wk => !usedWords.has(wk)));\r\n                secOrder.forEach(wk => {usedWords.set(wk, true);});\r\n            });\r\n            mapKeys(section.words).filter(wKey => !usedWords.has(wKey)).forEach(wk => {\r\n                wordOrder.push(wk);\r\n            });\r\n            section.wordOrder = wordOrder;\r\n            return;\r\n        }\r\n\r\n        section.wordOrder = calculateWordOrder(grid, section);\r\n    });\r\n\r\n    // calculate connections\r\n    sections.forEach(section => {\r\n        sections.forEach((sec, id) => {\r\n            if (id === section.id) return;\r\n            if (mapKeys(sec.words).find(wk => section.words.has(wk)))\r\n                section.connections.set(id, true);\r\n        });\r\n    });\r\n\r\n    return sections;\r\n}\r\n\r\nexport function calculateSectionOrder(sections: Section[]): number[] {\r\n    return sections.sort((a, b) => {\r\n        if (a.id === 0) return -1;\r\n        if (b.id === 0) return 1;\r\n        if (a.connections.size !== b.connections.size) return b.connections.size - a.connections.size;\r\n        return b.squares.size - a.squares.size;\r\n    }).map(sec => sec.id);\r\n}\r\n\r\nfunction calculateWordOrder(grid: GridState, section: Section): string[] {\r\n    function wordsSort(a: GridWord, b: GridWord): number {\r\n        if (wordLength(a) !== wordLength(b)) return wordLength(b) - wordLength(a);\r\n        return a.direction === WordDirection.Across ? a.start[0] - b.start[0] : a.start[1] - b.start[1];\r\n    }\r\n\r\n    function iterateWordGroup(group: GridWord[]) {\r\n        if (group.length === 0) return;\r\n        if (group.length === 1) {\r\n            wordOrder.push(wordKey(group[0]));\r\n            usedWords.set(wordKey(group[0]), true);\r\n            return;\r\n        }\r\n\r\n        let centerIndex = Math.floor((rowOrCol(group[group.length-1]) - rowOrCol(group[0])) / 2);\r\n        wordOrder.push(wordKey(group[centerIndex]));\r\n        usedWords.set(wordKey(group[centerIndex]), true);\r\n        iterateWordGroup(group.slice(0, centerIndex));\r\n        iterateWordGroup(group.slice(centerIndex + 1));\r\n    }\r\n\r\n    let wordOrder = [] as string[];\r\n    let usedWords = new Map<string, boolean>();\r\n\r\n    // stack words\r\n    if (section.stackWords.size > 0) {\r\n        let acrossSortedStackWords = mapKeys(section.stackWords).map(wKey => grid.words.get(wKey)!)\r\n            .filter(word => word.direction === WordDirection.Across).sort(wordsSort);\r\n        let downSortedStackWords = mapKeys(section.stackWords).map(wKey => grid.words.get(wKey)!)\r\n            .filter(word => word.direction === WordDirection.Down).sort(wordsSort);\r\n        let longestStack = downSortedStackWords.length === 0 ? acrossSortedStackWords :\r\n            acrossSortedStackWords.length === 0 ? downSortedStackWords :\r\n            wordLength(acrossSortedStackWords[0]) >= wordLength(downSortedStackWords[0]) ? acrossSortedStackWords :\r\n            downSortedStackWords;\r\n        let otherStack = longestStack === acrossSortedStackWords ? downSortedStackWords : acrossSortedStackWords;\r\n        [longestStack, otherStack].forEach(stack => {\r\n            for (let i = 0; i < stack.length; i++) {\r\n                let word = stack[i];\r\n                let length = wordLength(word);\r\n                let curGroup = [word];\r\n                let prevRowOrCol = rowOrCol(word);\r\n                for (let j = i+1; j < stack.length && wordLength(stack[j]) === length; j++) {\r\n                    let newWord = stack[j];\r\n                    let newRowOrCol = rowOrCol(newWord);\r\n                    if (newRowOrCol - prevRowOrCol === 1) {\r\n                        curGroup.push(newWord);\r\n                        prevRowOrCol = newRowOrCol;\r\n                        i++;\r\n                    }\r\n                    else break;\r\n                }\r\n    \r\n                iterateWordGroup(curGroup);\r\n            }\r\n        });\r\n    }\r\n\r\n    // restOfWords\r\n    let remainingWords = mapKeys(section.words).filter(wKey => !usedWords.has(wKey))\r\n        .map(wKey => grid.words.get(wKey)!).sort(wordsSort);\r\n    remainingWords.forEach(word => {\r\n        wordOrder.push(wordKey(word));\r\n    });\r\n\r\n    return wordOrder;\r\n}\r\n\r\nfunction rowOrCol(word: GridWord): number {\r\n    return word.direction === WordDirection.Across ? word.start[0] : word.start[1];\r\n}\r\n\r\nfunction isOpenSquare(grid: GridState, sq: GridSquare): boolean {\r\n    let neighbors = getNeighboringSquares(grid, sq);\r\n    return neighbors.length === 8 && !neighbors.find(n => isBlackSquare(n));\r\n}\r\n\r\nfunction getNeighboringSquares(grid: GridState, sq: GridSquare): GridSquare[] {\r\n    let ret = [] as GridSquare[];\r\n    let nClear = sq.row > 0;\r\n    let sClear = sq.row < grid.height-1;\r\n    let wClear = sq.col > 0;\r\n    let eClear = sq.col < grid.width-1;\r\n\r\n    if (nClear && wClear) ret.push(grid.squares[sq.row-1][sq.col-1]);\r\n    if (nClear) ret.push(grid.squares[sq.row-1][sq.col]);\r\n    if (nClear && eClear) ret.push(grid.squares[sq.row-1][sq.col+1]);\r\n    if (eClear) ret.push(grid.squares[sq.row][sq.col+1]);\r\n    if (sClear && eClear) ret.push(grid.squares[sq.row+1][sq.col+1]);\r\n    if (sClear) ret.push(grid.squares[sq.row+1][sq.col]);\r\n    if (sClear && wClear) ret.push(grid.squares[sq.row+1][sq.col-1]);\r\n    if (wClear) ret.push(grid.squares[sq.row][sq.col-1]);\r\n\r\n    return ret;\r\n}\r\n\r\nexport function newSectionCandidate(node: FillNode, section: Section): SectionCandidate {\r\n    let grid = node.endGrid;\r\n    return {\r\n        sectionId: section.id,\r\n        grid: grid,\r\n        score: calculateSectionCandidateScore(grid, section),\r\n        iffyEntry: node.iffyWordKey ? getEntryAtWordKey(grid, node.iffyWordKey) : undefined,\r\n        isFilteredOut: false,\r\n    } as SectionCandidate;\r\n}\r\n\r\nexport function calculateSectionCandidateScore(grid: GridState, section: Section): number {\r\n    let total = 0;\r\n    let foundIffy = false;\r\n    section.words.forEach((_, wordKey) => {\r\n        let word = grid.words.get(wordKey)!;\r\n        let squares = getSquaresForWord(grid, word);\r\n        let str = getLettersFromSquares(squares);\r\n        let score = getWordScore(str);\r\n        if (score < 3) foundIffy = true;\r\n        total += score;\r\n    });\r\n\r\n    if (!foundIffy) total *= 10;\r\n    return total / section.words.size;\r\n}\r\n\r\nconst natoAlphabet = {\r\n    \"A\": \"Alfa\",   \"B\": \"Bravo\",   \"C\": \"Charlie\",\r\n    \"D\": \"Delta\",  \"E\": \"Echo\",    \"F\": \"Foxtrot\",\r\n    \"G\": \"Golf\",   \"H\": \"Hotel\",   \"I\": \"India\",\r\n    \"J\": \"Juliett\",\"K\": \"Kilo\",    \"L\": \"Lima\",\r\n    \"M\": \"Mike\",   \"N\": \"November\",\"O\": \"Oscar\",\r\n    \"P\": \"Papa\",   \"Q\": \"Quebec\",  \"R\": \"Romeo\",\r\n    \"S\": \"Sierra\", \"T\": \"Tango\",   \"U\": \"Uniform\",\r\n    \"V\": \"Victor\", \"W\": \"Whiskey\", \"X\": \"X-ray\",\r\n    \"Y\": \"Yankee\", \"Z\": \"Zulu\"\r\n} as any;\r\n\r\nexport function getPhoneticName(n: number): string {\r\n    if (n === 0) return \"Full Grid\";\r\n    return n <= 26 ? natoAlphabet[String.fromCharCode(n+64)] : \"Section \" + n.toString();\r\n}\r\n\r\nexport function sectionCandidateKey(section: Section, grid: GridState): string {\r\n    let keys = mapKeys(section.squares).sort();\r\n    return keys.map(k => getSquareAtKey(grid, k).content!).join(\"\");\r\n}\r\n\r\nexport function makeNewSection(id: number): Section {\r\n    return {\r\n        id: id,\r\n        openSquareCount: 0,\r\n        squares: new Map<string, boolean>(),\r\n        words: new Map<string, boolean>(),\r\n        stackWords: new Map<string, boolean>(),\r\n        wordOrder: [],\r\n        neighboringCrosses: new Map<string, boolean>(),\r\n        candidates: new Map<string, SectionCandidate>(),\r\n        connections: new Map<number, boolean>(),\r\n        comboPermsQueue: [],\r\n        comboPermsUsed: new Map<string, boolean>(),\r\n    } as Section;\r\n}\r\n\r\nexport function getLongestStackWord(section: Section): GridWord {\r\n    function getLongest(wordKeys: string[]): GridWord {\r\n        return wordKeys.map(w => grid.words.get(w)!).sort((a, b) => wordLength(b) - wordLength(a))[0];\r\n    }\r\n\r\n    let grid = getGrid();\r\n    if (section.stackWords.size > 0)\r\n        return getLongest(mapKeys(section.stackWords))\r\n    else\r\n        return getLongest(mapKeys(section.words));\r\n}\r\n\r\nexport function getSelectedSections(): Section[] {\r\n    if (Globals.selectedSectionIds!.size === 0) return [Globals.sections!.get(0)!];\r\n    return mapKeys(Globals.selectedSectionIds!).sort().map(id => Globals.sections!.get(id)!);\r\n}\r\n\r\nexport function getSelectedSectionCandidates(): SectionCandidate[] {\r\n    let ret = [] as SectionCandidate[];\r\n    Globals.sections!.forEach((section, _) => {\r\n        Globals.selectedSectionCandidateKeys!.forEach((scKey, _) => {\r\n            if (section.candidates.has(scKey))\r\n                ret.push(section.candidates.get(scKey)!);\r\n        });\r\n    });\r\n    return ret;\r\n}\r\n\r\nexport function getSelectedSectionCandidatesWithWord(wordKey: string): SectionCandidate[] {\r\n    let ret = [] as SectionCandidate[];\r\n    getSelectedSectionCandidates().forEach(sc => {\r\n        let section = Globals.sections!.get(sc.sectionId)!;\r\n        if (section.words.has(wordKey))\r\n            ret.push(sc);\r\n    });\r\n    return ret;\r\n}\r\n\r\nexport function getSelectedSectionCandidatesWithSquare(squareKey: string): SectionCandidate[] {\r\n    let ret = [] as SectionCandidate[];\r\n    getSelectedSectionCandidates().forEach(sc => {\r\n        let section = Globals.sections!.get(sc.sectionId)!;\r\n        if (section.squares.has(squareKey))\r\n            ret.push(sc);\r\n    });\r\n    return ret;\r\n}\r\n\r\nexport function getSectionsWithSelectedCandidate(): Section[] {\r\n    return getSelectedSectionCandidates().map(sc => getSectionWithCandidate(sc));\r\n}\r\n\r\nexport function getSectionWithCandidate(sc: SectionCandidate): Section {\r\n    return Globals.sections!.get(sc.sectionId)!;\r\n}\r\n\r\nexport function getUnfilteredSectionCandidates(section: Section): SectionCandidate[] {\r\n    return mapValues(section.candidates).filter(sc => !sc.isFilteredOut);\r\n}\r\n\r\nexport function getSectionsWithWord(word: GridWord): Section[] {\r\n    return mapValues(Globals.sections!).filter(sec => sec.id > 0 && sec.words.has(wordKey(word)));\r\n}\r\n","import { ContentType } from \"../models/ContentType\";\r\nimport { FillNode } from \"../models/FillNode\";\r\nimport { GridSquare } from \"../models/GridSquare\";\r\nimport { GridState } from \"../models/GridState\";\r\nimport { getAllCrosses } from \"./fill\";\r\nimport { generateConstraintInfoForSquares, getLettersFromSquares } from \"./grid\";\r\nimport { sectionCandidateKey } from \"./section\";\r\nimport { deepClone, getSectionCandidatesFromKeys, getSquaresForWord, isWordFull, mapKeys } from \"./util\";\r\nimport Globals from './windowService';\r\n\r\nexport function processAndInsertChosenEntry(node: FillNode, contentType?: ContentType) {\r\n    if (contentType === undefined) contentType = ContentType.Autofill;\r\n    if (!node.chosenEntry) return false;\r\n\r\n    let grid = deepClone(node.startGrid) as GridState;\r\n    let word = node.fillWord!;\r\n    let wordSquares = getSquaresForWord(grid, word);\r\n    let crosses = getAllCrosses(grid, word);\r\n\r\n    wordSquares.forEach((sq, i) => {\r\n        sq.content = node.chosenEntry!.word[i];\r\n        if ([ContentType.Autofill, ContentType.ChosenSection, ContentType.HoverChosenWord].includes(sq.contentType))\r\n            sq.contentType = contentType!;\r\n    });\r\n    grid.usedWords.set(getLettersFromSquares(wordSquares), true);\r\n    node.iffyWordKey = node.chosenEntry!.iffyWordKey;\r\n\r\n    if (contentType === ContentType.ChosenWord) {\r\n        removeNonmatchingSectionCandidates(grid, wordSquares, node.chosenEntry!.word);\r\n    }  \r\n\r\n    crosses.forEach(cross => {\r\n        let newSquares = getSquaresForWord(grid, cross);\r\n        generateConstraintInfoForSquares(newSquares);\r\n\r\n        if (isWordFull(newSquares)) {\r\n            grid.usedWords.set(getLettersFromSquares(newSquares), true);\r\n        }\r\n    });\r\n    \r\n    node.endGrid = grid;\r\n}\r\n\r\nfunction removeNonmatchingSectionCandidates(grid: GridState, newSquares: GridSquare[], chosenEntry: string) {\r\n    let sectionCandidates = getSectionCandidatesFromKeys(mapKeys(grid.userFilledSectionCandidates));\r\n    sectionCandidates.forEach(sc => {\r\n        let section = Globals.sections!.get(sc.sectionId)!;\r\n        newSquares.forEach((sq, i) => {\r\n            if (sc.grid.squares[sq.row][sq.col].content !== chosenEntry[i])\r\n                grid.userFilledSectionCandidates.delete(sectionCandidateKey(section, grid));\r\n        });\r\n    });\r\n}\r\n","// https://itnext.io/priority-queue-in-typescript-6ef23116901\r\n\r\n  interface Node<T> {\r\n    key: number\r\n    value: T\r\n  }\r\n\r\n  export interface PriorityQueue<T> {\r\n      isEmpty: () => boolean,\r\n      peek: () => T | null,\r\n      size: () => number,\r\n      insert: (item: T, prio: number) => void,\r\n      pop: () => T | null,\r\n  }\r\n  \r\n  export const priorityQueue = <T>(): PriorityQueue<T> => {\r\n    let heap: Node<T>[] = []\r\n\r\n    const parent = (index: number) => Math.floor((index - 1) / 2)\r\n    const left = (index: number) => 2 * index + 1\r\n    const right = (index: number) =>  2 * index + 2\r\n    const hasLeft = (index: number) => left(index) < heap.length\r\n    const hasRight = (index: number) => right(index) < heap.length\r\n\r\n    const swap = (a: number, b: number) => {\r\n        let temp = heap[a];\r\n        heap[a] = heap[b];\r\n        heap[b] = temp;\r\n    }\r\n  \r\n    return {\r\n      \r\n      isEmpty: () => heap.length === 0,\r\n  \r\n      peek: () => heap.length === 0 ? null : heap[0].value,\r\n      \r\n      size: () => heap.length,\r\n\r\n      insert: (item, prio) => {\r\n        heap.push({key: prio, value: item})\r\n  \r\n        let i = heap.length -1\r\n        while(i > 0) {\r\n          const p = parent(i)\r\n          if(heap[p].key > heap[i].key) break\r\n          const tmp = heap[i]\r\n          heap[i] = heap[p]\r\n          heap[p] = tmp\r\n          i = p\r\n        }\r\n      },\r\n\r\n      pop: () => {\r\n        if(heap.length === 0) return null\r\n        \r\n        swap(0, heap.length - 1)\r\n        const item = heap.pop()\r\n  \r\n        let current = 0\r\n        while(hasLeft(current)) {\r\n          let largerChild = left(current)\r\n          if(hasRight(current) && heap[right(current)].key > heap[left(current)].key) \r\n            largerChild = right(current)\r\n  \r\n          if(heap[largerChild].key < heap[current].key) break\r\n  \r\n          swap(current, largerChild)\r\n          current = largerChild\r\n        }\r\n  \r\n        return item!.value\r\n      }\r\n    }\r\n  }\r\n  ","export enum FillStatus {\r\n    NoWordList,\r\n    Ready,\r\n    Running,\r\n    Complete,\r\n}\r\n","import { FillNode } from \"../models/FillNode\";\r\nimport { GridSquare } from \"../models/GridSquare\";\r\nimport { GridState } from \"../models/GridState\";\r\nimport { GridWord } from \"../models/GridWord\";\r\nimport { SquareType } from \"../models/SquareType\";\r\nimport { WordDirection } from \"../models/WordDirection\";\r\nimport Globals from './windowService';\r\nimport { getSquaresForWord, isBlackSquare, newWord, forAllGridSquares, isWordFull, isWordEmpty, getGrid, \r\n    isUserFilled, deepClone, wordKey, getWordAtSquare, getSquareAtKey, otherDir, squareKey, getSection, mapKeys, \r\n    fullAlphabet, letterListToLetterMatrix, letterMatrixToLetterList } from \"./util\";\r\nimport { SymmetryType } from \"../models/SymmetryType\";\r\nimport { makeNewNode } from \"./fill\";\r\nimport { ContentType } from \"../models/ContentType\";\r\nimport { processAndInsertChosenEntry } from \"./insertEntry\";\r\nimport { queryIndexedWordList } from \"./wordList\";\r\nimport { populateAndScoreEntryCandidates, populateNoHeuristicEntryCandidates } from \"./entryCandidates\";\r\nimport { getSectionsWithSelectedCandidate, getSectionWithCandidate, \r\n    getSelectedSectionCandidatesWithSquare } from \"./section\";\r\nimport { FillStatus } from \"../models/FillStatus\";\r\nimport { SectionCandidate } from \"../models/SectionCandidate\";\r\n\r\nexport function populateWords(grid: GridState) {\r\n    function processSquare(grid: GridState, row: number, col: number, dir: WordDirection) {\r\n        let sq = grid.squares[row][col];\r\n\r\n        if (isBlackSquare(sq)) return;\r\n        if (!currentWord.number && !sq.number) return; // unchecked square\r\n\r\n        if (!currentWord.number) {\r\n            currentWord.number = sq.number;\r\n            currentWord.direction = dir;\r\n            currentWord.start = [row, col]; \r\n        }\r\n\r\n        currentWord.end = [row, col];\r\n\r\n        let nextSq = dir === WordDirection.Across ? [row, col+1] : [row+1, col];\r\n        if (nextSq[0] === grid.height || nextSq[1] === grid.width || isBlackSquare(grid.squares[nextSq[0]][nextSq[1]])) {\r\n            if ((dir === WordDirection.Across && currentWord.end[1] - currentWord.start[1] > 0) ||\r\n                (dir === WordDirection.Down && currentWord.end[0] - currentWord.start[0] > 0))\r\n                grid.words.set(wordKey(currentWord), currentWord);\r\n            currentWord = newWord();\r\n        }\r\n    }\r\n\r\n    grid.words = new Map<string, GridWord>();\r\n\r\n    numberizeGrid(grid);\r\n\r\n    let currentWord: GridWord = newWord();\r\n    for (let row = 0; row < grid.height; row++) {\r\n        for (let col = 0; col < grid.width; col++) {\r\n            processSquare(grid, row, col, WordDirection.Across);\r\n        }\r\n    }\r\n\r\n    for (let col = 0; col < grid.width; col++) {\r\n        for (let row = 0; row < grid.height; row++) {\r\n            processSquare(grid, row, col, WordDirection.Down);\r\n        }\r\n    }\r\n}\r\n\r\nexport function updateGridConstraintInfo(grid: GridState) {\r\n    grid.usedWords = new Map<string, boolean>();\r\n    forAllGridSquares(grid, sq => { sq.viableLetters = undefined; });\r\n\r\n    if (!Globals.wordList) return;\r\n\r\n    let wordKeys = mapKeys(grid.words);\r\n    let sortedWordKeys = wordKeys.filter(k => k.includes(\"A\")).concat(wordKeys.filter(k => k.includes(\"D\")));\r\n    sortedWordKeys.forEach(wordKey => {\r\n        let word = grid.words.get(wordKey)!;\r\n        let newSquares = deepClone(getSquaresForWord(grid, word)) as GridSquare[];\r\n        let letters = getLettersFromSquares(newSquares);\r\n        if (!letters.includes(\"-\")) grid.usedWords.set(letters, true);\r\n        generateConstraintInfoForSquares(newSquares);\r\n        if (newSquares !== undefined && newSquares.length > 0) {\r\n            newSquares.forEach(ns => {\r\n                grid.squares[ns.row][ns.col] = ns;\r\n            });\r\n        }\r\n    });\r\n}\r\n\r\nfunction numberizeGrid(grid: GridState) {\r\n    var currentNumber = 1;\r\n\r\n    for(var row = 0; row < grid.height; row++) {\r\n        for (var col = 0; col < grid.width; col++) {\r\n            var sq = grid.squares[row][col];  \r\n            sq.number = undefined;\r\n\r\n            if (!isBlackSquare(sq)) {\r\n                let isAboveBlocked = (row === 0 || isBlackSquare(grid.squares![row-1][col]));\r\n                let isBelowBlocked = (row === grid.height-1 || isBlackSquare(grid.squares[row+1][col]));\r\n                let isLeftBlocked = (col === 0 || isBlackSquare(grid.squares[row][col-1]));\r\n                let isRightBlocked = (col === grid.width-1 || isBlackSquare(grid.squares[row][col+1]));\r\n\r\n                let isUnchecked = (isAboveBlocked && isBelowBlocked) || (isLeftBlocked && isRightBlocked);\r\n                let isUncheckedStart = (isAboveBlocked && isBelowBlocked && isLeftBlocked && !isRightBlocked) || \r\n                                       (isLeftBlocked && isRightBlocked && isAboveBlocked && !isBelowBlocked);\r\n                let isCheckedStart = isAboveBlocked || isLeftBlocked;\r\n\r\n                if ((isUnchecked && isUncheckedStart) || (!isUnchecked && isCheckedStart)) {\r\n                    sq.number = currentNumber++;\r\n                }\r\n            } \r\n        }\r\n    }\r\n}\r\n\r\nexport function generateConstraintInfoForSquares(squares: GridSquare[]) {\r\n    squares.forEach(sq => {\r\n        if (sq.content) {\r\n            sq.viableLetters = [sq.content];\r\n        }\r\n        else if (!sq.viableLetters) {\r\n            sq.viableLetters = deepClone(fullAlphabet);\r\n        }\r\n    });\r\n    if (isWordEmpty(squares) || isWordFull(squares)) return;\r\n\r\n    let pattern = getLettersFromSquares(squares);\r\n    let entryOptions = queryIndexedWordList(pattern);\r\n    if (entryOptions.length > 500) return;\r\n\r\n    for (let i = 0; i < squares.length; i++) {\r\n        let sq = squares[i];\r\n        if (sq.content) continue;\r\n        let curViableMatrix = sq.viableLetters ? letterListToLetterMatrix(sq.viableLetters) : Array<boolean>(26).fill(true);\r\n        let newViableMatrix = Array<boolean>(26).fill(false);\r\n\r\n        let letters = entryOptions.map(entry => entry[i]);\r\n        letters.forEach(ltr => {\r\n            if (sq.viableLetters && curViableMatrix[ltr.charCodeAt(0) - 65]) return;\r\n            setLettersArrayVal(newViableMatrix, ltr, true);\r\n        });\r\n        sq.viableLetters = letterMatrixToLetterList(newViableMatrix);\r\n    }\r\n}\r\n\r\nexport function getLettersArrayVal(arr: boolean[], ltr: string) {\r\n    return arr[ltr.charCodeAt(0) - 65];\r\n}\r\n\r\nexport function setLettersArrayVal(arr: boolean[], ltr: string, newVal: boolean) {\r\n    arr[ltr.charCodeAt(0) - 65] = newVal;\r\n}\r\n\r\nexport function getConstraintSquareSum(squares: GridSquare[]): number {\r\n    let total = 0;\r\n    squares.forEach(sq => {\r\n        total += sq.viableLetters ? sq.viableLetters.length : 0;\r\n    });\r\n    return total;\r\n}\r\n\r\nexport function getLettersFromSquares(squares: GridSquare[]): string {\r\n    return squares.map(sq => sq.content ? sq.content! : \"-\").join(\"\");\r\n}\r\n\r\nexport function gridToString(grid: GridState): string {\r\n    let chs: string[] = [];\r\n    forAllGridSquares(grid, sq => {\r\n        chs.push(isBlackSquare(sq) ? \".\" : sq.content ? sq.content : \"-\");\r\n    });\r\n    return chs.join(\"\");\r\n}\r\n\r\nexport function createNewGrid(width: number, height: number): GridState {\r\n    let squares: GridSquare[][] = [];\r\n\r\n    for (let row = 0; row < height; row++) {\r\n        squares.push([]);\r\n        for (let col = 0; col < width; col++) {\r\n            squares[row][col] = {\r\n                row: row,\r\n                col: col,\r\n                type: SquareType.White,\r\n                isCircled: false,\r\n                contentType: ContentType.Autofill,\r\n            } as GridSquare;\r\n        }\r\n    }\r\n\r\n    let grid: GridState = {\r\n        height: height,\r\n        width: width,\r\n        squares: squares,\r\n        words: new Map<string, GridWord>(),\r\n        usedWords: new Map<string, boolean>(),\r\n        userFilledSectionCandidates: new Map<string, boolean>(),\r\n    };\r\n\r\n    populateWords(grid);\r\n\r\n    return grid;\r\n}\r\n\r\nexport function getUncheckedSquareDir(grid: GridState, row: number, col: number): WordDirection | undefined {\r\n    if (grid.squares[row][col].type === SquareType.Black) return undefined;\r\n    if ((col === 0 || grid.squares[row][col-1].type === SquareType.Black) &&\r\n        (col === grid.width-1 || grid.squares[row][col+1].type === SquareType.Black))\r\n        return WordDirection.Down;\r\n    if ((row === 0 || grid.squares[row-1][col].type === SquareType.Black) &&\r\n        (row === grid.height-1 || grid.squares[row+1][col].type === SquareType.Black))\r\n        return WordDirection.Across;\r\n\r\n    return undefined;\r\n}\r\n\r\nexport function getSymmetrySquares(initSquare: [number, number]): [number, number][] {\r\n    let grid = getGrid();\r\n    let w = grid.width - 1;\r\n    let h = grid.height - 1;\r\n    let r = initSquare[0];\r\n    let c = initSquare[1];\r\n    let ret = [initSquare];\r\n\r\n    switch (Globals.gridSymmetry!) {\r\n        case SymmetryType.Rotate180:\r\n            ret.push([h - r, w - c]);\r\n            break;\r\n        case SymmetryType.Rotate90:\r\n            ret.push([c, h - r]);\r\n            ret.push([h - r, w - c]);\r\n            ret.push([w - c, r]);\r\n            break;\r\n        case SymmetryType.MirrorHorizontal:\r\n            ret.push([r, w - c]);\r\n            break;\r\n        case SymmetryType.MirrorVertical:\r\n            ret.push([h - r, c]);\r\n            break;\r\n        case SymmetryType.MirrorNWSE:\r\n            ret.push([w - c, h - r]);\r\n            break;\r\n        case SymmetryType.MirrorNESW:\r\n            ret.push([c, r]);\r\n            break;\r\n    }\r\n\r\n    return ret;\r\n}\r\n\r\nexport function insertEntryIntoGrid(node: FillNode, wordKey: string, entry: string, iffyWordKey?: string, contentType?: ContentType) {\r\n    let grid = node.startGrid;\r\n    node.fillWord = grid.words.get(wordKey)!;\r\n    node.chosenEntry = node.entryCandidates.find(ec => ec.word === entry && ec.iffyWordKey === iffyWordKey);\r\n    processAndInsertChosenEntry(node, contentType);\r\n}\r\n\r\nexport function eraseGridSquare(grid: GridState, sq: GridSquare, dir: WordDirection) {\r\n    if (sq.content === undefined) return;\r\n\r\n    let word = getWordAtSquare(grid, sq.row, sq.col, dir)!;\r\n    let squares = word ? getSquaresForWord(grid, word) : [sq];\r\n\r\n    let otherDirWord = getWordAtSquare(grid, sq.row, sq.col, dir)!;\r\n    let otherDirSquares = otherDirWord ? getSquaresForWord(grid, otherDirWord) : [sq];\r\n    if (squares.length > 1 && isWordFull(squares)) grid.usedWords.delete(getLettersFromSquares(squares));\r\n    if (otherDirSquares.length > 1 && isWordFull(otherDirSquares)) grid.usedWords.delete(getLettersFromSquares(otherDirSquares));\r\n\r\n    if (squares.find(sq => sq.contentType === ContentType.Autofill)) {\r\n        ; // autofill is ephemeral, no need to explicitly delete\r\n    }\r\n    else if (squares.find(sq => [ContentType.User, ContentType.ChosenWord].includes(sq.contentType))) {\r\n        let isInSection = getSectionsWithSelectedCandidate().find(sec => sec.squares.has(squareKey(sq)));\r\n\r\n        squares.forEach(wsq => {\r\n            if (wsq.contentType === ContentType.User) return;\r\n            let cross = getWordAtSquare(grid, wsq.row, wsq.col, otherDir(dir))!;\r\n            if (wsq.contentType === ContentType.ChosenWord && !cross) {\r\n                wsq.contentType = ContentType.Autofill;\r\n                return;\r\n            }\r\n            let crossSquares = getSquaresForWord(grid, cross);\r\n            if (crossSquares.find(csq => [ContentType.Autofill, ContentType.ChosenSection].includes(csq.contentType))) {\r\n                if (isInSection)\r\n                    wsq.contentType = ContentType.ChosenSection;\r\n                else\r\n                    wsq.contentType = ContentType.Autofill;\r\n            }\r\n        });\r\n    }\r\n        \r\n    sq.content = undefined;\r\n    sq.contentType = ContentType.Autofill;\r\n    clearFill(grid);\r\n}\r\n\r\nexport function eraseSectionCandidateFromGrid(grid: GridState, sc: SectionCandidate) {\r\n    let section = getSectionWithCandidate(sc);\r\n    Globals.selectedSectionCandidateKeys?.delete(section.id);\r\n    section.squares.forEach((_, sqKey) => {\r\n        let sq = getSquareAtKey(grid, sqKey);\r\n        let scs = getSelectedSectionCandidatesWithSquare(sqKey);\r\n        if (scs.length > 1) return;\r\n        if (sq.contentType === ContentType.ChosenSection)\r\n            sq.contentType = ContentType.Autofill;\r\n    });\r\n}\r\n\r\nexport function clearFill(grid: GridState) {\r\n    Globals.selectedWordNode = undefined;\r\n    let section = getSection();\r\n    section.fillQueue = undefined;\r\n    section.comboPermsQueue = [];\r\n    section.comboPermsUsed = new Map<string, boolean>();\r\n    Globals.fillStatus = Globals.wordList !== undefined ? FillStatus.Ready : FillStatus.NoWordList;\r\n\r\n    forAllGridSquares(grid, sq => {\r\n        if (!isUserFilled(sq)) {\r\n            sq.content = undefined;\r\n        }\r\n    });\r\n\r\n    updateGridConstraintInfo(grid);\r\n}\r\n\r\nexport function updateManualEntryCandidates(grid: GridState) {\r\n    if (!Globals.selectedWordKey || !Globals.wordList) {\r\n        Globals.selectedWordNode = undefined;\r\n        return;\r\n    }\r\n\r\n    let node = makeNewNode(grid, 0, false, undefined);\r\n    node.fillWord = grid.words.get(Globals.selectedWordKey!);\r\n    if (Globals.useManualHeuristics!) {\r\n        populateAndScoreEntryCandidates(node, true);\r\n    }\r\n    else {\r\n        populateNoHeuristicEntryCandidates(node);\r\n    }\r\n    Globals.selectedWordNode = node;\r\n}\r\n","import { CluesViewProp } from \"./CluesViewProp\";\r\nimport React, { createRef, useEffect, useRef, useState } from 'react';\r\nimport \"./CluesView.scss\";\r\nimport { wordKey, deepClone, getSquaresForWord, getGrid, mapValues } from \"../../lib/util\";\r\nimport Globals from '../../lib/windowService';\r\nimport { getLettersFromSquares } from \"../../lib/grid\";\r\nimport { WordDirection } from \"../../models/WordDirection\";\r\n\r\nfunction CluesView(props: any) {\r\n    const [clueProps, setClueProps] = useState(initClueProps());\r\n    const [selectedKey, setSelectedKey] = useState(\"\");\r\n    const textareasRef = useRef([] as any[]);\r\n\r\n    useEffect(() => {\r\n        setClueProps(initClueProps());\r\n        setSelectedKey(Globals.selectedWordKey!);\r\n    }, [props.updateSemaphore])\r\n\r\n    function initClueProps(): CluesViewProp[] {\r\n        let props = [] as CluesViewProp[];\r\n        if (!Globals.puzzle) return props;\r\n\r\n        let grid = getGrid();\r\n        let words = grid.words;\r\n        let clues = Globals.puzzle.clues;\r\n        mapValues(words).sort((a, b) => (a.number || 0) - (b.number || 0)).forEach(word => {\r\n            let key = wordKey(word);\r\n            let squares = getSquaresForWord(grid, word);\r\n            let prop = {\r\n                number: word.number!,\r\n                key: key,\r\n                direction: word.direction,\r\n                clue: clues.get(key)! || \"\",\r\n                entry: getLettersFromSquares(squares),\r\n                isOpenForEditing: false,\r\n            } as CluesViewProp;\r\n            props.push(prop);\r\n        });\r\n        return props;\r\n    }\r\n\r\n    function handleClueClick(event: any) {\r\n        let target = event.target;\r\n        while (![\"clue\"].includes(target.classList[0])) {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n        let targetKey = target.attributes[\"data-key\"].value;\r\n        let refIndex = +target.attributes[\"data-ref-index\"].value;\r\n        let textareaEl = textareasRef.current[refIndex].current;\r\n        \r\n        let newClueProps = deepClone(clueProps) as CluesViewProp[];\r\n        let propToToggle = newClueProps.find(p => p.key === targetKey)!;\r\n        propToToggle.isOpenForEditing = !propToToggle.isOpenForEditing;\r\n        setClueProps(newClueProps);\r\n\r\n        if (propToToggle.isOpenForEditing) {\r\n            textareaEl.value = propToToggle.clue;\r\n            textareaEl.style.display = \"inherit\"; // have to do this before we can autofocus\r\n            textareaEl.focus();\r\n        }\r\n    }\r\n\r\n    function handleKeyDown(event: any) {\r\n        let target = event.target;\r\n        let targetKey: string = target.attributes[\"data-key\"].value;\r\n        let keyPressed: string = event.key.toUpperCase();\r\n\r\n        if (keyPressed === \"ENTER\") {\r\n            applyClueChange(targetKey, target.value);\r\n        }\r\n    }\r\n\r\n    function handleFocus(event: any) {\r\n        event.target.select();\r\n    }\r\n\r\n    function applyClueChange(targetKey: string, newValue: string) {\r\n        let newClueProps = deepClone(clueProps) as CluesViewProp[];\r\n        let targetProp = newClueProps.find(p => p.key === targetKey)!;\r\n        targetProp.clue = newValue === \"(blank clue)\" ? \"\" : newValue;\r\n        targetProp.isOpenForEditing = false;\r\n        Globals.puzzle!.clues.set(targetKey, newValue);\r\n        setClueProps(newClueProps);\r\n    }\r\n\r\n    function renderCluesContainer(isAcross: boolean, clueList: CluesViewProp[], refIndex: number) {\r\n        return (\r\n            <div className=\"clues-container\">\r\n                <div className=\"clues-header\">{isAcross ? \"ACROSS\" : \"DOWN\"}</div>\r\n                <div className=\"clues-clues\">\r\n                    {clueList.map(clue => {\r\n                        textareasRef.current.push(createRef());\r\n                        let ret = (\r\n                            <div key={clue.key}>\r\n                                <div className={\"clue\" + (clue.key === selectedKey ? \" clue-selected\" : \"\")}\r\n                                    data-key={clue.key} onClick={handleClueClick} data-ref-index={refIndex}>\r\n                                    <div className=\"clue-number\">{clue.number}</div>\r\n                                    <div className=\"clue-entry\">{clue.entry}</div>\r\n                                    {clue.entry.length > 15 && <br />}\r\n                                    {clue.clue.length > 0 ? clue.clue : \"(blank clue)\"}\r\n                                </div>\r\n                                <textarea className=\"clue-editor\" defaultValue={clue.clue} data-key={clue.key} \r\n                                    style={{display: clue.isOpenForEditing ? \"inherit\" : \"none\"}}\r\n                                    onKeyDown={handleKeyDown} onFocus={handleFocus}\r\n                                    ref={textareasRef.current[refIndex]}>\r\n                                </textarea>\r\n                            </div>\r\n                        );\r\n                        refIndex++;\r\n                        return ret;\r\n                    })}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    textareasRef.current = [] as any[];\r\n    let acrossClues = clueProps.filter(p => p.direction === WordDirection.Across);\r\n    let downClues = clueProps.filter(p => p.direction === WordDirection.Down);\r\n\r\n    return (\r\n        <div className=\"clues-view\">\r\n            {renderCluesContainer(true, acrossClues, 0)}\r\n            {renderCluesContainer(false, downClues, acrossClues.length)}\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default CluesView;\r\n","import React, { useContext, useState } from 'react';\r\nimport { SymmetryType } from '../../models/SymmetryType';\r\nimport \"./FillView.scss\";\r\nimport Globals from '../../lib/windowService';\r\nimport { FillStatus } from '../../models/FillStatus';\r\nimport { getEntryAtWordKey, getGrid, getSection, getSquaresForWord, mapKeys, mapValues } from '../../lib/util';\r\nimport { calculateSectionOrder, getLongestStackWord, getPhoneticName, insertSectionCandidateIntoGrid, \r\n    makeNewSection, sectionCandidateKey, updateSectionFilters } from '../../lib/section';\r\nimport { clearFill, eraseSectionCandidateFromGrid, getLettersFromSquares, insertEntryIntoGrid, updateGridConstraintInfo, updateManualEntryCandidates } from '../../lib/grid';\r\nimport { fillSectionWord, makeNewNode } from '../../lib/fill';\r\nimport { FillNode } from '../../models/FillNode';\r\nimport { AppContext } from '../../AppContext';\r\nimport { ContentType } from '../../models/ContentType';\r\nimport { Section } from '../../models/Section';\r\nimport { processWordListData } from '../../lib/wordList';\r\nimport { useInterval } from '../../lib/useInterval';\r\nimport { SectionCandidate } from '../../models/SectionCandidate';\r\nimport { QualityClass } from '../../models/QualityClass';\r\n\r\nfunction FillView() {\r\n    const appContext = useContext(AppContext);\r\n    const [showSectionCandidates, setShowSectionCandidates] = useState(true);\r\n    const [isWordListLoading, setIsWordListLoading] = useState(false);\r\n    const [isFillRunning, setIsFillRunning] = useState(false);\r\n\r\n    function triggerUpdate() {\r\n        appContext.triggerUpdate();\r\n    }\r\n\r\n    function setFillStatus(newStatus: FillStatus) {\r\n        Globals.fillStatus = newStatus;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleToggleFill() {\r\n        if (isFillRunning) {\r\n            clearFill(getGrid());\r\n            setFillStatus(FillStatus.Ready);\r\n            setIsFillRunning(false);\r\n            triggerUpdate();\r\n        }\r\n        else {\r\n            setFillStatus(FillStatus.Running);\r\n            setIsFillRunning(true);\r\n        }\r\n    }\r\n    \r\n    function doFillWord() {\r\n        if (Globals.fillStatus === FillStatus.Complete) return;\r\n        if (!fillSectionWord()) {\r\n            clearFill(getGrid());\r\n            setFillStatus(FillStatus.Complete);\r\n            setIsFillRunning(false);\r\n        }\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleFillWordClick(event: any) {\r\n        if (!Globals.wordList) return;\r\n\r\n        if (!fillSectionWord()) {\r\n            clearFill(getGrid());\r\n            setFillStatus(FillStatus.Complete);\r\n        }\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleSymmetryChange(event: any) {\r\n        Globals.gridSymmetry = +SymmetryType[event.target[event.target.selectedIndex].value] as SymmetryType;\r\n    }\r\n\r\n    function handleIffyLengthChange(event: any) {\r\n        Globals.maxIffyLength = +event.target[event.target.selectedIndex].value;\r\n        Globals.manualIffyKey = undefined;\r\n    }\r\n\r\n    function getSymmetryTypeString(type: string): string {\r\n        switch(type) {\r\n            case \"None\": return \"None\";\r\n            case \"Rotate180\": return \"180° Rotational\";\r\n            case \"Rotate90\": return \"90° Rotational\";\r\n            case \"MirrorHorizontal\": return \"Mirror Horizontally\";\r\n            case \"MirrorVertical\": return \"Mirror Vertically\";\r\n            case \"MirrorNWSE\": return \"Mirror NW to SE\";\r\n            case \"MirrorNESW\": return \"Mirror NE to SW\";\r\n        }\r\n        return \"\";\r\n    }\r\n\r\n    function getSymmetryTypesForRectGrids(): string[] {\r\n        return [\"None\", \"Rotate180\", \"MirrorHorizontal\", \"MirrorVertical\"];\r\n    }\r\n\r\n    function getFillStatusString(status: FillStatus): string {\r\n        switch(status) {\r\n            case FillStatus.NoWordList: return \"No Word List Loaded\";\r\n            case FillStatus.Ready: return \"Ready to Fill\";\r\n            case FillStatus.Running: return \"Fill Running...\";\r\n            case FillStatus.Complete: return \"Fill Complete\";\r\n            default: return \"\";\r\n        }\r\n    }\r\n\r\n    function getManualEntryNode(entry: string, iffyWordKey?: string, isHover?: boolean): FillNode {\r\n        let node = Globals.selectedWordNode!;\r\n        let wordKey = Globals.selectedWordKey!;\r\n        insertEntryIntoGrid(node, wordKey, entry, iffyWordKey, isHover ? ContentType.HoverChosenWord : ContentType.ChosenWord);\r\n        return node;\r\n    }\r\n\r\n    function getManualSectionNode(sectionCandidateKey: string, isHover: boolean): FillNode {\r\n        let grid = getGrid();\r\n\r\n        let node = makeNewNode(grid, 0, false, undefined);\r\n        let section = getSection();\r\n        let candidate = section.candidates.get(sectionCandidateKey)!;\r\n        insertSectionCandidateIntoGrid(node.endGrid, candidate, \r\n            isHover ? ContentType.HoverChosenSection : ContentType.ChosenSection);\r\n        return node;\r\n    }\r\n\r\n    function handleEntryCandidateClick(event: any) {\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        if (!Globals.selectedWordKey) return;\r\n\r\n        let entry = target.attributes[\"data-word\"].value as string;\r\n        let iffyWordKey = target.attributes[\"data-iffykey\"].value as string | undefined;\r\n        if (iffyWordKey === \"na\") iffyWordKey = undefined;\r\n        let node = getManualEntryNode(entry, iffyWordKey, false);\r\n\r\n        Globals.manualIffyKey = iffyWordKey;\r\n\r\n        updateManualEntryCandidates(node.endGrid);\r\n\r\n        Globals.activeGrid = node.endGrid;\r\n        updateSectionFilters();\r\n        Globals.hoverGrid = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleEntryCandidateHover(event: any) {\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        if (!Globals.selectedWordKey) return;\r\n\r\n        let entry = target.attributes[\"data-word\"].value as string;\r\n        let iffyWordKey = target.attributes[\"data-iffykey\"].value as string | undefined;\r\n        if (iffyWordKey === \"na\") iffyWordKey = undefined;\r\n        let node = getManualEntryNode(entry, iffyWordKey, true);\r\n\r\n        Globals.hoverGrid = node.endGrid;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleEntryCandidateBlur() {\r\n        Globals.hoverGrid = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleSectionClick(event: any) {\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n            if (target.classList[0] === \"section-checkbox\") return;\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        let sectionId = +target.attributes[\"data-id\"].value;\r\n        clearFill(getGrid());\r\n\r\n        if (sectionId === Globals.activeSectionId!) {\r\n            Globals.activeSectionId = 0;\r\n            Globals.selectedSectionIds = new Map<number, boolean>();\r\n            Globals.selectedSectionIds!.set(sectionId, true);\r\n        }\r\n        else {\r\n            Globals.activeSectionId = sectionId;\r\n            Globals.selectedSectionIds = new Map<number, boolean>();\r\n            Globals.selectedSectionIds!.set(sectionId, true);\r\n        }\r\n\r\n        Globals.hoverGrid = undefined;\r\n        Globals.hoverSectionId = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleSectionCheckClick(event: any) {\r\n        return;\r\n        // let target = event.target;\r\n        // while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n        //     target = target.parentElement;\r\n        //     if (!target) return;\r\n        // }\r\n\r\n        // let sectionId = +target.attributes[\"data-id\"].value;\r\n        // if (Globals.selectedSectionIds!.get(sectionId))\r\n        //     Globals.selectedSectionIds!.delete(sectionId);\r\n        // else\r\n        //     Globals.selectedSectionIds!.set(sectionId, true);\r\n    }\r\n\r\n    function handleSectionHover(event: any) {\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        let sectionId = +target.attributes[\"data-id\"].value;\r\n        Globals.hoverSectionId = sectionId;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleSectionBlur() {\r\n        Globals.hoverSectionId = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleSectionCandidateClick(event: any) {\r\n        function eraseSc() {\r\n            section.selectedCandidate = undefined;\r\n            section.comboPermsQueue = [];\r\n            section.comboPermsUsed = new Map<string, boolean>();\r\n            let sc = section.candidates.get(candidateKey)!;\r\n            eraseSectionCandidateFromGrid(grid, sc);\r\n            clearFill(grid);\r\n        }\r\n\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        let section = getSection();\r\n        let grid = getGrid();\r\n        let candidateKey = target.attributes[\"data-candidate-key\"].value as string;\r\n\r\n        if (section.selectedCandidate === candidateKey) {\r\n            eraseSc();\r\n        }\r\n        else {\r\n            if (section.selectedCandidate) eraseSc();\r\n\r\n            let node = getManualSectionNode(candidateKey, false);\r\n            Globals.selectedSectionCandidateKeys!.set(section.id, candidateKey);\r\n            section.selectedCandidate = candidateKey;\r\n\r\n            updateManualEntryCandidates(node.endGrid);\r\n\r\n            Globals.activeGrid = node.endGrid;\r\n        }\r\n        \r\n        updateSectionFilters();\r\n        Globals.hoverGrid = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleSectionCandidateHover(event: any) {\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        let candidateKey = target.attributes[\"data-candidate-key\"].value as string;\r\n        let node = getManualSectionNode(candidateKey, true);\r\n\r\n        Globals.hoverGrid = node.endGrid;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleShowSectionCandidatesToggle() {\r\n        setShowSectionCandidates(!showSectionCandidates);\r\n    }\r\n\r\n    function clearSectionCandidates() {\r\n        if (!window.confirm(\"Are you sure you want to clear the fills?\")) return;\r\n\r\n        let section = getSection();\r\n        section.candidates = new Map<string, SectionCandidate>();\r\n        section.selectedCandidate = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleUseHeuristicsToggle() {\r\n        let newValue = Globals.useManualHeuristics !== undefined ? !Globals.useManualHeuristics! : false;\r\n        Globals.useManualHeuristics = newValue;\r\n\r\n        triggerUpdate();\r\n        let node = Globals.selectedWordNode;\r\n        if (!node) return;\r\n\r\n        updateManualEntryCandidates(grid);\r\n    }\r\n\r\n    function handleSectionCandidateBlur() {\r\n        Globals.hoverGrid = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function loadWordList() {\r\n        document.getElementById(\"open-wordlist-input\")!.click();\r\n    }\r\n\r\n    function clearWordLists() {\r\n        if (!window.confirm(\"Are you sure you want to clear the word lists?\")) return;\r\n\r\n        Globals.wordList = undefined;\r\n        Globals.wordLists = [];\r\n        setFillStatus(FillStatus.NoWordList);\r\n        Globals.selectedWordNode = undefined;\r\n        Globals.qualityClasses = new Map<string, QualityClass>();\r\n    }\r\n\r\n    function onWordListUpload(event: any) {\r\n        let file = event.target.files[0];\r\n        event.target.value = null;\r\n        setIsWordListLoading(true);\r\n\r\n        setTimeout(() => {\r\n            processWordListData(file.name, file).then(wordList => {\r\n                if (wordList) {\r\n                    Globals.wordLists!.push(wordList);\r\n                    setFillStatus(FillStatus.Ready);\r\n                    let grid = getGrid();\r\n                    updateGridConstraintInfo(grid);\r\n                    updateManualEntryCandidates(grid);\r\n                    setIsWordListLoading(false);\r\n                    triggerUpdate();\r\n                }\r\n            });\r\n        }, 5);\r\n    }\r\n\r\n    useInterval(() => {\r\n        doFillWord();\r\n    }, isFillRunning ? 5 : null);\r\n\r\n    let grid = getGrid();\r\n    let selectedSymmetry = SymmetryType[Globals.gridSymmetry!];\r\n    let symmetryOptions = (!grid || grid.width === grid.height) ?\r\n        Object.values(SymmetryType).filter(t => isNaN(Number(t))) :\r\n        getSymmetryTypesForRectGrids();\r\n\r\n    let fillStatusStr = getFillStatusString(Globals.fillStatus!);\r\n    \r\n    let wordLists = Globals.wordLists || [];\r\n\r\n    let entryCandidates = Globals.selectedWordNode ? Globals.selectedWordNode.entryCandidates : [];\r\n    let isNoEntryCandidates = Globals.selectedWordNode && entryCandidates.length === 0;\r\n\r\n    let sections = [] as Section[];\r\n    if (Globals.sections!) {\r\n        let sectionsOrder = calculateSectionOrder(mapValues(Globals.sections!));\r\n        sections = sectionsOrder.map(id => Globals.sections!.get(id)!);\r\n    }\r\n    let activeSection = Globals.sections ? Globals.sections!.get(Globals.activeSectionId!)! : makeNewSection(-1);\r\n    let selectedScKey = activeSection.selectedCandidate;\r\n    let selectedSectionIds = mapKeys(Globals.selectedSectionIds!) || [0];\r\n    let sectionCandidates = mapValues(activeSection.candidates)\r\n        .filter(sc => !sc.isFilteredOut).sort((a, b) => b.score - a.score);\r\n    let selectedEntry = Globals.selectedWordKey ? getEntryAtWordKey(grid, Globals.selectedWordKey!) : \"\";\r\n    let selectedMaxIffyLength = Globals.maxIffyLength || 0;\r\n    let useManualHeuristics = Globals.useManualHeuristics !== undefined ? Globals.useManualHeuristics : true;\r\n\r\n    let wordListsStyle = {\r\n        gridTemplateColumns: `4fr 1fr`\r\n    } as React.CSSProperties;\r\n\r\n    let entryCandidatesStyle = {\r\n        gridTemplateColumns: `4fr 1fr 2fr`\r\n    } as React.CSSProperties;\r\n\r\n    let sectionsStyle = {\r\n        gridTemplateColumns: `1fr 2fr 1fr 1fr 1fr`\r\n    } as React.CSSProperties;\r\n\r\n    let fillsStyle = {\r\n        gridTemplateColumns: `4fr 1fr 2fr`\r\n    } as React.CSSProperties;\r\n\r\n    return (\r\n        <div id=\"FillView\" className=\"fill-container\">\r\n            <input id=\"open-wordlist-input\" hidden type=\"file\" accept=\".dict,.txt\" onChange={onWordListUpload} />\r\n            <div id=\"loader\" style={{display: isWordListLoading ? \"block\" : \"none\"}}></div>\r\n\r\n            <div className={\"fill-status\" +\r\n                (Globals.fillStatus! === FillStatus.NoWordList ? \" fill-status-red\" :\r\n                Globals.fillStatus! === FillStatus.Running ? \" fill-status-green\" : \"\")}>{fillStatusStr}</div>\r\n            {wordLists.length > 0 &&\r\n            <>\r\n                <div className=\"custom-control custom-switch fill-switch\">\r\n                    <input type=\"checkbox\" className=\"custom-control-input\" id=\"fillSwitch\" \r\n                        checked={isFillRunning} onChange={handleToggleFill} />\r\n                    <label className=\"custom-control-label\" htmlFor=\"fillSwitch\">Fill</label>\r\n                </div>\r\n                <br />\r\n                Max Iffy Length: <br />\r\n                <select className=\"custom-select iffy-select\" defaultValue={selectedMaxIffyLength} onChange={handleIffyLengthChange}>\r\n                    <option value={0} key={0}>Off</option>\r\n                    {[2, 3, 4, 5, 6, 7].map(length => (\r\n                        <option value={length} key={length}>{length}</option>\r\n                    ))}\r\n                </select>\r\n            </>\r\n            }\r\n            \r\n            <br /><br />\r\n            Grid Symmetry: <br />\r\n            <select className=\"custom-select symmetry-select\" defaultValue={selectedSymmetry} onChange={handleSymmetryChange}>\r\n                {symmetryOptions.map(type => (\r\n                    <option value={type} key={type}>{getSymmetryTypeString(type.toString())}</option>\r\n                ))}\r\n            </select>\r\n            <br /><br />\r\n            <button className=\"btn btn-primary\" onClick={handleFillWordClick} style={{display: \"none\"}}>Fill Word</button>\r\n\r\n            <div className=\"fill-lists\">\r\n                <div className=\"fill-list-box\">\r\n                    <div className=\"fill-list-title\">Word Lists</div>\r\n                    <div className=\"fill-list-button\" onClick={clearWordLists}>Clear</div>\r\n                    <div className=\"fill-list-button\" onClick={loadWordList}>Load</div>\r\n                    <div className=\"fill-list\" style={wordListsStyle}>\r\n                        <div className=\"fill-list-header\">Filename</div>\r\n                        <div className=\"fill-list-header\">Count</div>\r\n                        { wordLists.length === 0 && (\r\n                            <div className=\"fill-list-row-wrapper\" style={{cursor: \"auto\"}}>\r\n                                <div><i>No word lists loaded</i></div><div></div>\r\n                            </div>\r\n                        )}\r\n                        { wordLists.map(wl => (\r\n                            <div className=\"fill-list-row-wrapper\" style={{cursor: \"auto\"}} key={wl.filename}>\r\n                                <div>{wl.filename}</div>\r\n                                <div>{wl.wordCount}</div>\r\n                            </div>\r\n                        ))}\r\n                    </div>\r\n                </div>\r\n                <div className=\"fill-list-box\" onMouseOut={handleEntryCandidateBlur}>\r\n                    <div className=\"fill-list-title entry-color\">Entry Candidates</div>\r\n                    <div className=\"fill-sec-checkbox\">\r\n                        <input type=\"checkbox\" className=\"section-checkbox\" id=\"use-heuristics-box\"\r\n                                    checked={useManualHeuristics} onChange={handleUseHeuristicsToggle} />\r\n                        <label htmlFor=\"use-heuristics-box\">Use heuristics</label>\r\n                    </div>\r\n                    <div className=\"fill-list\" style={entryCandidatesStyle}>\r\n                        <div className=\"fill-list-header\">Entry</div>\r\n                        <div className=\"fill-list-header\">Score</div>\r\n                        <div className=\"fill-list-header\">Iffy</div>\r\n                        { isNoEntryCandidates && useManualHeuristics && (\r\n                            <div className=\"fill-list-row-wrapper\">\r\n                                <div><i>No viable entries</i></div><div></div><div></div>\r\n                            </div>\r\n                        )}\r\n                        { entryCandidates.map(ec => (\r\n                            <div className={\"fill-list-row-wrapper\" + (selectedEntry === ec.word ? \" fill-list-row-selected\" : \"\")} \r\n                                key={ec.word + (ec.iffyEntry || \"\")} data-word={ec.word} data-iffykey={ec.iffyWordKey || \"na\"}\r\n                                onClick={handleEntryCandidateClick} onMouseOver={handleEntryCandidateHover}>\r\n                                <div>{ec.word}</div>\r\n                                <div>{ec.score.toFixed(0)}</div>\r\n                                <div>{ec.iffyEntry || \"\"}</div>\r\n                            </div>\r\n                        ))}\r\n                    </div>\r\n                </div>\r\n                <div className=\"fill-list-box\" onMouseOut={handleSectionBlur}>\r\n                    <div className=\"fill-list-title section-color\">Sections</div>\r\n                    <div className=\"fill-list\" style={sectionsStyle}>\r\n                        <div className=\"fill-list-header\">Active</div>\r\n                        <div className=\"fill-list-header\">ID</div>\r\n                        <div className=\"fill-list-header\">Size</div>\r\n                        <div className=\"fill-list-header\">Conn</div>\r\n                        <div className=\"fill-list-header\">Fills</div>\r\n                        { sections.map(sec => (\r\n                            <div className={\"fill-list-row-wrapper\" + (sec.id === activeSection.id ? \" fill-list-row-selected\" : \"\")} \r\n                                key={sec.id} data-id={sec.id} onClick={handleSectionClick} onMouseOver={handleSectionHover}>\r\n                                <div><input type=\"checkbox\" className=\"section-checkbox\"\r\n                                    checked={selectedSectionIds.includes(sec.id)} onChange={handleSectionCheckClick} /></div>\r\n                                <div>{getPhoneticName(sec.id)}</div>\r\n                                <div>{sec.squares.size}</div>\r\n                                <div>{sec.connections.size}</div>\r\n                                <div>{sec.candidates.size}</div>\r\n                            </div>\r\n                        ))}\r\n                    </div>\r\n                </div>\r\n                <div className=\"fill-list-box\" onMouseOut={handleSectionCandidateBlur}>\r\n                    <div className=\"fill-list-title\">Fills {sectionCandidates.length > 0 ? `(${sectionCandidates.length})` : \"\"}</div>\r\n                    <div className=\"fill-list-button\" onClick={clearSectionCandidates}>Clear</div>\r\n                    <div className=\"fill-sec-checkbox\">\r\n                        <input type=\"checkbox\" className=\"section-checkbox\" id=\"show-fills-box\"\r\n                                    checked={showSectionCandidates} onChange={handleShowSectionCandidatesToggle} />\r\n                        <label htmlFor=\"show-fills-box\">Show</label>\r\n                    </div>\r\n                    <div className=\"fill-list\" style={fillsStyle}>\r\n                        <div className=\"fill-list-header\">Longest</div>\r\n                        <div className=\"fill-list-header\">Score</div>\r\n                        <div className=\"fill-list-header\">Iffy</div>\r\n                        {!showSectionCandidates && (\r\n                            <div className=\"fill-list-row-wrapper\">\r\n                                <div><i>Hidden</i></div><div></div><div></div>\r\n                            </div>\r\n                        )}\r\n                        {showSectionCandidates && Globals.fillStatus === FillStatus.Complete && sectionCandidates.length === 0 && (\r\n                            <div className=\"fill-list-row-wrapper\">\r\n                                <div><i>No fills found</i></div><div></div><div></div>\r\n                            </div>\r\n                        )}\r\n                        {showSectionCandidates && sectionCandidates.map(sc => {\r\n                            let entry = getLettersFromSquares(getSquaresForWord(sc.grid, getLongestStackWord(activeSection)));\r\n                            let candidateKey = sectionCandidateKey(activeSection, sc.grid);\r\n\r\n                            return (\r\n                            <div className={\"fill-list-row-wrapper\" + (selectedScKey === candidateKey ? \" fill-list-row-selected\" : \"\")}\r\n                                key={candidateKey} data-candidate-key={candidateKey}\r\n                                onClick={handleSectionCandidateClick} onMouseOver={handleSectionCandidateHover}>\r\n                                <div>{entry}</div>\r\n                                <div>{sc.score.toFixed(2)}</div>\r\n                                <div>{sc.iffyEntry || \"\"}</div>\r\n                            </div>\r\n                        )})}\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default FillView;\r\n","import { useEffect, useRef } from 'react';\r\n\r\nexport function useInterval(callback: () => void, delay: number | null) {\r\n  const savedCallback = useRef<() => void>();\r\n\r\n  // Remember the latest callback.\r\n  useEffect(() => {\r\n    savedCallback.current = callback;\r\n  }, [callback]);\r\n\r\n  // Set up the interval.\r\n  useEffect(() => {\r\n    function tick() {\r\n      if (savedCallback.current) savedCallback.current();\r\n    }\r\n    if (delay !== null) {\r\n      let id = setInterval(tick, delay);\r\n      return () => clearInterval(id);\r\n    }\r\n  }, [delay]);\r\n}\r\n","import React from 'react';\r\nimport { ContentType } from '../../models/ContentType';\r\nimport { QualityClass } from '../../models/QualityClass';\r\nimport { SquareType } from '../../models/SquareType';\r\nimport { SquareProps } from './SquareProps';\r\n\r\nfunction Square(props: SquareProps) {\r\n    return getSquareElement(props);\r\n}\r\n\r\nfunction getSquareElement(props: SquareProps) {\r\n    let content = props.content || \"\";\r\n    if (props.type === SquareType.White) {\r\n        return <div \r\n                    className={\"grid-square\" + \r\n                        (props.isSelected ? \" grid-square-selected\" : \r\n                        props.isInSelectedWord ? \" grid-square-selected-word\" : \r\n                        props.isInSelectedSection ? \" grid-square-selected-section\" : \"\") +\r\n                        (props.content ? \"\" :\r\n                        props.constraintSum === 0 ? \" grid-square-error-word\" :\r\n                        between(props.constraintSum, 1, 1) ? \" grid-square-constrained-5\" : \r\n                        between(props.constraintSum, 1, 3) ? \" grid-square-constrained-4\" : \r\n                        between(props.constraintSum, 1, 5) ? \" grid-square-constrained-3\" : \r\n                        between(props.constraintSum, 1, 10) ? \" grid-square-constrained-2\" : \r\n                        between(props.constraintSum, 1, 15) ? \" grid-square-constrained-1\" : \"\"\r\n                        )} \r\n                    data-row={props.row} data-col={props.col}>\r\n            {props.isCircled && \r\n                <div className=\"grid-square-circled\"></div>\r\n            }\r\n            <div className=\"grid-number\">{props.number ?? \"\"}</div>\r\n            <div className={\"grid-content\" + \r\n                        (content.length > 1 ? \" grid-content-rebus\" : \"\") +\r\n                        (props.content && props.contentType === ContentType.User ? \"\" :\r\n                         props.content && props.contentType === ContentType.ChosenWord ? \" grid-content-chosen-word\" :\r\n                         props.content && props.contentType === ContentType.HoverChosenWord ? \" grid-content-chosen-word-hover\" :\r\n                         props.content && props.contentType === ContentType.ChosenSection ? \" grid-content-chosen-section\" :\r\n                         props.content && props.contentType === ContentType.HoverChosenSection ? \" grid-content-chosen-section-hover\" :\r\n                         props.qualityClass === QualityClass.Lively ? \" grid-content-lively\" :\r\n                         props.qualityClass === QualityClass.Normal ? \" grid-content-normal\" :\r\n                         props.qualityClass === QualityClass.Crosswordese ? \" grid-content-crosswordese\" :\r\n                         props.qualityClass === QualityClass.Iffy ? \" grid-content-iffy\" :\r\n                         props.qualityClass === QualityClass.NotAThing ? \" grid-content-notathing\" : \"\"\r\n                        )}>\r\n                    {content}\r\n            </div>\r\n        </div>\r\n    }\r\n    else {\r\n        return <div className={\"grid-square-black\" + (props.isSelected ? \" grid-square-black-selected\" : \"\")} \r\n            data-row={props.row} data-col={props.col}>\r\n        </div>\r\n    }\r\n}\r\n\r\nfunction between(input: number, min: number, max: number): boolean {\r\n    return input >= min && input <= max;\r\n}\r\n\r\nexport default Square;\r\n","import React, { useContext, useState } from 'react';\r\nimport { SquareType } from '../../models/SquareType';\r\nimport { SquareProps } from '../Square/SquareProps';\r\nimport \"./Grid.scss\";\r\nimport Square from '../Square/Square';\r\nimport { GridState } from '../../models/GridState';\r\nimport { WordDirection } from '../../models/WordDirection';\r\nimport Globals from '../../lib/windowService';\r\nimport { compareTuples, doesWordContainSquare, getGrid, getSection, getSelectedWord, getSquaresForWord, \r\n    getWordAtSquare, initializeSessionGlobals, isWordFull, mapValues, otherDir, \r\n    squareKey, wordKey } from '../../lib/util';\r\nimport { clearFill, eraseGridSquare, getLettersFromSquares, getSymmetrySquares, getUncheckedSquareDir, populateWords, \r\n    updateGridConstraintInfo, updateManualEntryCandidates } from '../../lib/grid';\r\nimport { GridWord } from '../../models/GridWord';\r\nimport { AppContext } from '../../AppContext';\r\nimport { ContentType } from '../../models/ContentType';\r\nimport { updateSectionFilters } from '../../lib/section';\r\nimport { QualityClass } from '../../models/QualityClass';\r\nimport { GridSquare } from '../../models/GridSquare';\r\nimport { Section } from '../../models/Section';\r\n\r\nfunction Grid() {\r\n    const [selectedSquare, setSelectedSquare] = useState([-1, -1] as [number, number]);\r\n    const appContext = useContext(AppContext);\r\n\r\n    function handleClick(event: any) {\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || ![\"grid-square\", \"grid-square-black\"].includes(target.classList[0])) {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        let row = +target.attributes[\"data-row\"].value;\r\n        let col = +target.attributes[\"data-col\"].value;\r\n        let grid = getGrid();\r\n        \r\n        let newDirection = Globals.selectedWordDir || WordDirection.Across;\r\n\r\n        let uncheckedSquareDir = getUncheckedSquareDir(grid, row, col);\r\n        if (uncheckedSquareDir !== undefined) {\r\n            newDirection = uncheckedSquareDir;\r\n            setSelectedSquare([row, col]);\r\n        }\r\n        else if (compareTuples([row, col], selectedSquare)) {\r\n            newDirection = otherDir(newDirection);\r\n        }\r\n        else {\r\n            setSelectedSquare([row, col]);\r\n        }\r\n\r\n        Globals.selectedWordDir = newDirection;\r\n        setSelWordAtSelSquare([row, col]);\r\n\r\n        updateManualEntryCandidates(grid);\r\n\r\n        appContext.triggerUpdate();\r\n    }\r\n    \r\n    function handleKeyDown(event: any) {\r\n        if (!isSquareSelected()) return;\r\n\r\n        let grid = getGrid();\r\n        let row = selectedSquare[0];\r\n        let col = selectedSquare[1];\r\n\r\n        let key: string = event.key.toUpperCase();\r\n        let letterChanged = false;\r\n        let blackSquareChanged = false;\r\n        let sq = grid.squares[row][col];\r\n        let newSelSq = [-1,-1] as [number, number];\r\n\r\n        if (key.match(/^[A-Z]$/)) {\r\n            newSelSq = advanceCursor();\r\n\r\n            if (sq.type === SquareType.Black) return;\r\n            if (sq.content === key && sq.contentType === ContentType.User) return;\r\n\r\n            letterChanged = true;\r\n            if (sq.content !== key && sq.contentType !== ContentType.User)\r\n                eraseGridSquare(grid, sq, Globals.selectedWordDir!);\r\n\r\n            sq = grid.squares[row][col];\r\n            sq.content = key;\r\n            sq.contentType = ContentType.User;\r\n        }\r\n        if (key === \"BACKSPACE\") {\r\n            newSelSq = backupCursor();\r\n\r\n            if (sq.content !== undefined) {\r\n                eraseGridSquare(grid, sq, Globals.selectedWordDir!);\r\n                letterChanged = true;\r\n            }\r\n                \r\n            if (sq.type === SquareType.Black) {\r\n                getSymmetrySquares([row, col]).forEach(res => {\r\n                    let resSq = grid.squares[res[0]][res[1]];\r\n                    resSq.type = SquareType.White;\r\n                });\r\n\r\n                blackSquareChanged = true;\r\n            }\r\n        }\r\n        // toggle black square\r\n        if (key === \".\") {\r\n            newSelSq = advanceCursor();\r\n\r\n            eraseGridSquare(grid, sq, Globals.selectedWordDir!);\r\n\r\n            let newSquareType = sq.type === SquareType.White ? SquareType.Black : SquareType.White;\r\n            getSymmetrySquares([row, col]).forEach(res => {\r\n                let resSq = grid.squares[res[0]][res[1]];\r\n                resSq.type = newSquareType;\r\n            });\r\n\r\n            blackSquareChanged = true;\r\n        }\r\n        // toggle circled square\r\n        if (key === \",\") {\r\n            if (sq.type === SquareType.Black) return;\r\n            sq.isCircled = !sq.isCircled;\r\n            newSelSq = advanceCursor();\r\n            setSelWordAtSelSquare(newSelSq);\r\n        }\r\n\r\n        if (blackSquareChanged) {\r\n            populateWords(grid);\r\n            initializeSessionGlobals();\r\n            clearFill(grid);\r\n            setSelWordAtSelSquare(newSelSq);\r\n            updateGridConstraintInfo(grid);\r\n        }\r\n        else if (letterChanged)  {\r\n            updateSectionFilters();\r\n            updateGridConstraintInfo(grid);\r\n        }\r\n\r\n        updateManualEntryCandidates(grid);\r\n\r\n        appContext.triggerUpdate();\r\n    }\r\n\r\n    function advanceCursor(): [number, number] {\r\n        let selSq = selectedSquare;\r\n        if (!isSquareSelected()) return selSq;\r\n    \r\n        let grid = getGrid();\r\n        let dir = Globals.selectedWordDir!;\r\n        if ((dir === WordDirection.Across && selSq[1] === grid.width-1) || (dir === WordDirection.Down && selSq[0] === grid.height-1))\r\n            return selSq;\r\n\r\n        let newSelSq = (dir === WordDirection.Across ? [selSq[0], selSq[1] + 1] : [selSq[0] + 1, selSq[1]]) as [number, number];\r\n        setSelectedSquare(newSelSq);\r\n        setSelWordAtSelSquare(newSelSq);\r\n        return newSelSq;\r\n    }\r\n    \r\n    function backupCursor(): [number, number] {\r\n        let selSq = selectedSquare;\r\n        if (!isSquareSelected()) return selSq;\r\n    \r\n        let dir = Globals.selectedWordDir!;\r\n        if ((dir === WordDirection.Across && selSq[1] === 0) || (dir === WordDirection.Down && selSq[0] === 0))\r\n            return selSq;\r\n\r\n        let newSelSq = (dir === WordDirection.Across ? [selSq[0], selSq[1] - 1] : [selSq[0] - 1, selSq[1]]) as [number, number];\r\n        setSelectedSquare(newSelSq);\r\n        setSelWordAtSelSquare(newSelSq);\r\n        return newSelSq;\r\n    }\r\n\r\n    function isSquareSelected(): boolean {\r\n        return selectedSquare[0] > -1;\r\n    }\r\n    \r\n    function isWordSelected(): boolean {\r\n        return !!getSelectedWord();\r\n    }\r\n\r\n    function isSquareInSection(section: Section, sq: GridSquare): boolean {\r\n        return section.squares.has(squareKey(sq));\r\n    }\r\n\r\n    function setSelWordAtSelSquare(newSelSquare: [number, number]) {\r\n        let grid = getGrid();\r\n        let word = getWordAtSquare(grid, newSelSquare[0], newSelSquare[1], Globals.selectedWordDir!);\r\n        Globals.selectedWordKey = word ? wordKey(word) : undefined;\r\n    }\r\n\r\n    function getSquareProps(grid: GridState, row: number, col: number, \r\n        selectedSquare: [number, number], selectedWord: GridWord | undefined): SquareProps {\r\n        let square = grid.squares[row][col];\r\n    \r\n        return {\r\n            key: `${row},${col}`,\r\n            row: row,\r\n            col: col,\r\n            number: square.number,\r\n            type: square.type,\r\n            content: square.content,\r\n            contentType: square.contentType,\r\n            qualityClass: qualityClassMap.get(squareKey(square)) || QualityClass.Normal,\r\n            isSelected: isSquareSelected() && compareTuples(selectedSquare, [row, col]),\r\n            isInSelectedWord: isWordSelected() && doesWordContainSquare(selectedWord!, row, col),\r\n            isInSelectedSection: (Globals.activeSectionId !== 0 && isSquareInSection(getSection(), square)) ||\r\n                (Globals.hoverSectionId !== undefined && isSquareInSection(Globals.sections!.get(Globals.hoverSectionId)!, square)),\r\n            constraintSum: square.viableLetters ? square.viableLetters.length : 26,\r\n            isCircled: square.isCircled,\r\n        };\r\n    }\r\n\r\n    function getSquareElement(props: SquareProps) {\r\n        return <Square {...props}></Square>\r\n    }\r\n\r\n    function suppressEnterKey(event: any) {\r\n        let keyPressed: string = event.key.toUpperCase();\r\n\r\n        if (keyPressed === \"ENTER\") {\r\n            event.preventDefault();\r\n        }\r\n    }\r\n\r\n    function handleFocus(event: any) {\r\n        selectElementContents(event.target);\r\n    }\r\n\r\n    // https://stackoverflow.com/questions/6139107/programmatically-select-text-in-a-contenteditable-html-element/6150060#6150060\r\n    function selectElementContents(el: any) {\r\n        var range = document.createRange();\r\n        range.selectNodeContents(el);\r\n        var sel = window.getSelection();\r\n        sel!.removeAllRanges();\r\n        sel!.addRange(range);\r\n    }\r\n\r\n    function setTitle() {\r\n        let newTitle = document.getElementById(\"puzzleTitle\")!.innerText;\r\n        Globals.puzzle!.title = newTitle === \"(title)\" ? \"Untitled\" : newTitle;\r\n    }\r\n\r\n    function setAuthor() {\r\n        let newAuthor = document.getElementById(\"puzzleAuthor\")!.innerText;\r\n        Globals.puzzle!.author = newAuthor === \"(author)\" ? \"\" : newAuthor;\r\n    }\r\n\r\n    function setCopyright() {\r\n        let newCopyright = document.getElementById(\"puzzleCopyright\")!.innerText;\r\n        Globals.puzzle!.copyright = newCopyright === \"© copyright\" ? \"\" : newCopyright;\r\n    }\r\n\r\n    function setNotes() {\r\n        let newNotes = document.getElementById(\"puzzleNotes\")!.innerText;\r\n        Globals.puzzle!.notes = newNotes === \"(notes)\" ? \"\" : newNotes;\r\n    }\r\n\r\n    function generateQualityClassMap(grid: GridState): Map<string, QualityClass> {\r\n        let ret = new Map<string, QualityClass>();\r\n\r\n        let acrossWords = mapValues(grid.words).filter(w => w.direction === WordDirection.Across);\r\n        acrossWords.forEach(w => {\r\n            let squares = getSquaresForWord(grid, w);\r\n            if (isWordFull(squares)) {\r\n                let letters = getLettersFromSquares(squares);\r\n                let qc = Globals.qualityClasses ? Globals.qualityClasses!.get(letters) : QualityClass.Normal;\r\n                squares.forEach(sq => {\r\n                    if (sq.contentType === ContentType.Autofill)\r\n                        ret.set(squareKey(sq), qc || QualityClass.Iffy);\r\n                });\r\n            }\r\n        });\r\n\r\n        let downWords = mapValues(grid.words).filter(w => w.direction === WordDirection.Down);\r\n        downWords.forEach(w => {\r\n            let squares = getSquaresForWord(grid, w);\r\n            if (isWordFull(squares)) {\r\n                let letters = getLettersFromSquares(squares);\r\n                let qc = Globals.qualityClasses ? Globals.qualityClasses!.get(letters) : QualityClass.Normal;\r\n                squares.forEach(sq => {\r\n                    if (sq.contentType === ContentType.Autofill) {\r\n                        let curQc = ret.get(squareKey(sq)) || QualityClass.Normal;\r\n                        if (!qc || qc < curQc)\r\n                            ret.set(squareKey(sq), qc || QualityClass.Iffy);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n\r\n        return ret;\r\n    }\r\n\r\n    let puzzle = Globals.puzzle!;\r\n    let grid = Globals.hoverGrid ? Globals.hoverGrid! : getGrid();\r\n    let qualityClassMap = generateQualityClassMap(grid);\r\n\r\n    let squareElements = [];\r\n    for (let row = 0; row < grid.height; row++) {\r\n        for (let col = 0; col < grid.width; col++) {\r\n            let sqProps = getSquareProps(grid, row, col, selectedSquare, getSelectedWord());\r\n            squareElements.push(getSquareElement(sqProps));\r\n        }\r\n    }\r\n\r\n    let columnTemplateStyle = {\r\n        gridTemplateColumns: `repeat(${grid.width}, 1fr)`\r\n    } as React.CSSProperties;\r\n\r\n    return (\r\n        <>\r\n            <div className=\"puzzle-author-by\">&nbsp;</div>\r\n            <div id=\"puzzleTitle\" className=\"puzzle-title editable\" contentEditable={true} suppressContentEditableWarning={true}\r\n                onKeyDown={suppressEnterKey} onBlur={setTitle} onFocusCapture={handleFocus}>{puzzle.title || \"(title)\"}</div>\r\n            <div className=\"puzzle-author-by\">by&nbsp;</div>\r\n            <div id=\"puzzleAuthor\" className=\"puzzle-author editable\" contentEditable={true} suppressContentEditableWarning={true}\r\n                onKeyDown={suppressEnterKey} onBlur={setAuthor} onFocusCapture={handleFocus}>{puzzle.author || \"(author)\"}</div>\r\n            <div className=\"puzzle-author-by\">&nbsp;</div>\r\n            <div id=\"puzzleCopyright\" className=\"puzzle-copyright editable\" contentEditable={true} suppressContentEditableWarning={true}\r\n                onKeyDown={suppressEnterKey} onBlur={setCopyright} onFocusCapture={handleFocus}>{puzzle.copyright || \"© copyright\"}</div>\r\n            \r\n            <div id=\"Grid\" className=\"grid-container\" style={columnTemplateStyle}\r\n                onClick={handleClick} onKeyDown={handleKeyDown} tabIndex={0}>\r\n                {squareElements}\r\n            </div>\r\n\r\n            <div className=\"puzzle-notes-label\">Notes:</div>\r\n            <div id=\"puzzleNotes\" className=\"puzzle-notes editable\" contentEditable={true} suppressContentEditableWarning={true}\r\n                onKeyDown={suppressEnterKey} onBlur={setNotes} onFocusCapture={handleFocus}>{puzzle.notes || \"(notes)\"}</div>\r\n        </>\r\n    );\r\n}\r\n\r\nexport default Grid;\r\n","import { ContentType } from \"../models/ContentType\";\r\nimport { GridWord } from \"../models/GridWord\";\r\nimport { Puzzle } from \"../models/Puzzle\";\r\nimport { SquareType } from \"../models/SquareType\";\r\nimport { WordDirection } from \"../models/WordDirection\";\r\nimport { createNewGrid, populateWords } from \"./grid\";\r\nimport { deepClone, getGrid, mapValues, newPuzzle, wordKey } from \"./util\";\r\nimport Globals from '../lib/windowService';\r\n\r\n// https://code.google.com/archive/p/puz/wikis/FileFormat.wiki\r\n\r\nexport async function loadPuzFile(url: string): Promise<Puzzle | undefined> {\r\n    let response = await fetch(url);\r\n    let data: Blob = await response.blob();\r\n\r\n    return processPuzData(data);\r\n}\r\n\r\nexport async function processPuzData(data: Blob): Promise<Puzzle | undefined> {\r\n    let magicString = await data.slice(0x02, 0x0e).text();\r\n    if (magicString !== \"ACROSS&DOWN\\0\") return undefined;\r\n\r\n    let width = new Uint8Array(await data.slice(0x2c, 0x2d).arrayBuffer())[0];\r\n    let height = new Uint8Array(await data.slice(0x2d, 0x2e).arrayBuffer())[0];\r\n\r\n    let puzzle = newPuzzle();\r\n    let restOfFile = await blobToText(await data.slice(0x34, data.size));\r\n    let grid = createNewGrid(width, height);\r\n\r\n    let i = 0;\r\n    for (let row = 0; row < height; row++) {\r\n        for (let col = 0; col < width; col++) {\r\n            let curChar = restOfFile[i];\r\n            let square = grid.squares[row][col];\r\n            if (curChar === \".\")\r\n                square.type = SquareType.Black;\r\n            if (curChar === \"-\") {} // no data entered\r\n            if (curChar.match(/[A-Z]/)) {\r\n                square.content = curChar;\r\n                square.contentType = ContentType.User;\r\n            }\r\n            i++;\r\n        }\r\n    }\r\n    i *= 2; // skip over user progress\r\n\r\n    populateWords(grid);\r\n    \r\n    [puzzle.title, i] = getNextString(restOfFile, i);\r\n    [puzzle.author, i] = getNextString(restOfFile, i);\r\n    [puzzle.copyright, i] = getNextString(restOfFile, i);\r\n\r\n    let sortedWords = sortWordsForPuz(mapValues(grid.words));\r\n    sortedWords.forEach(word => {\r\n        let clue = \"\";\r\n        [clue, i] = getNextString(restOfFile, i);\r\n        let key = wordKey(word);\r\n        puzzle.clues.set(key, clue);\r\n    });\r\n\r\n    [puzzle.notes, i] = getNextString(restOfFile, i);\r\n\r\n    let rebusSquareMappings = new Map<string, number>();\r\n    let rebusValues = new Map<number, string>();\r\n\r\n    while (i < restOfFile.length) {\r\n        let sectionType = restOfFile.slice(i, i+4);\r\n        i += 4;\r\n        let dlI = 0x34 + i;\r\n        let dataLength = new Uint16Array(await data.slice(dlI, dlI+2).arrayBuffer())[0];\r\n        i += 2;\r\n        i += 2; // skip checksum\r\n\r\n        if (sectionType === \"GRBS\") { // rebus grid\r\n            let secI = 0x34 + i;\r\n            for (let row = 0; row < height; row++) {\r\n                for (let col = 0; col < width; col++) {\r\n                    let n = new Uint8Array(await data.slice(secI, secI + 1).arrayBuffer())[0];\r\n                    secI++;\r\n                    if (n > 0) {\r\n                        rebusSquareMappings.set(`${row},${col}`, n-1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (sectionType === \"RTBL\") { // rebus values\r\n            let valuesStr = restOfFile.slice(i, i + dataLength);\r\n            let valueStrs = valuesStr.split(\";\");\r\n            valueStrs.forEach(str => {\r\n                let tokens = str.split(\":\");\r\n                let n = +tokens[0].trim();\r\n                let val = tokens[1];\r\n                if (n > 0) rebusValues.set(n, val);\r\n            });\r\n        }\r\n        if (sectionType === \"GEXT\") { // extra flags\r\n            let secI = 0x34 + i;\r\n            for (let row = 0; row < height; row++) {\r\n                for (let col = 0; col < width; col++) {\r\n                    let n = new Uint8Array(await data.slice(secI, secI + 1).arrayBuffer())[0];\r\n                    secI++;\r\n                    if (n & 0x80) {\r\n                        grid.squares[row][col].isCircled = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        i += dataLength + 1;\r\n    }\r\n\r\n    if (rebusSquareMappings.size > 0) {\r\n        rebusSquareMappings.forEach((v, k) => {\r\n            let tokens = k.split(\",\");\r\n            let square = grid.squares[+tokens[0]][+tokens[1]];\r\n            square.content = rebusValues.get(v)![0]; // TODO: Use full value when we have rebus support\r\n            square.contentType = ContentType.User;\r\n        });\r\n    }\r\n\r\n    Globals.activeGrid = grid;\r\n    return puzzle;\r\n}\r\n\r\nasync function blobToText(blob: Blob): Promise<string> {\r\n    let arr = Array.from(new Uint8Array(await blob.arrayBuffer()));\r\n    return arr.map(x => String.fromCharCode(x)).join(\"\");\r\n}\r\n\r\nfunction getNextString(data: string, i: number): [string, number] {\r\n    let ret = \"\";\r\n    while(data[i] !== \"\\0\") {\r\n        ret += data[i];\r\n        i++;\r\n    }\r\n    i++;\r\n    return [ret.trim(), i];\r\n}\r\n\r\nexport function generatePuzFile(puzzle: Puzzle): Blob {\r\n    let grid = getGrid();\r\n    let bytes = new Uint8Array(128_000);\r\n    insertString(bytes, \"ACROSS&DOWN\\0\", 0x02);\r\n    insertString(bytes, \"1.3\\0\", 0x18);\r\n\r\n    insertNumber(bytes, grid.width, 0x2c, 1);\r\n    insertNumber(bytes, grid.height, 0x2d, 1);\r\n    insertNumber(bytes, grid.words.size, 0x2e, 2);\r\n    insertNumber(bytes, 1, 0x30, 2);\r\n    insertNumber(bytes, 0, 0x32, 2);\r\n\r\n    let pos = 0x34;\r\n    let solutionPos = pos;\r\n    let areCircledSquares = false;\r\n    for (let row = 0; row < grid.height; row++) {\r\n        for (let col = 0; col < grid.width; col++) {\r\n            let sq = grid.squares[row][col];\r\n            let char = sq.type === SquareType.Black ? \".\" : sq.content ? sq.content : \" \";\r\n            insertString(bytes, char, pos);\r\n            pos++;\r\n\r\n            if (sq.isCircled) areCircledSquares = true;\r\n        }\r\n    }\r\n    let gridPos = pos;\r\n    for (let row = 0; row < grid.height; row++) {\r\n        for (let col = 0; col < grid.width; col++) {\r\n            let sq = grid.squares[row][col];\r\n            let char = sq.type === SquareType.Black ? \".\" : \"-\";\r\n            insertString(bytes, char, pos);\r\n            pos++;\r\n        }\r\n    }\r\n\r\n    let titlePos = pos;\r\n    insertString(bytes, puzzle.title + \"\\0\", pos);\r\n    pos += puzzle.title.length + 1;\r\n    let authorPos = pos;\r\n    insertString(bytes, puzzle.author + \"\\0\", pos);\r\n    pos += puzzle.author.length + 1;\r\n    let copyrightPos = pos;\r\n    insertString(bytes, puzzle.copyright + \"\\0\", pos);\r\n    pos += puzzle.copyright.length + 1;\r\n\r\n    let orderedClues = [] as string[];\r\n    let sortedWords = sortWordsForPuz(mapValues(grid.words));\r\n    sortedWords.forEach(word => {\r\n        let key = wordKey(word);\r\n        orderedClues.push(puzzle.clues.get(key)! || \"\");\r\n    });\r\n\r\n    let cluesPos = pos;\r\n    orderedClues.forEach(oc => {\r\n        insertString(bytes, oc + \"\\0\", pos);\r\n        pos += oc.length + 1;\r\n    });\r\n\r\n    insertString(bytes, puzzle.notes + \"\\0\", pos);\r\n    pos++;\r\n\r\n    if (areCircledSquares) {\r\n        let sectionSize = grid.width * grid.height;\r\n        insertString(bytes, \"GEXT\", pos);\r\n        pos += 4;\r\n        insertNumber(bytes, sectionSize, pos, 2);\r\n        pos += 2;\r\n        let checksumPos = pos;\r\n        pos += 2;\r\n        for (let row = 0; row < grid.height; row++) {\r\n            for (let col = 0; col < grid.width; col++) {\r\n                let sq = grid.squares[row][col];\r\n                insertNumber(bytes, sq.isCircled ? 0x80 : 0, pos, 1);\r\n                pos++;\r\n            }\r\n        }\r\n        insertString(bytes, \"\\0\", pos);\r\n        pos++;\r\n\r\n        let cksum = cksum_region(bytes, checksumPos + 2, sectionSize, 0);\r\n        insertNumber(bytes, cksum, checksumPos, 2);\r\n    }\r\n\r\n    let c_cib = cksum_region(bytes, 0x2c, 8, 0);\r\n    let cksum = c_cib;\r\n    let squaresTotal = grid.width*grid.height;\r\n    cksum = cksum_region(bytes, solutionPos, squaresTotal, cksum);\r\n    cksum = cksum_region(bytes, gridPos, squaresTotal, cksum);\r\n    if (puzzle.title.length > 0) cksum = cksum_region(bytes, titlePos, puzzle.title.length+1, cksum);\r\n    if (puzzle.author.length > 0) cksum = cksum_region(bytes, authorPos, puzzle.author.length+1, cksum);\r\n    if (puzzle.copyright.length > 0) cksum = cksum_region(bytes, copyrightPos, puzzle.copyright.length+1, cksum);\r\n    let cluePos = cluesPos;\r\n    for(let i = 0; i < orderedClues.length; i++) {\r\n        let clue = orderedClues[i];\r\n        cksum = cksum_region(bytes, cluePos, clue.length, cksum);\r\n        cluePos += clue.length+1;\r\n    }\r\n    insertNumber(bytes, c_cib, 0x0e, 2);\r\n    insertNumber(bytes, cksum, 0x00, 2);\r\n\r\n    let c_sol = cksum_region(bytes, solutionPos, squaresTotal, 0);\r\n    let c_grid = cksum_region(bytes, gridPos, squaresTotal, 0);\r\n    let c_part = 0;\r\n    if (puzzle.title.length > 0) c_part = cksum_region(bytes, titlePos, puzzle.title.length+1, c_part);\r\n    if (puzzle.author.length > 0) c_part= cksum_region(bytes, authorPos, puzzle.author.length+1, c_part);\r\n    if (puzzle.copyright.length > 0) c_part = cksum_region(bytes, copyrightPos, puzzle.copyright.length+1, c_part);\r\n    cluePos = cluesPos;\r\n    for(let i = 0; i < orderedClues.length; i++) {\r\n        let clue = orderedClues[i];\r\n        c_part = cksum_region(bytes, cluePos, clue.length, c_part);\r\n        cluePos += clue.length+1;\r\n    }\r\n    insertNumber(bytes, 0x49 ^ (c_cib & 0xFF), 0x10, 1);\r\n    insertNumber(bytes, 0x43 ^ (c_sol & 0xFF), 0x11, 1);\r\n    insertNumber(bytes, 0x48 ^ (c_grid & 0xFF), 0x12, 1);\r\n    insertNumber(bytes, 0x45 ^ (c_part & 0xFF), 0x13, 1);\r\n    insertNumber(bytes, 0x41 ^ ((c_cib & 0xFF00) >> 8), 0x14, 1);\r\n    insertNumber(bytes, 0x54 ^ ((c_sol & 0xFF00) >> 8), 0x15, 1);\r\n    insertNumber(bytes, 0x45 ^ ((c_grid & 0xFF00) >> 8), 0x16, 1);\r\n    insertNumber(bytes, 0x44 ^ ((c_part & 0xFF00) >> 8), 0x17, 1);\r\n\r\n    let finalArray = bytes.slice(0, pos);\r\n    return new Blob([finalArray], {type: \"application/octet-stream; charset=ISO-8859-1\"});\r\n}\r\n\r\n// http://www.keiranking.com/phil/\r\nfunction cksum_region(bytes: Uint8Array, startPos: number, len: number, cksum: number) {\r\n    for (let i = 0; i < len; i++) {\r\n        cksum = (cksum >> 1) | ((cksum & 1) << 15);\r\n        cksum = (cksum + bytes[startPos + i]) & 0xffff;\r\n    }\r\n    \r\n    return cksum; \r\n}\r\n\r\nfunction insertString(bytes: Uint8Array, str: string, pos: number) {\r\n    for (let i = 0; i < str.length; i++) {\r\n        bytes[pos] = str[i].charCodeAt(0);\r\n        pos++;\r\n    }\r\n}\r\n\r\nfunction insertNumber(bytes: Uint8Array, n: number, pos: number, size: number) {\r\n    for (var index = size-1; index >= 0; --index) {\r\n      bytes[pos] = n % 256;\r\n      n = n >> 8;\r\n      pos++;\r\n    }\r\n}\r\n\r\nfunction sortWordsForPuz(words: GridWord[]): GridWord[] {\r\n    let sortedWords = (deepClone(words) as GridWord[]).sort((a, b) => {\r\n        if (a.start[0] !== b.start[0]) return a.start[0] - b.start[0];\r\n        if (a.start[1] !== b.start[1]) return a.start[1] - b.start[1];\r\n        return a.direction === WordDirection.Across ? -1 : 1;\r\n    });\r\n    return sortedWords;\r\n}\r\n","import React, { createRef, useContext, useRef } from 'react';\r\nimport \"./Menu.scss\";\r\nimport { MenuProps } from './MenuProps';\r\nimport { AppContext } from '../../AppContext';\r\nimport { processPuzData } from '../../lib/puzFiles';\r\n\r\nfunction Menu(props: MenuProps) {\r\n    const appContext = useContext(AppContext);\r\n    const sizeRefs = useRef([createRef(), createRef()] as any[]);\r\n\r\n    function handleViewChange(event: any) {\r\n        let target = event.target;\r\n        let newView = target.attributes[\"data-view-id\"].value;\r\n        \r\n        appContext.switchActiveView(newView);\r\n    }\r\n\r\n    function handleNewPuzzle() {\r\n        if (!window.confirm(\"Are you sure you want to start a new puzzle?\")) return;\r\n\r\n        let newWidth = +sizeRefs.current[0].current.value;\r\n        let newHeight = +sizeRefs.current[1].current.value;\r\n\r\n        appContext.createNewPuzzle(newWidth, newHeight);\r\n    }\r\n\r\n    function handleLoadPuz() {\r\n        document.getElementById(\"open-puzzle-input\")!.click();\r\n    }\r\n\r\n    function handleExportPuz() {\r\n        appContext.exportPuz();\r\n    }\r\n\r\n    function handleFocus(event: any) {\r\n        event.target.select();\r\n    }\r\n\r\n    function onFileUpload(event: any) {\r\n        let file = event.target.files[0];\r\n        event.target.value = null;\r\n\r\n        processPuzData(file).then(puzzle => {\r\n            if (puzzle) {\r\n                appContext.setPuzzle(puzzle);\r\n            }\r\n        });\r\n    }\r\n\r\n    return (\r\n        <div id=\"Menu\">\r\n            <input id=\"open-puzzle-input\" hidden type=\"file\" accept=\".puz\" onChange={onFileUpload} />\r\n\r\n            <div className=\"site-title\">CrossHatch</div>\r\n\r\n            <div className=\"menu-label\">View: </div>\r\n            <div className=\"btn-group\" role=\"group\" id=\"view-change-group\">\r\n                <button type=\"button\" data-view-id=\"Clues\"\r\n                    className={\"btn\" + (props.openView === \"Clues\" ? \" btn-primary\" : \" btn-secondary\")}\r\n                    onClick={handleViewChange}>\r\n                    Clues\r\n                </button>\r\n                <button type=\"button\" data-view-id=\"Fill\"\r\n                    className={\"btn\" + (props.openView === \"Fill\" ? \" btn-primary\" : \" btn-secondary\")}\r\n                    onClick={handleViewChange}>\r\n                    Fill\r\n                </button>\r\n            </div>\r\n            \r\n            <div className=\"new-grid-group\">\r\n                <div className=\"btn btn-primary\" onClick={handleNewPuzzle}>New Puzzle</div>\r\n                <input type=\"text\" className=\"form-control\" defaultValue={props.gridWidth} onFocus={handleFocus}\r\n                    ref={sizeRefs.current[0]}></input>\r\n                <div className=\"menu-gridsize-sep\"><div style={{height:\"6px\", float:\"none\"}}></div>x</div>\r\n                <input type=\"text\" className=\"form-control\" defaultValue={props.gridHeight} onFocus={handleFocus}\r\n                    ref={sizeRefs.current[1]}></input>\r\n            </div>\r\n            \r\n            <div id=\"loadPuz\" className=\"btn btn-primary menu-button\" onClick={handleLoadPuz}>Load .puz</div>\r\n            <div id=\"exportPuz\" className=\"btn btn-primary menu-button\" onClick={handleExportPuz}>Export .puz</div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Menu;\r\n","import React, { useEffect, useState } from 'react';\r\nimport { AppContext } from './AppContext';\r\nimport { AppProps } from './AppProps';\r\nimport CluesView from './components/CluesView/CluesView';\r\nimport FillView from './components/FillView/FillView';\r\nimport Grid from './components/Grid/Grid';\r\nimport Menu from './components/Menu/Menu';\r\nimport Globals from './lib/windowService';\r\nimport \"./App.scss\";\r\nimport { Puzzle } from './models/Puzzle';\r\nimport { getGrid, initializeSessionGlobals, newPuzzle } from './lib/util';\r\nimport { generatePuzFile } from './lib/puzFiles';\r\nimport { SymmetryType } from './models/SymmetryType';\r\nimport { clearFill, createNewGrid } from './lib/grid';\r\nimport { WordDirection } from './models/WordDirection';\r\nimport { FillStatus } from './models/FillStatus';\r\n\r\nfunction App(props: AppProps) {\r\n  const [activeView, setActiveView] = useState(props.activeView);\r\n  const [gridWidth, setGridWidth] = useState(7);\r\n  const [gridHeight, setGridHeight] = useState(7);\r\n  const [updateSemaphore, setUpdateSemaphore] = useState(0);\r\n  const [appState, setAppState] = useState(getAppContext());\r\n\r\n  useEffect(() => {\r\n    setAppState(getAppContext());\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [updateSemaphore]);\r\n\r\n  function getAppContext() {\r\n    return { \r\n      triggerUpdate: triggerUpdate,\r\n      switchActiveView: switchActiveView,\r\n      setPuzzle: setPuzzle,\r\n      createNewPuzzle: createNewPuzzle,\r\n      exportPuz: exportPuz,\r\n    }\r\n  }\r\n\r\n  function triggerUpdate() {\r\n    setUpdateSemaphore(updateSemaphore + 1);\r\n  }\r\n\r\n  function switchActiveView(newView: string) {\r\n    setActiveView(newView);\r\n  }\r\n\r\n  function createNewPuzzle(width: number, height: number) {\r\n    initializeGlobals(undefined, width, height);\r\n    triggerUpdate();\r\n  }\r\n\r\n  function setPuzzle(puzzle: Puzzle) {\r\n    let grid = getGrid();\r\n    initializeGlobals(puzzle, grid.width, grid.height);\r\n    triggerUpdate();\r\n  }\r\n\r\n  function exportPuz() {\r\n    let puzzle = Globals.puzzle!;\r\n    let blob = generatePuzFile(puzzle);\r\n    let filename = (puzzle.title || \"Untitled\")+\".puz\";\r\n    let file = new File([blob], filename);\r\n    const url= window.URL.createObjectURL(file);\r\n    let puzzleLink = document.getElementById(\"download-puzzle-link\");\r\n    puzzleLink!.setAttribute(\"href\", url);\r\n    puzzleLink!.setAttribute(\"download\", filename);\r\n    puzzleLink!.click();\r\n  }\r\n\r\n  function initializeGlobals(puzzle?: Puzzle, width?: number, height?: number) {\r\n    let isNewPuzzle = !!puzzle;\r\n    Globals.puzzle = puzzle || newPuzzle();\r\n    if (width === undefined) width = gridWidth;\r\n    if (height === undefined) height = gridHeight;\r\n    if (!Globals.activeGrid || !isNewPuzzle)\r\n      Globals.activeGrid = createNewGrid(width, height);\r\n    Globals.hoverGrid = undefined;\r\n    Globals.selectedWordKey = undefined;\r\n    Globals.selectedWordDir = WordDirection.Across;\r\n    if (!Globals.gridSymmetry) Globals.gridSymmetry = SymmetryType.Rotate180;\r\n    if (Globals.useManualHeuristics === undefined) Globals.useManualHeuristics = true;\r\n    if (Globals.maxIffyLength === undefined) Globals.maxIffyLength = 0;\r\n    Globals.selectedWordNode = undefined;\r\n    Globals.curChainId = 1;\r\n    if (Globals.wordLists === undefined) Globals.wordLists = [];\r\n    Globals.fillStatus = Globals.wordList !== undefined ? FillStatus.Ready : FillStatus.NoWordList;\r\n\r\n    initializeSessionGlobals();\r\n    clearFill(Globals.activeGrid!);\r\n\r\n    setGridWidth(width);\r\n    setGridHeight(height);\r\n  }\r\n\r\n  if (!Globals.puzzle) {\r\n    initializeGlobals();\r\n    triggerUpdate();\r\n  }\r\n\r\n  return (\r\n    <AppContext.Provider value={appState}>\r\n      <a id=\"download-puzzle-link\" href=\"http://www.example.com\" style={{display: \"none\"}}>stuff</a>\r\n\r\n      <Menu gridHeight={gridHeight} gridWidth={gridWidth} openView={activeView}></Menu>\r\n\r\n      <div className=\"left-panel\">\r\n        {activeView === \"Clues\" && \r\n            <CluesView updateSemaphore={updateSemaphore}></CluesView>\r\n        }\r\n        {activeView === \"Fill\" && \r\n            <FillView></FillView>\r\n        }\r\n      </div>\r\n      \r\n      <div className=\"right-panel\">\r\n        <Grid></Grid>\r\n      </div>\r\n    </AppContext.Provider>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\nimport 'bootstrap/dist/css/bootstrap.css';\r\n\r\n// import { loadWordListFromLocalhost } from './lib/wordList';\r\n// import Globals from './lib/windowService';\r\n// import { FillStatus } from './models/FillStatus';\r\n// loadWordListFromLocalhost(\"http://localhost/classifier/mainBrodaEntries.txt\").then(() => {\r\n//   Globals.fillStatus = FillStatus.Ready;\r\n// });\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App activeView=\"Fill\" />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n"],"sourceRoot":""}