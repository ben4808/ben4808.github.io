{"version":3,"sources":["models/SquareType.ts","models/WordDirection.ts","AppContext.ts","lib/windowService.tsx","models/SymmetryType.ts","models/ContentType.ts","models/QualityClass.ts","lib/wordList.ts","lib/entryCandidates.ts","lib/util.ts","lib/section.ts","lib/insertEntry.ts","lib/priorityQueue.ts","models/FillStatus.ts","lib/fill.ts","lib/grid.ts","components/CluesView/CluesView.tsx","components/FillView/FillView.tsx","lib/useInterval.ts","components/Square/Square.tsx","components/Grid/Grid.tsx","lib/puzFiles.ts","components/Menu/Menu.tsx","App.tsx","index.tsx"],"names":["SquareType","WordDirection","AppContext","React","createContext","triggerUpdate","switchActiveView","_","setPuzzle","createNewPuzzle","w","h","exportPuz","window","Globals","SymmetryType","ContentType","QualityClass","filename","data","a","text","lines","split","indexWordList","words","parseWordList","wordList","wordCount","length","qcMap","qualityClasses","Map","forEach","line","tokens","trim","match","score","qualityClass","Lively","Normal","Crosswordese","word","has","push","set","queryIndexedWordList","pattern","wl","letters","i","buckets","oneVal","charCodeAt","pos1","pos2","val1","val2","twoVal","filter","entries","existingList","ch1","ch2","populateAndScoreEntryCandidates","node","isForManualFill","wordKey","fillWord","iffyWordKey","populateNoHeuristicEntryCandidates","anchorSquareKeys","anchorInfo","populateFillWordAnchors","getSquaresForWord","startGrid","anchorCombosLeft","eligibleCandidates","heuristicsLevel","processAnchorCombo","getEligibleCandidates","ec","entryCandidates","sort","b","squares","deepClone","sq","isUserFilled","content","undefined","getLettersFromSquares","get","entry","getWordScore","isViable","hasBeenChained","wasChainFailure","crossScore","minCrossScore","calculatedSquares","anchorKeyCounts","count","squareKey","viableLetters","constraintLetterCount","combos","constraintLetters","map","sqKey","find","fullAlphabet","comboScores","letter1","letter2","letterFrequencies","Math","random","generateAnchorCombos","grid","combo","pop","fillWordKey","wordSquares","patternWithAnchor","insertLetterIntoPattern","isWordFull","crossKeys","crossCrossKeys","getAllCrosses","cross","crossCross","size","manualIffyKey","getWordAtSquare","row","col","otherDir","direction","csq","getFilteredEntries","usedWords","processEntry","maxIffyLength","ck","wordLength","wordScore","topCrossScore","topMinCrossScore","calculateEntryCandidateScore","distillIndex","crossSquares","includes","foundCountReduction","wKey","wordPattern","filteredEntries","anchorComboCount","newPattern","fe","reduce","newMatrix","Array","fill","letterMatrixToLetterList","existingCounts","iffyEntry","iffyWord","iffySquares","isq","idx","calSq","substring","anchorPattern","constraintCounts","x","curPatterns","lowestCount","index","newCurPatterns","ltr","broadenAnchorPatterns","newLetter","findIndex","updateSectionFilters","sections","getGrid","sec","candidates","can","sqKeys","mapKeys","isFilteredOut","gridSq","getSquareAtKey","canSq","isUserOrWordFilled","insertSectionCandidateIntoGrid","candidate","contentType","ChosenSection","newGrid","section","sectionId","foundDiscrepancy","candidateSq","HoverChosenSection","Autofill","forAllGridSquares","newSq","key","neighboringCrosses","generateConstraintInfoForSquares","userFilledSectionCandidates","sectionCandidateKey","generateGridSections","usedSquares","nextSectionId","fullSection","makeNewSection","isBlackSquare","isOpenSquare","newSection","iterateSection","openSquareCount","getNeighboringSquares","neighbor","Across","Down","dir","wsq","id","delete","stackWords","stackedNeighbors","otherKey","otherWord","isAcross","abs","start","min","end","max","sk","crossKey","wordOrder","calculateSectionOrder","mapValues","secOrder","calculateWordOrder","wk","connections","wordsSort","iterateWordGroup","group","centerIndex","floor","rowOrCol","slice","acrossSortedStackWords","downSortedStackWords","longestStack","stack","curGroup","prevRowOrCol","j","newWord","newRowOrCol","neighbors","n","ret","nClear","sClear","height","wClear","eClear","width","calculateSectionCandidateScore","total","foundIffy","natoAlphabet","k","join","comboPermsQueue","comboPermsUsed","getSelectedSectionCandidates","selectedSectionCandidateKeys","scKey","getSectionWithCandidate","sc","getSectionsWithWord","processAndInsertChosenEntry","chosenEntry","crosses","HoverChosenWord","ChosenWord","newSquares","getSectionCandidatesFromKeys","removeNonmatchingSectionCandidates","endGrid","FillStatus","fillSectionWord","getSection","fillQueue","newFillQueue","heap","left","right","hasRight","swap","temp","isEmpty","peek","value","insert","item","prio","p","tmp","current","largerChild","priorityQueue","populateSeedNodes","needsNewPriority","shouldBeDeleted","calculateNodePriority","isChainNode","chainId","curChainId","activeGrid","selectWordToFill","topScore","c","pow","roll","runningTotal","chooseEntryFromCandidates","processSectionNode","sectionString","getSectionString","newSecCandidateFound","newCandidate","getEntryAtWordKey","newSectionCandidate","invalidateChainNode","newNode","makeNewNode","depth","nextFillWord","curSections","nextSections","cs","ns","selectedWordNode","parent","prevCandidate","backtracks","chainBaseNode","chainIffyCandidates","chainGoodCandidates","curNode","isSectionBase","situationScore","selectedSectionIds","activeSectionId","activeSection","connectionIds","selectedCandidate","candidateCounts","comboKey","perm","toString","shift","defaultCombo","allOnes","foundNew","newPerm","newPermKey","getNewPermutations","wasSuccess","viableLetterCounts","Iffy","populateWords","processSquare","currentWord","number","nextSq","currentNumber","isAboveBlocked","isBelowBlocked","isLeftBlocked","isRightBlocked","isUnchecked","isUncheckedStart","isCheckedStart","numberizeGrid","updateGridConstraintInfo","wordKeys","concat","isWordEmpty","entryOptions","curViableMatrix","list","matrix","letterListToLetterMatrix","newViableMatrix","arr","newVal","setLettersArrayVal","createNewGrid","type","White","isCircled","getSymmetrySquares","initSquare","r","gridSymmetry","Rotate180","Rotate90","MirrorHorizontal","MirrorVertical","MirrorNWSE","MirrorNESW","eraseGridSquare","otherDirWord","otherDirSquares","User","isInSection","clearFill","eraseSectionCandidateFromGrid","getSelectedSectionCandidatesWithSquare","fillStatus","Ready","NoWordList","updateManualEntryCandidates","selectedWordKey","useManualHeuristics","obj","Date","getTime","from","Object","keys","newObj","compareTuples","first","second","Black","doesWordContainSquare","func","newPuzzle","title","author","copyright","clues","notes","getSelectedWord","values","sck","initializeSessionGlobals","hoverSectionId","String","fromCharCode","CluesView","props","useState","initClueProps","clueProps","setClueProps","selectedKey","setSelectedKey","textareasRef","useRef","puzzle","prop","clue","isOpenForEditing","handleClueClick","event","target","classList","parentElement","targetKey","attributes","refIndex","textareaEl","newClueProps","propToToggle","style","display","focus","handleKeyDown","toUpperCase","newValue","targetProp","applyClueChange","handleFocus","select","renderCluesContainer","clueList","className","createRef","data-key","onClick","data-ref-index","defaultValue","onKeyDown","onFocus","ref","useEffect","updateSemaphore","acrossClues","downClues","FillView","appContext","useContext","showSectionCandidates","setShowSectionCandidates","isWordListLoading","setIsWordListLoading","isFillRunning","setIsFillRunning","setFillStatus","newStatus","getManualEntryNode","isHover","insertEntryIntoGrid","getManualSectionNode","handleEntryCandidateClick","hoverGrid","handleEntryCandidateHover","handleSectionClick","handleSectionCheckClick","handleSectionHover","handleSectionCandidateClick","eraseSc","candidateKey","handleSectionCandidateHover","callback","delay","savedCallback","setInterval","clearInterval","useInterval","Complete","selectedSymmetry","symmetryOptions","t","isNaN","Number","fillStatusStr","status","Running","getFillStatusString","wordLists","isNoEntryCandidates","selectedScKey","sectionCandidates","selectedEntry","selectedMaxIffyLength","hidden","accept","onChange","file","files","setTimeout","processWordListData","name","then","checked","htmlFor","selectedIndex","getSymmetryTypeString","confirm","document","getElementById","click","gridTemplateColumns","cursor","onMouseOut","data-word","data-iffykey","onMouseOver","toFixed","data-id","getLongest","getLongestStackWord","data-candidate-key","between","input","Square","isSelected","isInSelectedWord","isInSelectedSection","constraintSum","data-row","data-col","NotAThing","getSquareElement","Grid","selectedSquare","setSelectedSquare","advanceCursor","selSq","isSquareSelected","selectedWordDir","newSelSq","setSelWordAtSelSquare","isSquareInSection","newSelSquare","getSquareProps","selectedWord","square","qualityClassMap","suppressEnterKey","preventDefault","el","range","createRange","selectNodeContents","sel","getSelection","removeAllRanges","addRange","selectElementContents","qc","curQc","generateQualityClassMap","squareElements","sqProps","columnTemplateStyle","contentEditable","suppressContentEditableWarning","onBlur","newTitle","innerText","onFocusCapture","newAuthor","newCopyright","newDirection","uncheckedSquareDir","getUncheckedSquareDir","letterChanged","blackSquareChanged","backupCursor","res","newSquareType","tabIndex","newNotes","processPuzData","Uint8Array","arrayBuffer","blobToText","restOfFile","curChar","getNextString","sortWordsForPuz","rebusSquareMappings","rebusValues","sectionType","dlI","Uint16Array","dataLength","secI","valuesStr","str","val","v","blob","cksum_region","bytes","startPos","len","cksum","insertString","pos","insertNumber","Menu","sizeRefs","handleViewChange","newView","role","data-view-id","openView","newWidth","newHeight","gridWidth","float","gridHeight","App","activeView","setActiveView","setGridWidth","setGridHeight","setUpdateSemaphore","getAppContext","appState","setAppState","initializeGlobals","solutionPos","areCircledSquares","char","gridPos","titlePos","authorPos","copyrightPos","orderedClues","cluesPos","oc","sectionSize","checksumPos","c_cib","squaresTotal","cluePos","c_sol","c_grid","c_part","finalArray","Blob","generatePuzFile","File","url","URL","createObjectURL","puzzleLink","setAttribute","isNewPuzzle","Provider","href","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.74270a7e.chunk.js","sourcesContent":["export enum SquareType {\r\n    White,\r\n    Black,\r\n    //Blank,\r\n}\r\n","export enum WordDirection {\r\n    Across,\r\n    Down,\r\n}\r\n","import React from \"react\";\r\nimport { Puzzle } from \"./models/Puzzle\";\r\n\r\nexport const AppContext = React.createContext({\r\n    triggerUpdate: () => {},\r\n    switchActiveView: (_: string) => {},\r\n    setPuzzle: (_: Puzzle) => {},\r\n    createNewPuzzle: (w: number, h: number) => {},\r\n    exportPuz: () => {},\r\n  });\r\n  ","import { GlobalsObj } from \"../models/GlobalsObj\";\r\n\r\ndeclare const window: any;\r\nwindow.Globals = {} as GlobalsObj;\r\nexport default window.Globals as GlobalsObj;\r\n","export enum SymmetryType {\r\n    None,\r\n    Rotate180,\r\n    Rotate90,\r\n    MirrorHorizontal,\r\n    MirrorVertical,\r\n    MirrorNWSE,\r\n    MirrorNESW,\r\n}\r\n","export enum ContentType {\r\n    User,\r\n    ChosenWord,\r\n    HoverChosenWord,\r\n    ChosenSection,\r\n    HoverChosenSection,\r\n    Autofill,\r\n}\r\n","export enum QualityClass {\r\n    NotAThing,\r\n    Iffy,\r\n    Crosswordese,\r\n    Normal,\r\n    Lively,\r\n}\r\n","import { IndexedWordList } from \"../models/IndexedWordList\";\r\nimport { QualityClass } from \"../models/QualityClass\";\r\nimport { WordList } from \"../models/WordList\";\r\nimport Globals from './windowService';\r\n\r\nexport async function processWordListData(filename: string, data: Blob): Promise<WordList | undefined> {\r\n    let lines = (await data.text()).split(\"\\n\");\r\n    let words = parseWordList(lines);\r\n    indexWordList(words, Globals.wordList);\r\n\r\n    return {\r\n        filename: filename,\r\n        wordCount: words.length,\r\n    } as WordList;\r\n}\r\n\r\nexport async function loadWordListFromLocalhost(url: string) {\r\n    var response = await fetch(url);\r\n    const lines = (await response.text()).split('\\n');\r\n    let words = parseWordList(lines);\r\n    indexWordList(words, Globals.wordList);\r\n    let filenameTokens = url.split(\"/\");\r\n    let filename = filenameTokens[filenameTokens.length - 1];\r\n\r\n    Globals.wordLists = [];\r\n    Globals.wordLists!.push({\r\n        filename: filename,\r\n        wordCount: words.length,\r\n    });\r\n\r\n    console.log(\"Word List loaded\");\r\n}\r\n\r\nfunction parseWordList(lines: string[]): string[] {\r\n    let qcMap = Globals.qualityClasses || new Map<string, QualityClass>();\r\n    let words = [] as string[];\r\n\r\n    lines.forEach(line => {\r\n        let tokens = line.trim().split(\";\");\r\n        if (tokens.length > 2) return;\r\n        if (!tokens[0].match(/^[A-Z]+$/)) return;\r\n\r\n        let score = tokens.length === 2 ? +tokens[1] : 50;\r\n        let qualityClass = score >= 100 ? QualityClass.Lively :\r\n                           score >= 50 ? QualityClass.Normal :\r\n                           QualityClass.Crosswordese;\r\n        let word = tokens[0];\r\n        if (word.length >= 2 && word.length <= 15) {\r\n            if (!qcMap.has(word)) words.push(word);\r\n            qcMap.set(word, qualityClass);\r\n        }\r\n    });\r\n\r\n    Globals.qualityClasses = qcMap;\r\n\r\n    return words;\r\n}\r\n\r\nexport function queryIndexedWordList(pattern: string): string[] {\r\n    let wl = Globals.wordList!;\r\n    let words = [] as string[];\r\n    if (pattern.length > 15) return words;\r\n    let letters = [] as [number, string][];\r\n    let length = pattern.length;\r\n    for (let i = 0; i < pattern.length; i++) {\r\n        if (pattern[i] !== \"-\") {\r\n            letters.push([i+1, pattern[i]]);\r\n        }\r\n    }\r\n\r\n    if (letters.length === 1) {\r\n        words = wl.buckets.oneVal[length-2][letters[0][0]-1][letters[0][1].charCodeAt(0)-65];\r\n    }\r\n    else if (letters.length === pattern.length) {\r\n        words = Globals.qualityClasses?.has(pattern) ? [pattern] : [];\r\n    }\r\n    else if (letters.length > 1) {\r\n        let pos1 = letters[0][0];\r\n        let pos2 = letters[1][0];\r\n        let val1 = letters[0][1];\r\n        let val2 = letters[1][1];\r\n        words = wl.buckets.twoVal[length-2][pos1-1][pos2-(pos1+1)][val1.charCodeAt(0)-65][val2.charCodeAt(0)-65];\r\n\r\n        for (let i = 2; i < letters.length; i++) {\r\n            words = words.filter(w => w[letters[i][0]-1] === letters[i][1]);\r\n        }\r\n    }\r\n\r\n    return words;\r\n}\r\n\r\nfunction indexWordList(entries: string[], existingList?: IndexedWordList) {\r\n    let buckets = existingList ? existingList.buckets : {\r\n        oneVal: [] as any[],\r\n        twoVal: [] as any[],\r\n    };\r\n\r\n    for (let length = 2; length <= 15; length++) {\r\n        buckets.oneVal.push([] as any[]);\r\n        for (let pos1 = 1; pos1 <= length; pos1++) {\r\n            buckets.oneVal[length-2].push([] as any[]);\r\n            for (let ch1 = 65; ch1 <= 90; ch1++) {\r\n                buckets.oneVal[length-2][pos1-1].push([] as string[]);\r\n            }\r\n        }\r\n    }\r\n\r\n    for (let length = 2; length <= 15; length++) {\r\n        buckets.twoVal.push([] as any[]);\r\n        for (let pos1 = 1; pos1 <= length-1; pos1++) {\r\n            buckets.twoVal[length-2].push([] as any[]);\r\n            for (let pos2 = pos1+1; pos2 <= length; pos2++) {\r\n                buckets.twoVal[length-2][pos1-1].push([] as any[]);\r\n                for (let ch1 = 65; ch1 <= 90; ch1++) {\r\n                    buckets.twoVal[length-2][pos1-1][pos2-(pos1+1)].push([] as any[]);\r\n                    for (let ch2 = 65; ch2 <= 90; ch2++) {\r\n                        buckets.twoVal[length-2][pos1-1][pos2-(pos1+1)][ch1-65].push([] as string[]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    entries.forEach(word => {\r\n        // 1-position entries\r\n        for (let pos1 = 1; pos1 <= word.length; pos1++) {\r\n            buckets.oneVal[word.length-2][pos1-1][word[pos1-1].charCodeAt(0)-65].push(word);\r\n        }\r\n\r\n        // 2-position entries\r\n        for (let pos1 = 1; pos1 < word.length; pos1++) {\r\n            for (let pos2 = pos1 + 1; pos2 <= word.length; pos2++) {\r\n                buckets.twoVal[word.length-2][pos1-1][pos2-(pos1+1)][word[pos1-1].charCodeAt(0)-65][word[pos2-1].charCodeAt(0)-65].push(word);\r\n            }\r\n        }\r\n    });\r\n\r\n    Globals.wordList = { buckets: buckets } as IndexedWordList;\r\n}\r\n","import { EntryCandidate } from \"../models/EntryCandidate\";\r\nimport { FillNode } from \"../models/FillNode\";\r\nimport { GridSquare } from \"../models/GridSquare\";\r\nimport { getAllCrosses, getEligibleCandidates, getWordScore } from \"./fill\";\r\nimport { getLettersFromSquares } from \"./grid\";\r\nimport { constraintLetterCount, deepClone, fullAlphabet, getSquaresForWord, getWordAtSquare, isUserFilled, \r\n    isWordFull, letterMatrixToLetterList, otherDir, squareKey, sum, wordKey, wordLength } from \"./util\";\r\nimport { queryIndexedWordList } from \"./wordList\";\r\nimport Globals from './windowService';\r\n\r\n// returns false if no viable candidates were found or iffy was set\r\nexport function populateAndScoreEntryCandidates(node: FillNode, isForManualFill: boolean): boolean {\r\n    if (isForManualFill && wordKey(node.fillWord!) === node.iffyWordKey) {\r\n        populateNoHeuristicEntryCandidates(node);\r\n        return true;\r\n    }\r\n\r\n    if (node.anchorSquareKeys.length === 0) {\r\n        let word = node.fillWord!;\r\n        let squares = getSquaresForWord(node.startGrid, word);\r\n        let anchorInfo = populateFillWordAnchors(squares);\r\n        node.anchorCombosLeft = anchorInfo.anchorCombosLeft;\r\n        node.anchorSquareKeys = anchorInfo.anchorSquareKeys;\r\n    }\r\n\r\n    let eligibleCandidates = [] as EntryCandidate[];\r\n    let heuristicsLevel = node.anchorCombosLeft.length > 100 ? 1 : node.anchorCombosLeft.length > 25 ? 2 : 3;\r\n\r\n    while(true) {\r\n        processAnchorCombo(node, isForManualFill, heuristicsLevel);\r\n        eligibleCandidates = getEligibleCandidates(node);\r\n        if (node.anchorCombosLeft.length === 0) break;\r\n        if (eligibleCandidates.filter(ec => !ec.iffyWordKey).length > (isForManualFill ? 100 : 0)) break;\r\n    }\r\n\r\n    node.entryCandidates.sort((a, b) => b.score! - a.score!);\r\n    return true;\r\n}\r\n\r\nexport function populateNoHeuristicEntryCandidates(node: FillNode) {\r\n    let word = node.fillWord!;\r\n    let squares = deepClone(getSquaresForWord(node.startGrid, word)) as GridSquare[];\r\n    squares.forEach(sq => {\r\n        if (!isUserFilled(sq)) sq.content = undefined;\r\n    });\r\n    let pattern = getLettersFromSquares(squares);\r\n    let entries = queryIndexedWordList(pattern).sort((a, b) => Globals.qualityClasses!.get(b)! - Globals.qualityClasses!.get(a)!);\r\n\r\n    node.entryCandidates = [];\r\n    entries.forEach(entry => {\r\n        node.entryCandidates.push({\r\n            word: entry,\r\n            score: getWordScore(entry),\r\n            isViable: true,\r\n            hasBeenChained: false,\r\n            wasChainFailure: false,\r\n            crossScore: 0,\r\n            minCrossScore: 0,\r\n        } as EntryCandidate);\r\n    });\r\n}\r\n\r\nfunction populateFillWordAnchors(squares: GridSquare[], calculatedSquares?: Map<string, string[]>):\r\n    { anchorSquareKeys: string[], anchorCombosLeft: [string, string][] } {\r\n    let anchorKeyCounts = [] as [string, number][];\r\n\r\n    squares.forEach(sq => {\r\n        let count = (calculatedSquares && calculatedSquares.has(squareKey(sq))) ? \r\n            calculatedSquares!.get(squareKey(sq))!.length : constraintLetterCount(sq);\r\n        if (count === 0) return; // don't anchor iffy\r\n\r\n        if (anchorKeyCounts.length < 2) {\r\n            anchorKeyCounts.push([squareKey(sq), count]);\r\n            anchorKeyCounts.sort((a, b) => a[1] - b[1]);\r\n            return;\r\n        }\r\n\r\n        if (count < anchorKeyCounts[1][1]) {\r\n            anchorKeyCounts[1] = [squareKey(sq), count];\r\n            anchorKeyCounts.sort((a, b) => a[1] - b[1]);\r\n        }\r\n    });\r\n\r\n    if (anchorKeyCounts.length < 2) {\r\n        return {\r\n            anchorSquareKeys: [],\r\n            anchorCombosLeft: [],\r\n        };\r\n    }\r\n\r\n    let anchorSquareKeys = [anchorKeyCounts[0][0], anchorKeyCounts[1][0]];\r\n    let combos = generateAnchorCombos(squares, anchorSquareKeys, calculatedSquares);\r\n\r\n    return {\r\n        anchorSquareKeys: anchorSquareKeys,\r\n        anchorCombosLeft: combos,\r\n    };\r\n}\r\n\r\nconst letterFrequencies = {\r\n    \"A\": 8.2, \"B\": 1.5, \"C\": 2.8, \"D\": 4.3,\r\n    \"E\": 13, \"F\": 2.2, \"G\": 2, \"H\": 6.1,\r\n    \"I\": 7, \"J\": 0.15, \"K\": 0.77, \"L\": 4,\r\n    \"M\": 2.4, \"N\": 6.7, \"O\": 7.5, \"P\": 1.9,\r\n    \"Q\": 0.095, \"R\": 6, \"S\": 6.3, \"T\": 9.1,\r\n    \"U\": 2.8, \"V\": 0.98, \"W\": 2.4, \"X\": 0.15,\r\n    \"Y\": 2, \"Z\": 0.074,\r\n} as any;\r\n\r\nfunction generateAnchorCombos(squares: GridSquare[], anchorSquareKeys: string[], \r\n    calculatedSquares?: Map<string, string[]>): [string, string][] {\r\n    let constraintLetters = anchorSquareKeys\r\n        .map(sqKey => squares.find(sq => squareKey(sq) === sqKey)!)\r\n        .map(sq => (calculatedSquares && calculatedSquares.has(squareKey(sq))) ? \r\n        calculatedSquares!.get(squareKey(sq))! : sq.viableLetters || fullAlphabet);\r\n\r\n    let combos = [] as [string, string][];\r\n    let comboScores = new Map<string, number>();\r\n    for (var letter1 of constraintLetters[0]) {\r\n        for (var letter2 of constraintLetters[1]) {\r\n            combos.push([letter1, letter2]);\r\n            comboScores.set(`[${letter1},${letter2}]`, letterFrequencies[letter1] * letterFrequencies[letter2] * Math.random());\r\n        }\r\n    }\r\n\r\n    combos.sort((a, b) => {\r\n        return comboScores.get(`[${a[0]},${a[1]}]`)! - comboScores.get(`[${b[0]},${b[1]}]`)!;\r\n    });\r\n\r\n    return combos;\r\n}\r\n\r\nfunction processAnchorCombo(node: FillNode, isForManualFill: boolean, heuristicsLevel: number) {\r\n    let grid = node.startGrid;\r\n    let combo = node.anchorCombosLeft.pop()!;\r\n\r\n    let fillWordKey = wordKey(node.fillWord!);\r\n    let wordSquares = getSquaresForWord(grid, node.fillWord!);\r\n    let patternWithAnchor = getLettersFromSquares(wordSquares);\r\n    node.anchorSquareKeys.forEach((sqKey, i) => {\r\n        patternWithAnchor = insertLetterIntoPattern(patternWithAnchor, combo[i], wordSquares, sqKey);\r\n    });\r\n    if (isForManualFill && isWordFull(wordSquares)) {\r\n        node.entryCandidates.push({\r\n            word: patternWithAnchor,\r\n            score: 1,\r\n            isViable: true,\r\n            hasBeenChained: false,\r\n            wasChainFailure: false,\r\n            crossScore: 0,\r\n            minCrossScore: 0,\r\n        } as EntryCandidate);\r\n        return;\r\n    }\r\n\r\n    let crossKeys = new Map<string, boolean>();\r\n    let crossCrossKeys = new Map<string, boolean>();\r\n    getAllCrosses(grid, node.fillWord!).forEach(cross => {\r\n        crossKeys.set(wordKey(cross), true);\r\n        getAllCrosses(grid, cross).forEach(crossCross => {\r\n            crossCrossKeys.set(wordKey(crossCross), true);\r\n        });\r\n    });\r\n\r\n    if (wordSquares.length < 6 || (wordSquares.length < 7 && crossKeys.size + crossCrossKeys.size <= 15))\r\n        heuristicsLevel = 3;\r\n    if (heuristicsLevel === 3 && wordSquares.length > 8 && crossKeys.size + crossCrossKeys.size > 20)\r\n        heuristicsLevel = 2;\r\n\r\n    let iffyWordKey = isForManualFill ? Globals.manualIffyKey : node.iffyWordKey;\r\n    if (iffyWordKey) {\r\n        wordSquares.forEach(sq => {\r\n            let cross = getWordAtSquare(grid, sq.row, sq.col, otherDir(node.fillWord!.direction))!;\r\n            if (wordKey(cross) === iffyWordKey) {\r\n                let crossSquares = getSquaresForWord(grid, cross);\r\n                crossSquares.forEach(csq => {\r\n                    if (!csq.content)\r\n                        csq.viableLetters = deepClone(fullAlphabet);\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    let entries = getFilteredEntries(wordSquares, patternWithAnchor, undefined, grid.usedWords);\r\n\r\n    entries.forEach(entry => {\r\n        let success = processEntry(entry, iffyWordKey);\r\n\r\n        if (!success && !node.iffyWordKey && heuristicsLevel === 3 && Globals.maxIffyLength! > 0) {\r\n            crossKeys.forEach((_, ck) => {\r\n                let cross = grid.words.get(ck)!;\r\n                if (wordLength(cross) > Globals.maxIffyLength!) return;\r\n                processEntry(entry, ck);\r\n            });\r\n        }\r\n    });\r\n\r\n    node.entryCandidates.forEach(ec => {\r\n        if(ec.score === -1) {\r\n            ec.score = calculateEntryCandidateScore(node, ec);\r\n        }\r\n    });\r\n\r\n    function processEntry(entry: string, iffyWordKey?: string): boolean {\r\n        let isViable = true;\r\n        let distillIndex = 1;\r\n        let calculatedSquares = new Map<string, string[]>();\r\n        let crossScore = 0;\r\n        let minCrossScore = 1e8;\r\n        let usedWords = deepClone(grid.usedWords) as Map<string, boolean>;\r\n        usedWords.set(entry, true);\r\n\r\n        wordSquares.forEach((sq, i) => {\r\n            let sqKey = squareKey(sq);\r\n            calculatedSquares.set(sqKey, [entry[i]]);\r\n\r\n            let cross = getWordAtSquare(grid, sq.row, sq.col, otherDir(node.fillWord!.direction))!;\r\n            if (!cross) {\r\n                calculatedSquares.set(sqKey, deepClone(fullAlphabet));\r\n                return;\r\n            }\r\n\r\n            let crossSquares = getSquaresForWord(grid, cross);\r\n            let pattern = getLettersFromSquares(crossSquares);\r\n            insertLetterIntoPattern(pattern, entry[i], crossSquares, sqKey);\r\n            if (!pattern.includes(\"-\"))\r\n                usedWords.set(pattern, true);\r\n\r\n            if (wordKey(cross) === iffyWordKey) {\r\n                crossSquares.forEach(csq => {\r\n                    if (!csq.content)\r\n                        csq.viableLetters = deepClone(fullAlphabet);\r\n                });\r\n            }\r\n        });\r\n\r\n        while(true) {\r\n            let wordKeys = distillIndex % 2 === 1  ? crossKeys : crossCrossKeys;\r\n            let foundCountReduction = false;\r\n    \r\n            // eslint-disable-next-line\r\n            wordKeys.forEach((_, wKey) => {\r\n                if (!isViable) return;\r\n                if (wKey === fillWordKey) return;\r\n                if (wKey === iffyWordKey) return;\r\n\r\n                let word = grid.words.get(wKey)!;\r\n                let squares = getSquaresForWord(grid, word);\r\n                if (isWordFull(squares)) return;\r\n                if (distillIndex === 1 && squares.filter(sq => !calculatedSquares.has(squareKey(sq)) && \r\n                    (!sq.viableLetters || sq.viableLetters.length < 20)).length === 0) return;\r\n                let wordPattern = getLettersFromSquares(squares);\r\n                let filteredEntries = [] as string[];\r\n                let anchorInfo = populateFillWordAnchors(squares, calculatedSquares);\r\n                let anchorComboCount = anchorInfo.anchorCombosLeft.length;\r\n                if (distillIndex > 1 && anchorComboCount > 20) return;\r\n\r\n                anchorInfo.anchorCombosLeft.forEach(combo => {\r\n                    let newPattern = wordPattern;\r\n                    anchorInfo.anchorSquareKeys.forEach((sqKey, i) => {\r\n                        newPattern = insertLetterIntoPattern(newPattern, combo[i], squares, sqKey);\r\n                    });\r\n                    filteredEntries.push(...getFilteredEntries(squares, newPattern, calculatedSquares, usedWords));\r\n                });\r\n    \r\n                if (filteredEntries.length === 0) {\r\n                    isViable = false;\r\n                    return;\r\n                }\r\n\r\n                if (distillIndex === 1) {\r\n                    let score = sum(filteredEntries.map(fe => getWordScore(fe)));\r\n                    crossScore += score;\r\n                    if (score < minCrossScore) minCrossScore = score;\r\n                }\r\n\r\n                if (heuristicsLevel === 1) return;\r\n                if (distillIndex === 2 && heuristicsLevel === 2) return;\r\n    \r\n                squares.forEach((sq, i) => {\r\n                    let newMatrix = Array<boolean>(26).fill(false);\r\n                    filteredEntries.forEach(entry => {\r\n                        newMatrix[entry[i].charCodeAt(0) - 65] = true;\r\n                    });\r\n                    let letters = letterMatrixToLetterList(newMatrix);\r\n\r\n                    let existingCounts = calculatedSquares.get(squareKey(sq))!;\r\n                    if (!existingCounts || existingCounts.length > letters.length)\r\n                        foundCountReduction = true;\r\n\r\n                    calculatedSquares.set(squareKey(sq), letters);\r\n                });\r\n            });\r\n\r\n            if (distillIndex === 3) break;\r\n            if (!foundCountReduction) break;\r\n            if (!isViable) break;\r\n            if (distillIndex > 0 && heuristicsLevel === 1) break;\r\n            if (distillIndex === 2 && heuristicsLevel === 2) break;\r\n\r\n            distillIndex++;\r\n        }\r\n\r\n        if (!isViable) return false;\r\n\r\n        if (crossScore > node.topCrossScore) node.topCrossScore = crossScore;\r\n        if (minCrossScore > node.topMinCrossScore) node.topMinCrossScore = minCrossScore;\r\n\r\n        let iffyEntry = undefined as string | undefined;\r\n        if (iffyWordKey) {\r\n            let iffyWord = grid.words.get(iffyWordKey)!;\r\n            let iffySquares = getSquaresForWord(grid, iffyWord);\r\n            let pattern = getLettersFromSquares(iffySquares);\r\n            iffySquares.forEach((isq, idx) => {\r\n                let calSq = calculatedSquares.get(squareKey(isq));\r\n                if (!isq.content && calSq && calSq.length === 1)\r\n                    pattern = pattern.substring(0, idx) + calSq[0] + pattern.substring(idx+1);\r\n            });\r\n            iffyEntry = pattern;\r\n        }\r\n\r\n        if (iffyEntry && usedWords.has(iffyEntry)) return false;\r\n\r\n        node.entryCandidates.push({\r\n            word: entry,\r\n            score: -1,\r\n            isViable: isViable,\r\n            hasBeenChained: false,\r\n            wasChainFailure: false,\r\n            iffyEntry: iffyEntry,\r\n            iffyWordKey: iffyWordKey,\r\n            crossScore: crossScore,\r\n            minCrossScore: minCrossScore,\r\n        } as EntryCandidate);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\nfunction getFilteredEntries(squares: GridSquare[], anchorPattern: string, calculatedSquares?: Map<string, string[]>,\r\n    usedWords?: Map<string, boolean>): string[] {\r\n    let entries = [] as string[];\r\n    broadenAnchorPatterns(squares, anchorPattern, calculatedSquares).forEach(pattern => {\r\n        entries.push(...queryIndexedWordList(pattern));\r\n    });\r\n\r\n    let filteredEntries = entries.filter(entry => {\r\n        if (usedWords && usedWords.has(entry)) return false;\r\n\r\n        for (let i = 0; i < squares.length; i++) {\r\n            let sq = squares[i];\r\n            let sqKey = squareKey(sq);\r\n            \r\n            if (calculatedSquares && calculatedSquares.has(sqKey) && !calculatedSquares.get(sqKey)!.includes(entry[i])) {\r\n                return false;\r\n            }\r\n            else if (sq.viableLetters && !sq.viableLetters.includes(entry[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        \r\n        return true;\r\n    });\r\n\r\n    return filteredEntries;\r\n}\r\n\r\nfunction broadenAnchorPatterns(squares: GridSquare[], anchorPattern: string, calculatedSquares?: Map<string, string[]>): string[] {\r\n    let constraintCounts = squares.map((sq, i) => {\r\n        if (anchorPattern[i] !== \"-\") return [i, [anchorPattern[i]]] as [number, string[]];\r\n        if (calculatedSquares && calculatedSquares.has(squareKey(sq))) {\r\n            return [i, calculatedSquares.get(squareKey(sq))!] as [number, string[]];\r\n        }\r\n        return [i, sq.viableLetters || fullAlphabet] as [number, string[]];\r\n    })\r\n    .filter(x => x[1].length > 0).sort((a, b) => b[1].length - a[1].length);\r\n\r\n    let curPatterns = [anchorPattern];\r\n    while(constraintCounts.length > 0 && curPatterns.length < 12) {\r\n        let lowestCount = constraintCounts.pop()!;\r\n        if (lowestCount[1].length >= 6) \r\n            return curPatterns;\r\n\r\n        let index = lowestCount[0];\r\n        let viableLetters = lowestCount[1];\r\n        let newCurPatterns = [] as string[];\r\n        // eslint-disable-next-line\r\n        viableLetters.forEach(ltr => {\r\n            curPatterns.forEach(pattern => {\r\n                newCurPatterns.push(pattern.substring(0, index) + ltr + pattern.substring(index+1));\r\n            });\r\n        });\r\n        curPatterns = newCurPatterns;\r\n    }\r\n\r\n    return curPatterns;\r\n}\r\n\r\nfunction calculateEntryCandidateScore(node: FillNode, ec: EntryCandidate): number {\r\n    let wordScore = getWordScore(ec.word);\r\n    let crossScore = node.topCrossScore > 0 ? ec.crossScore / node.topCrossScore : 1;\r\n    let minCrossScore = node.topMinCrossScore > 0 ? ec.minCrossScore / node.topMinCrossScore : 1;\r\n    let ret = (crossScore + minCrossScore) * wordScore * (ec.iffyWordKey ? 1 : 10);\r\n    return ret;\r\n}\r\n\r\nfunction insertLetterIntoPattern(pattern: string, newLetter: string, squares: GridSquare[], sqKey: string): string {\r\n    let i = squares.findIndex(sq => squareKey(sq) === sqKey);\r\n    return pattern.substring(0, i) + newLetter + pattern.substring(i+1);\r\n}\r\n","import { GridSquare } from \"../models/GridSquare\";\r\nimport { GridState } from \"../models/GridState\";\r\nimport { GridWord } from \"../models/GridWord\";\r\nimport { SquareType } from \"../models/SquareType\";\r\nimport { WordDirection } from \"../models/WordDirection\";\r\nimport Globals from './windowService';\r\nimport { Puzzle } from \"../models/Puzzle\";\r\nimport { getLettersFromSquares } from \"./grid\";\r\nimport { ContentType } from \"../models/ContentType\";\r\nimport { Section } from \"../models/Section\";\r\nimport { SectionCandidate } from \"../models/SectionCandidate\";\r\nimport { generateGridSections } from \"./section\";\r\n\r\nexport const fullAlphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".split(\"\");\r\n\r\nexport function average(arr: number[]): number {\r\n    return arr.reduce((a,b) => a + b, 0) / arr.length;\r\n}\r\n\r\nexport function sum(arr: number[]): number {\r\n    return arr.reduce((a,b) => a + b, 0);\r\n}\r\n\r\n// https://stackoverflow.com/questions/38416020/deep-copy-in-es6-using-the-spread-syntax\r\nexport function deepClone(obj: any): any {\r\n    if(typeof obj !== 'object' || obj === null) {\r\n        return obj;\r\n    }\r\n\r\n    if(obj instanceof Date) {\r\n        return new Date(obj.getTime());\r\n    }\r\n\r\n    if(obj instanceof Map) {\r\n        return new Map(Array.from(obj.entries()));\r\n    }\r\n\r\n    if(obj instanceof Array) {\r\n        return obj.reduce((arr, item, i) => {\r\n            arr[i] = deepClone(item);\r\n            return arr;\r\n        }, []);\r\n    }\r\n\r\n    if(obj instanceof Object) {\r\n        return Object.keys(obj).reduce((newObj: any, key) => {\r\n            newObj[key] = deepClone(obj[key]);\r\n            return newObj;\r\n        }, {})\r\n    }\r\n}\r\n\r\nexport function compareTuples(first: [number, number], second: [number, number]): boolean {\r\n    return first[0] === second[0] && first[1] === second[1];\r\n}\r\n\r\nexport function isBlackSquare(sq: GridSquare): boolean {\r\n    return sq.type === SquareType.Black;\r\n}\r\n\r\nexport function otherDir(dir: WordDirection): WordDirection {\r\n    return dir === WordDirection.Across ? WordDirection.Down : WordDirection.Across;\r\n}\r\n\r\nexport function getSquaresForWord(grid: GridState, word: GridWord): GridSquare[] {\r\n    let row = word.start[0];\r\n    let col = word.start[1];\r\n    let squares = [grid.squares[row][col]];\r\n    while (!compareTuples([row, col], word.end)) {\r\n        row = word.direction === WordDirection.Across ? row : row+1;\r\n        col = word.direction === WordDirection.Across ? col+1 : col;\r\n        squares.push(grid.squares[row][col]);\r\n    }\r\n\r\n    return squares;\r\n}\r\n\r\nexport function getWordAtSquare(grid: GridState, row: number, col: number, dir: WordDirection): GridWord | undefined {\r\n    let ret = undefined as GridWord | undefined;\r\n\r\n    grid.words.forEach((word, _) => {\r\n        if (dir === WordDirection.Across && word.direction === dir && word.start[0] === row &&\r\n            word.start[1] <= col && word.end[1] >= col)\r\n            ret = word;\r\n        if (dir === WordDirection.Down && word.direction === dir && word.start[1] === col &&\r\n            word.start[0] <= row && word.end[0] >= row)\r\n            ret = word;\r\n    });\r\n\r\n    return ret;\r\n}\r\n\r\nexport function newWord(): GridWord {\r\n    return {\r\n        number: undefined,\r\n        direction: WordDirection.Across,\r\n        start: [-1, -1],\r\n        end: [-1, -1],\r\n    }\r\n}\r\n\r\nexport function doesWordContainSquare(word: GridWord, row: number, col: number): boolean {\r\n    if (word.direction === WordDirection.Across) {\r\n        return word.start[0] === row && word.start[1] <= col && word.end[1] >= col;\r\n    }\r\n    else {\r\n        return word.start[1] === col && word.start[0] <= row && word.end[0] >= row;\r\n    }\r\n}\r\n\r\nexport function isWordEmpty(squares: GridSquare[]): boolean {\r\n    return !squares.find(x => !isBlackSquare(x) && x.content);\r\n}\r\n\r\nexport function isWordFull(squares: GridSquare[]): boolean {\r\n    return !squares.find(x => !isBlackSquare(x) && !x.content);\r\n}\r\n\r\nexport function shuffleArray(array: any[]) {\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1));\r\n        [array[i], array[j]] = [array[j], array[i]];\r\n    }\r\n}\r\n\r\nexport function forAllGridSquares(grid: GridState, func: (sq: GridSquare) => void) {\r\n    grid.squares.forEach(row => {\r\n        row.forEach(sq => {\r\n            func(sq);\r\n        });\r\n    });\r\n}\r\n\r\nexport function wordLength(word: GridWord): number {\r\n    if (word.direction === WordDirection.Across)\r\n        return word.end[1] - word.start[1] + 1;\r\n    else\r\n        return word.end[0] - word.start[0] + 1;\r\n}\r\n\r\nexport function newPuzzle(): Puzzle {\r\n    return {\r\n        title: \"\",\r\n        author: \"\",\r\n        copyright: \"\",\r\n        clues: new Map<string, string>(),\r\n        notes: \"\",\r\n    } as Puzzle;    \r\n}\r\n\r\nexport function wordKey(word: GridWord): string {\r\n    return `[${word.start[0]},${word.start[1]},${word.direction === WordDirection.Across ? \"A\" : \"D\"}]`;\r\n}\r\n\r\nexport function squareKey(sq: GridSquare | undefined): string {\r\n    return sq ? `[${sq.row},${sq.col}]` : \"\";\r\n}\r\n\r\nexport function getGrid(): GridState {\r\n    return Globals.activeGrid!;\r\n}\r\n\r\nexport function getSection(): Section {\r\n    return Globals.sections!.get(Globals.activeSectionId!)!;\r\n}\r\n\r\nexport function getSelectedWord(): GridWord | undefined {\r\n    let grid = getGrid();\r\n    if (!Globals.selectedWordKey) return undefined;\r\n    return grid.words.get(Globals.selectedWordKey);\r\n}\r\n\r\nexport function mapKeys<TKey, TVal>(map: Map<TKey, TVal>): TKey[] {\r\n    return Array.from(map.keys()) || [];\r\n}\r\n\r\nexport function mapValues<TKey, TVal>(map: Map<TKey, TVal>): TVal[] {\r\n    return Array.from(map.values()) || [];\r\n}\r\n\r\nexport function isUserFilled(sq: GridSquare): boolean {\r\n    return sq.contentType === ContentType.User || sq.contentType === ContentType.ChosenWord \r\n        || sq.contentType === ContentType.ChosenSection;\r\n}\r\n\r\nexport function isUserOrWordFilled(sq: GridSquare): boolean {\r\n    return sq.contentType === ContentType.User || sq.contentType === ContentType.ChosenWord;\r\n}\r\n\r\nexport function isAcross(word: GridWord): boolean {\r\n    return word.direction === WordDirection.Across;\r\n}\r\n\r\nexport function getSquareAtKey(grid: GridState, squareKey: string): GridSquare {\r\n    let tokens = squareKey.substring(1, squareKey.length - 1).split(\",\");\r\n    return grid.squares[+tokens[0]][+tokens[1]];\r\n}\r\n\r\nexport function isPartOfIffyWord(sq: GridSquare): boolean {\r\n    if (!sq.viableLetters) return false;\r\n    return sq.viableLetters.length === 0;\r\n}\r\n\r\n// https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\r\nexport function shuffle(array: any[]) {\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1));\r\n        [array[i], array[j]] = [array[j], array[i]];\r\n    }\r\n}\r\n\r\nexport function getEntryAtWordKey(grid: GridState, wordKey: string): string {\r\n    return getLettersFromSquares(getSquaresForWord(grid, grid.words.get(wordKey)!));\r\n}\r\n\r\nexport function getSectionCandidatesFromKeys(keys: string[]): SectionCandidate[] {\r\n    return keys\r\n        .map(sck => mapValues(Globals.sections!).find(sec => sec.candidates.has(sck))?.candidates.get(sck))\r\n        .filter(sck => sck !== undefined)\r\n        .map(sck => sck!);\r\n}\r\n\r\nexport function constraintLetterCount(sq: GridSquare): number {\r\n    if (!sq.viableLetters) return 26;\r\n\r\n    return sq.viableLetters.length;\r\n}\r\n\r\nexport function isPatternFull(pattern: string): boolean {\r\n    return !pattern.includes(\"-\");\r\n}\r\n\r\nexport function getUserFilledSections(grid: GridState): Section[] {\r\n    let sectionCandidates = getSectionCandidatesFromKeys(mapKeys(grid.userFilledSectionCandidates));\r\n    return sectionCandidates.map(sc => Globals.sections!.get(sc.sectionId)!);\r\n}\r\n\r\nexport function getUserFilledSectionCandidates(grid: GridState): SectionCandidate[] {\r\n    return getSectionCandidatesFromKeys(mapKeys(grid.userFilledSectionCandidates));\r\n}\r\n\r\nexport function initializeSessionGlobals() {\r\n    let grid = getGrid();\r\n    Globals.sections = generateGridSections(grid);\r\n    Globals.activeSectionId = 0;\r\n    Globals.hoverSectionId = undefined;\r\n    Globals.selectedSectionIds = new Map<number, boolean>();\r\n    Globals.selectedSectionIds.set(0, true);\r\n    Globals.selectedSectionCandidateKeys = new Map<number, string>();\r\n}\r\n\r\nexport function letterMatrixToLetterList(matrix: boolean[]): string[] {\r\n    return matrix.map((x, i) => x ? String.fromCharCode(i + 65) : \"\").filter(x => x);\r\n}\r\n\r\nexport function letterListToLetterMatrix(list: string[]): boolean[] {\r\n    let matrix = Array<boolean>(26).fill(false);\r\n    list.forEach(ltr => {\r\n        matrix[ltr.charCodeAt(0)] = true;\r\n    });\r\n    return matrix;\r\n}\r\n","import { ContentType } from \"../models/ContentType\";\r\nimport { FillNode } from \"../models/FillNode\";\r\nimport { GridSquare } from \"../models/GridSquare\";\r\nimport { GridState } from \"../models/GridState\";\r\nimport { GridWord } from \"../models/GridWord\";\r\nimport { Section } from \"../models/Section\";\r\nimport { SectionCandidate } from \"../models/SectionCandidate\";\r\nimport { WordDirection } from \"../models/WordDirection\";\r\nimport { getAllCrosses, getWordScore } from \"./fill\";\r\nimport { generateConstraintInfoForSquares, getLettersFromSquares } from \"./grid\";\r\nimport { forAllGridSquares, getEntryAtWordKey, getGrid, getSquaresForWord, getWordAtSquare, getSquareAtKey, isAcross, \r\n    isBlackSquare, mapKeys, squareKey, wordKey, wordLength, mapValues, isUserOrWordFilled, deepClone } from \"./util\";\r\nimport Globals from './windowService';\r\n\r\nexport function updateSectionFilters() {\r\n    let sections = Globals.sections!;\r\n    let grid = getGrid();\r\n    sections.forEach(sec => {\r\n        sec.candidates.forEach((can, _) => {\r\n            let sqKeys = mapKeys(sec.squares);\r\n            can.isFilteredOut = false;\r\n            for (let sqKey of sqKeys) {\r\n                let gridSq = getSquareAtKey(grid, sqKey);\r\n                let canSq = getSquareAtKey(can.grid, sqKey);\r\n                if (isUserOrWordFilled(gridSq) && canSq.content !== gridSq.content)\r\n                    can.isFilteredOut = true;\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\nexport function getSectionString(grid: GridState, section: Section): string {\r\n    let ret = [] as string[];\r\n    mapKeys(section.squares).sort().forEach(sqKey => {\r\n        let sq = getSquareAtKey(grid, sqKey);\r\n        let content = sq.content;\r\n        ret.push(content ? content! : \"-\");\r\n    });\r\n    return ret.join(\"\");\r\n}\r\n\r\n// returns whether it was a success\r\nexport function insertSectionCandidateIntoGrid(grid: GridState, candidate: SectionCandidate, contentType?: ContentType): boolean {\r\n    if (contentType === undefined) contentType = ContentType.ChosenSection;\r\n    let newGrid = deepClone(grid) as GridState;\r\n    let section = Globals.sections!.get(candidate.sectionId)!;\r\n    let foundDiscrepancy = false;\r\n    section.squares.forEach((_, sqKey) => {\r\n        let sq = getSquareAtKey(newGrid, sqKey);\r\n        let candidateSq = getSquareAtKey(candidate.grid, sqKey);\r\n        if (isUserOrWordFilled(sq) && sq.content! !== candidateSq.content!)\r\n            foundDiscrepancy = true;\r\n        sq.content = candidateSq.content;\r\n        sq.viableLetters = [sq.content!];\r\n        if (!isUserOrWordFilled(sq)) {\r\n            sq.contentType = [ContentType.HoverChosenSection, ContentType.Autofill].includes(contentType!) ? \r\n                ContentType.Autofill : ContentType.ChosenSection;\r\n        }\r\n    });\r\n    if (foundDiscrepancy) return false;\r\n    else {\r\n        forAllGridSquares(newGrid, newSq => {\r\n            grid.squares[newSq.row][newSq.col] = newSq;\r\n        });\r\n    }\r\n\r\n    section.words.forEach((_, key) => {\r\n        let word = grid.words.get(key)!;\r\n        let squares = getSquaresForWord(grid, word);\r\n        grid.usedWords.set(getLettersFromSquares(squares), true);\r\n    });\r\n\r\n    section.neighboringCrosses.forEach((_, key) => {\r\n        let word = grid.words.get(key)!;\r\n        let squares = getSquaresForWord(grid, word);\r\n        generateConstraintInfoForSquares(squares);\r\n    });\r\n\r\n    grid.userFilledSectionCandidates.set(sectionCandidateKey(section, grid), true);\r\n    return true;\r\n}\r\n\r\nexport function generateGridSections(grid: GridState): Map<number, Section> {\r\n    function iterateSection(section: Section, grid: GridState, sq: GridSquare, usedSquares: Map<string, boolean>) {\r\n        section.openSquareCount++;\r\n        usedSquares.set(squareKey(sq), true);\r\n\r\n        getNeighboringSquares(grid, sq).forEach(neighbor => {\r\n            if (!usedSquares.has(squareKey(neighbor)) && isOpenSquare(grid, neighbor)) {\r\n                iterateSection(section, grid, neighbor, usedSquares);\r\n            }\r\n\r\n            [WordDirection.Across, WordDirection.Down].forEach(dir => {\r\n                let word = getWordAtSquare(grid, neighbor.row, neighbor.col, dir)!;\r\n                if (word !== undefined && !section.words.has(wordKey(word))) {\r\n                    section.words.set(wordKey(word), true);\r\n                    let squares = getSquaresForWord(grid, word);\r\n                    squares.forEach(wsq => {\r\n                        section.squares.set(squareKey(wsq), true);\r\n                    });\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    let sections = new Map<number, Section>();\r\n    let usedSquares = new Map<string, boolean>();\r\n    let nextSectionId = 1;\r\n\r\n    // add full grid section\r\n    let fullSection = makeNewSection(0);\r\n    forAllGridSquares(grid, sq => {\r\n        if (!isBlackSquare(sq)) fullSection.squares.set(squareKey(sq), true);\r\n    });\r\n    grid.words.forEach(w => {\r\n        fullSection.words.set(wordKey(w), true);\r\n    });\r\n    sections.set(0, fullSection);\r\n\r\n    // populate sections\r\n    forAllGridSquares(grid, sq => {\r\n        if (!usedSquares.has(squareKey(sq)) && isOpenSquare(grid, sq)) {\r\n            let newSection = makeNewSection(nextSectionId);\r\n            iterateSection(newSection, grid, sq, usedSquares);\r\n            if (newSection.openSquareCount === 1) return;\r\n            sections.set(newSection.id, newSection);\r\n            nextSectionId++;\r\n        }\r\n    });\r\n    if (sections.size === 2) sections.delete(1);\r\n\r\n    // populate stackWords\r\n    sections.forEach(section => {\r\n        section.stackWords = new Map<string, boolean>();\r\n\r\n        section.words.forEach((_, key) => {\r\n            if (section.stackWords.has(key)) return;\r\n\r\n            let word = grid.words.get(key)!;\r\n            let stackedNeighbors = mapKeys(section.words).filter(otherKey => {\r\n                if (otherKey === key) return false;\r\n\r\n                let otherWord = grid.words.get(otherKey)!;\r\n                if (isAcross(word) && isAcross(otherWord) && Math.abs(word.start[0] - otherWord.start[0]) === 1) {\r\n                    let intersectionCount = Math.min(word.end[1], otherWord.end[1]) - Math.max(word.start[1], otherWord.start[1]) + 1;\r\n                    return intersectionCount >= 5;\r\n                }\r\n                if (!isAcross(word) && !isAcross(otherWord) && Math.abs(word.start[1] - otherWord.start[1]) === 1) {\r\n                    let intersectionCount = Math.min(word.end[0], otherWord.end[0]) - Math.max(word.start[0], otherWord.start[0]) + 1;\r\n                    return intersectionCount >= 5;\r\n                }\r\n                return false;\r\n            }); \r\n\r\n            if (stackedNeighbors.length > 0) {\r\n                section.stackWords.set(key, true);\r\n                stackedNeighbors.forEach(sk => {\r\n                    section.stackWords.set(sk, true);\r\n                });\r\n            }\r\n        });\r\n    });\r\n\r\n    // populate neighboringCrosses\r\n    sections.forEach(section => {\r\n        section.words.forEach((_, key) => {\r\n            let word = grid.words.get(key)!;\r\n            let crosses = getAllCrosses(grid, word);\r\n            crosses.forEach(cross => {\r\n                let crossKey = wordKey(cross);\r\n                if (!section.words.has(crossKey))\r\n                    section.neighboringCrosses.set(crossKey, true);\r\n            });\r\n        });\r\n    });\r\n\r\n    // calculate word order\r\n    sections.forEach(section => {\r\n        if (section.id === 0) {\r\n            let wordOrder = [] as string[];\r\n            let usedWords = new Map<string, boolean>();\r\n            let orderedSections = calculateSectionOrder(mapValues(sections));\r\n            orderedSections.forEach(id => {\r\n                if (id === 0 && sections.size > 1) return;\r\n                let secOrder = calculateWordOrder(grid, sections.get(id)!);\r\n                wordOrder.push(...secOrder.filter(wk => !usedWords.has(wk)));\r\n                secOrder.forEach(wk => {usedWords.set(wk, true);});\r\n            });\r\n            mapKeys(section.words).filter(wKey => !usedWords.has(wKey)).forEach(wk => {\r\n                wordOrder.push(wk);\r\n            });\r\n            section.wordOrder = wordOrder;\r\n            return;\r\n        }\r\n\r\n        section.wordOrder = calculateWordOrder(grid, section);\r\n    });\r\n\r\n    // calculate connections\r\n    sections.forEach(section => {\r\n        sections.forEach((sec, id) => {\r\n            if (id === section.id) return;\r\n            if (mapKeys(sec.words).find(wk => section.words.has(wk)))\r\n                section.connections.set(id, true);\r\n        });\r\n    });\r\n\r\n    return sections;\r\n}\r\n\r\nexport function calculateSectionOrder(sections: Section[]): number[] {\r\n    return sections.sort((a, b) => {\r\n        if (a.id === 0) return -1;\r\n        if (b.id === 0) return 1;\r\n        if (a.connections.size !== b.connections.size) return b.connections.size - a.connections.size;\r\n        return b.squares.size - a.squares.size;\r\n    }).map(sec => sec.id);\r\n}\r\n\r\nfunction calculateWordOrder(grid: GridState, section: Section): string[] {\r\n    function wordsSort(a: GridWord, b: GridWord): number {\r\n        if (wordLength(a) !== wordLength(b)) return wordLength(b) - wordLength(a);\r\n        return a.direction === WordDirection.Across ? a.start[0] - b.start[0] : a.start[1] - b.start[1];\r\n    }\r\n\r\n    function iterateWordGroup(group: GridWord[]) {\r\n        if (group.length === 0) return;\r\n        if (group.length === 1) {\r\n            wordOrder.push(wordKey(group[0]));\r\n            usedWords.set(wordKey(group[0]), true);\r\n            return;\r\n        }\r\n\r\n        let centerIndex = Math.floor((rowOrCol(group[group.length-1]) - rowOrCol(group[0])) / 2);\r\n        wordOrder.push(wordKey(group[centerIndex]));\r\n        usedWords.set(wordKey(group[centerIndex]), true);\r\n        iterateWordGroup(group.slice(0, centerIndex));\r\n        iterateWordGroup(group.slice(centerIndex + 1));\r\n    }\r\n\r\n    let wordOrder = [] as string[];\r\n    let usedWords = new Map<string, boolean>();\r\n\r\n    // stack words\r\n    if (section.stackWords.size > 0) {\r\n        let acrossSortedStackWords = mapKeys(section.stackWords).map(wKey => grid.words.get(wKey)!)\r\n            .filter(word => word.direction === WordDirection.Across).sort(wordsSort);\r\n        let downSortedStackWords = mapKeys(section.stackWords).map(wKey => grid.words.get(wKey)!)\r\n            .filter(word => word.direction === WordDirection.Down).sort(wordsSort);\r\n        let longestStack = downSortedStackWords.length === 0 ? acrossSortedStackWords :\r\n            acrossSortedStackWords.length === 0 ? downSortedStackWords :\r\n            wordLength(acrossSortedStackWords[0]) >= wordLength(downSortedStackWords[0]) ? acrossSortedStackWords :\r\n            downSortedStackWords;\r\n        let otherStack = longestStack === acrossSortedStackWords ? downSortedStackWords : acrossSortedStackWords;\r\n        [longestStack, otherStack].forEach(stack => {\r\n            for (let i = 0; i < stack.length; i++) {\r\n                let word = stack[i];\r\n                let length = wordLength(word);\r\n                let curGroup = [word];\r\n                let prevRowOrCol = rowOrCol(word);\r\n                for (let j = i+1; j < stack.length && wordLength(stack[j]) === length; j++) {\r\n                    let newWord = stack[j];\r\n                    let newRowOrCol = rowOrCol(newWord);\r\n                    if (newRowOrCol - prevRowOrCol === 1) {\r\n                        curGroup.push(newWord);\r\n                        prevRowOrCol = newRowOrCol;\r\n                        i++;\r\n                    }\r\n                    else break;\r\n                }\r\n    \r\n                iterateWordGroup(curGroup);\r\n            }\r\n        });\r\n    }\r\n\r\n    // restOfWords\r\n    let remainingWords = mapKeys(section.words).filter(wKey => !usedWords.has(wKey))\r\n        .map(wKey => grid.words.get(wKey)!).sort(wordsSort);\r\n    remainingWords.forEach(word => {\r\n        wordOrder.push(wordKey(word));\r\n    });\r\n\r\n    return wordOrder;\r\n}\r\n\r\nfunction rowOrCol(word: GridWord): number {\r\n    return word.direction === WordDirection.Across ? word.start[0] : word.start[1];\r\n}\r\n\r\nfunction isOpenSquare(grid: GridState, sq: GridSquare): boolean {\r\n    let neighbors = getNeighboringSquares(grid, sq);\r\n    return neighbors.length === 8 && !neighbors.find(n => isBlackSquare(n));\r\n}\r\n\r\nfunction getNeighboringSquares(grid: GridState, sq: GridSquare): GridSquare[] {\r\n    let ret = [] as GridSquare[];\r\n    let nClear = sq.row > 0;\r\n    let sClear = sq.row < grid.height-1;\r\n    let wClear = sq.col > 0;\r\n    let eClear = sq.col < grid.width-1;\r\n\r\n    if (nClear && wClear) ret.push(grid.squares[sq.row-1][sq.col-1]);\r\n    if (nClear) ret.push(grid.squares[sq.row-1][sq.col]);\r\n    if (nClear && eClear) ret.push(grid.squares[sq.row-1][sq.col+1]);\r\n    if (eClear) ret.push(grid.squares[sq.row][sq.col+1]);\r\n    if (sClear && eClear) ret.push(grid.squares[sq.row+1][sq.col+1]);\r\n    if (sClear) ret.push(grid.squares[sq.row+1][sq.col]);\r\n    if (sClear && wClear) ret.push(grid.squares[sq.row+1][sq.col-1]);\r\n    if (wClear) ret.push(grid.squares[sq.row][sq.col-1]);\r\n\r\n    return ret;\r\n}\r\n\r\nexport function newSectionCandidate(node: FillNode, section: Section): SectionCandidate {\r\n    let grid = node.endGrid;\r\n    return {\r\n        sectionId: section.id,\r\n        grid: grid,\r\n        score: calculateSectionCandidateScore(grid, section),\r\n        iffyEntry: node.iffyWordKey ? getEntryAtWordKey(grid, node.iffyWordKey) : undefined,\r\n        isFilteredOut: false,\r\n    } as SectionCandidate;\r\n}\r\n\r\nexport function calculateSectionCandidateScore(grid: GridState, section: Section): number {\r\n    let total = 0;\r\n    let foundIffy = false;\r\n    section.words.forEach((_, wordKey) => {\r\n        let word = grid.words.get(wordKey)!;\r\n        let squares = getSquaresForWord(grid, word);\r\n        let str = getLettersFromSquares(squares);\r\n        let score = getWordScore(str);\r\n        if (score < 3) foundIffy = true;\r\n        total += score;\r\n    });\r\n\r\n    if (!foundIffy) total *= 10;\r\n    return total / section.words.size;\r\n}\r\n\r\nconst natoAlphabet = {\r\n    \"A\": \"Alfa\",   \"B\": \"Bravo\",   \"C\": \"Charlie\",\r\n    \"D\": \"Delta\",  \"E\": \"Echo\",    \"F\": \"Foxtrot\",\r\n    \"G\": \"Golf\",   \"H\": \"Hotel\",   \"I\": \"India\",\r\n    \"J\": \"Juliett\",\"K\": \"Kilo\",    \"L\": \"Lima\",\r\n    \"M\": \"Mike\",   \"N\": \"November\",\"O\": \"Oscar\",\r\n    \"P\": \"Papa\",   \"Q\": \"Quebec\",  \"R\": \"Romeo\",\r\n    \"S\": \"Sierra\", \"T\": \"Tango\",   \"U\": \"Uniform\",\r\n    \"V\": \"Victor\", \"W\": \"Whiskey\", \"X\": \"X-ray\",\r\n    \"Y\": \"Yankee\", \"Z\": \"Zulu\"\r\n} as any;\r\n\r\nexport function getPhoneticName(n: number): string {\r\n    if (n === 0) return \"Full Grid\";\r\n    return n <= 26 ? natoAlphabet[String.fromCharCode(n+64)] : \"Section \" + n.toString();\r\n}\r\n\r\nexport function sectionCandidateKey(section: Section, grid: GridState): string {\r\n    let keys = mapKeys(section.squares).sort();\r\n    return keys.map(k => getSquareAtKey(grid, k).content!).join(\"\");\r\n}\r\n\r\nexport function makeNewSection(id: number): Section {\r\n    return {\r\n        id: id,\r\n        openSquareCount: 0,\r\n        squares: new Map<string, boolean>(),\r\n        words: new Map<string, boolean>(),\r\n        stackWords: new Map<string, boolean>(),\r\n        wordOrder: [],\r\n        neighboringCrosses: new Map<string, boolean>(),\r\n        candidates: new Map<string, SectionCandidate>(),\r\n        connections: new Map<number, boolean>(),\r\n        comboPermsQueue: [],\r\n        comboPermsUsed: new Map<string, boolean>(),\r\n    } as Section;\r\n}\r\n\r\nexport function getLongestStackWord(section: Section): GridWord {\r\n    function getLongest(wordKeys: string[]): GridWord {\r\n        return wordKeys.map(w => grid.words.get(w)!).sort((a, b) => wordLength(b) - wordLength(a))[0];\r\n    }\r\n\r\n    let grid = getGrid();\r\n    if (section.stackWords.size > 0)\r\n        return getLongest(mapKeys(section.stackWords))\r\n    else\r\n        return getLongest(mapKeys(section.words));\r\n}\r\n\r\nexport function getSelectedSections(): Section[] {\r\n    if (Globals.selectedSectionIds!.size === 0) return [Globals.sections!.get(0)!];\r\n    return mapKeys(Globals.selectedSectionIds!).sort().map(id => Globals.sections!.get(id)!);\r\n}\r\n\r\nexport function getSelectedSectionCandidates(): SectionCandidate[] {\r\n    let ret = [] as SectionCandidate[];\r\n    Globals.sections!.forEach((section, _) => {\r\n        Globals.selectedSectionCandidateKeys!.forEach((scKey, _) => {\r\n            if (section.candidates.has(scKey))\r\n                ret.push(section.candidates.get(scKey)!);\r\n        });\r\n    });\r\n    return ret;\r\n}\r\n\r\nexport function getSelectedSectionCandidatesWithWord(wordKey: string): SectionCandidate[] {\r\n    let ret = [] as SectionCandidate[];\r\n    getSelectedSectionCandidates().forEach(sc => {\r\n        let section = Globals.sections!.get(sc.sectionId)!;\r\n        if (section.words.has(wordKey))\r\n            ret.push(sc);\r\n    });\r\n    return ret;\r\n}\r\n\r\nexport function getSelectedSectionCandidatesWithSquare(squareKey: string): SectionCandidate[] {\r\n    let ret = [] as SectionCandidate[];\r\n    getSelectedSectionCandidates().forEach(sc => {\r\n        let section = Globals.sections!.get(sc.sectionId)!;\r\n        if (section.squares.has(squareKey))\r\n            ret.push(sc);\r\n    });\r\n    return ret;\r\n}\r\n\r\nexport function getSectionsWithSelectedCandidate(): Section[] {\r\n    return getSelectedSectionCandidates().map(sc => getSectionWithCandidate(sc));\r\n}\r\n\r\nexport function getSectionWithCandidate(sc: SectionCandidate): Section {\r\n    return Globals.sections!.get(sc.sectionId)!;\r\n}\r\n\r\nexport function getUnfilteredSectionCandidates(section: Section): SectionCandidate[] {\r\n    return mapValues(section.candidates).filter(sc => !sc.isFilteredOut);\r\n}\r\n\r\nexport function getSectionsWithWord(word: GridWord): Section[] {\r\n    return mapValues(Globals.sections!).filter(sec => sec.id > 0 && sec.words.has(wordKey(word)));\r\n}\r\n","import { ContentType } from \"../models/ContentType\";\r\nimport { FillNode } from \"../models/FillNode\";\r\nimport { GridSquare } from \"../models/GridSquare\";\r\nimport { GridState } from \"../models/GridState\";\r\nimport { getAllCrosses } from \"./fill\";\r\nimport { generateConstraintInfoForSquares, getLettersFromSquares } from \"./grid\";\r\nimport { sectionCandidateKey } from \"./section\";\r\nimport { deepClone, getSectionCandidatesFromKeys, getSquaresForWord, isWordFull, mapKeys } from \"./util\";\r\nimport Globals from './windowService';\r\n\r\nexport function processAndInsertChosenEntry(node: FillNode, contentType?: ContentType) {\r\n    if (contentType === undefined) contentType = ContentType.Autofill;\r\n    if (!node.chosenEntry) return false;\r\n\r\n    let grid = deepClone(node.startGrid) as GridState;\r\n    let word = node.fillWord!;\r\n    let wordSquares = getSquaresForWord(grid, word);\r\n    let crosses = getAllCrosses(grid, word);\r\n\r\n    wordSquares.forEach((sq, i) => {\r\n        sq.content = node.chosenEntry!.word[i];\r\n        if ([ContentType.Autofill, ContentType.ChosenSection, ContentType.HoverChosenWord].includes(sq.contentType))\r\n            sq.contentType = contentType!;\r\n    });\r\n    grid.usedWords.set(getLettersFromSquares(wordSquares), true);\r\n    node.iffyWordKey = node.chosenEntry!.iffyWordKey;\r\n\r\n    if (contentType === ContentType.ChosenWord) {\r\n        removeNonmatchingSectionCandidates(grid, wordSquares, node.chosenEntry!.word);\r\n    }  \r\n\r\n    crosses.forEach(cross => {\r\n        let newSquares = getSquaresForWord(grid, cross);\r\n        generateConstraintInfoForSquares(newSquares);\r\n\r\n        if (isWordFull(newSquares)) {\r\n            grid.usedWords.set(getLettersFromSquares(newSquares), true);\r\n        }\r\n    });\r\n    \r\n    node.endGrid = grid;\r\n}\r\n\r\nfunction removeNonmatchingSectionCandidates(grid: GridState, newSquares: GridSquare[], chosenEntry: string) {\r\n    let sectionCandidates = getSectionCandidatesFromKeys(mapKeys(grid.userFilledSectionCandidates));\r\n    sectionCandidates.forEach(sc => {\r\n        let section = Globals.sections!.get(sc.sectionId)!;\r\n        newSquares.forEach((sq, i) => {\r\n            if (sc.grid.squares[sq.row][sq.col].content !== chosenEntry[i])\r\n                grid.userFilledSectionCandidates.delete(sectionCandidateKey(section, grid));\r\n        });\r\n    });\r\n}\r\n","// https://itnext.io/priority-queue-in-typescript-6ef23116901\r\n\r\n  interface Node<T> {\r\n    key: number\r\n    value: T\r\n  }\r\n\r\n  export interface PriorityQueue<T> {\r\n      isEmpty: () => boolean,\r\n      peek: () => T | null,\r\n      size: () => number,\r\n      insert: (item: T, prio: number) => void,\r\n      pop: () => T | null,\r\n  }\r\n  \r\n  export const priorityQueue = <T>(): PriorityQueue<T> => {\r\n    let heap: Node<T>[] = []\r\n\r\n    const parent = (index: number) => Math.floor((index - 1) / 2)\r\n    const left = (index: number) => 2 * index + 1\r\n    const right = (index: number) =>  2 * index + 2\r\n    const hasLeft = (index: number) => left(index) < heap.length\r\n    const hasRight = (index: number) => right(index) < heap.length\r\n\r\n    const swap = (a: number, b: number) => {\r\n        let temp = heap[a];\r\n        heap[a] = heap[b];\r\n        heap[b] = temp;\r\n    }\r\n  \r\n    return {\r\n      \r\n      isEmpty: () => heap.length === 0,\r\n  \r\n      peek: () => heap.length === 0 ? null : heap[0].value,\r\n      \r\n      size: () => heap.length,\r\n\r\n      insert: (item, prio) => {\r\n        heap.push({key: prio, value: item})\r\n  \r\n        let i = heap.length -1\r\n        while(i > 0) {\r\n          const p = parent(i)\r\n          if(heap[p].key > heap[i].key) break\r\n          const tmp = heap[i]\r\n          heap[i] = heap[p]\r\n          heap[p] = tmp\r\n          i = p\r\n        }\r\n      },\r\n\r\n      pop: () => {\r\n        if(heap.length === 0) return null\r\n        \r\n        swap(0, heap.length - 1)\r\n        const item = heap.pop()\r\n  \r\n        let current = 0\r\n        while(hasLeft(current)) {\r\n          let largerChild = left(current)\r\n          if(hasRight(current) && heap[right(current)].key > heap[left(current)].key) \r\n            largerChild = right(current)\r\n  \r\n          if(heap[largerChild].key < heap[current].key) break\r\n  \r\n          swap(current, largerChild)\r\n          current = largerChild\r\n        }\r\n  \r\n        return item!.value\r\n      }\r\n    }\r\n  }\r\n  ","export enum FillStatus {\r\n    NoWordList,\r\n    Ready,\r\n    Running,\r\n    Complete,\r\n}\r\n","import { ContentType } from '../models/ContentType';\r\nimport { EntryCandidate } from '../models/EntryCandidate';\r\nimport { FillNode } from '../models/FillNode';\r\nimport { GridSquare } from '../models/GridSquare';\r\nimport { GridState } from '../models/GridState';\r\nimport { GridWord } from '../models/GridWord';\r\nimport { QualityClass } from '../models/QualityClass';\r\nimport { Section } from '../models/Section';\r\nimport { WordDirection } from '../models/WordDirection';\r\nimport { populateAndScoreEntryCandidates } from './entryCandidates';\r\nimport { processAndInsertChosenEntry } from './insertEntry';\r\nimport { PriorityQueue, priorityQueue } from './priorityQueue';\r\nimport { getSectionString, getSectionsWithWord, insertSectionCandidateIntoGrid, newSectionCandidate } from './section';\r\nimport { deepClone, getSquaresForWord, mapKeys, isWordFull, \r\n    getWordAtSquare, otherDir, mapValues, getSection, getGrid, wordKey } from './util';\r\nimport Globals from './windowService';\r\n\r\nexport function fillSectionWord(): boolean {\r\n    let section = getSection();\r\n    let fillQueue = section.fillQueue;\r\n    if (!fillQueue) {\r\n        let newFillQueue = priorityQueue<FillNode>();\r\n        populateSeedNodes(newFillQueue);\r\n        fillQueue = newFillQueue;\r\n        section.fillQueue = newFillQueue;\r\n    }\r\n\r\n    let node = fillQueue.peek()!;\r\n    if (!node) {\r\n        populateSeedNodes(fillQueue);\r\n        node = fillQueue.peek()!;\r\n        if (!node) {\r\n            return false;\r\n        }\r\n    }\r\n    while (node.needsNewPriority || node.shouldBeDeleted) {\r\n        node.needsNewPriority = false;\r\n        fillQueue.pop();\r\n        if (!node.shouldBeDeleted) fillQueue.insert(node, calculateNodePriority(node));\r\n        node = fillQueue.peek()!;\r\n        if (!node) return false;\r\n    }\r\n    while (node.isChainNode && node.chainId! !== Globals.curChainId!) {\r\n        fillQueue.pop();\r\n        node = fillQueue.peek()!;\r\n        if (!node) return false;\r\n    }\r\n\r\n    if (!node.isChainNode && Globals.activeGrid !== node.startGrid) {\r\n        Globals.activeGrid = node.startGrid;\r\n        return true;\r\n    }\r\n\r\n    let success = processSectionNode(node, section);\r\n    if (success) {\r\n        let sectionString = getSectionString(node.endGrid, section);\r\n        // is section filled?\r\n        if (!sectionString.includes(\"-\")) {\r\n            let newSecCandidateFound = false;\r\n            if (!section.candidates.has(sectionString)) {\r\n                let newCandidate = newSectionCandidate(node, section);\r\n                section.candidates.set(sectionString, newCandidate);\r\n                Globals.activeGrid = node.endGrid;\r\n                newSecCandidateFound = true;\r\n            }\r\n            \r\n            invalidateChainNode(node, newSecCandidateFound);\r\n            fillQueue.pop();\r\n            return true;\r\n        }\r\n\r\n        Globals.activeGrid = node.endGrid;\r\n        let newNode = makeNewNode(node.endGrid, node.depth + 1, true, node);\r\n        \r\n        if (section.id === 0) {\r\n            let nextFillWord = selectWordToFill(node, getSection());\r\n            let curSections = getSectionsWithWord(node.fillWord!);\r\n            let nextSections = getSectionsWithWord(nextFillWord!);\r\n            if (curSections.length > 0 && !curSections.find(cs => nextSections.find(ns => ns.id === cs.id))) {\r\n                newNode = makeNewNode(node.endGrid, node.depth + 1, false, node, true);\r\n                Globals.curChainId!++;\r\n            }\r\n        }\r\n        \r\n        fillQueue.insert(newNode, calculateNodePriority(newNode));\r\n    }\r\n    else {\r\n        fillQueue.pop();\r\n        if (node.isChainNode) invalidateChainNode(node);\r\n        fillSectionWord();\r\n    }\r\n\r\n    Globals.selectedWordNode = undefined;\r\n    return true;\r\n}\r\n\r\nfunction invalidateChainNode(node: FillNode, newSecCandidateFound?: boolean) {\r\n    if (newSecCandidateFound === undefined) newSecCandidateFound = false;\r\n\r\n    let parent = node.parent!;\r\n    if (!parent) return;\r\n\r\n    let prevCandidate = parent.chosenEntry!;\r\n    if (parent.isChainNode) {\r\n        if (prevCandidate)\r\n            prevCandidate.wasChainFailure = true;\r\n        parent.backtracks++;\r\n    }\r\n    else {\r\n        if (prevCandidate)\r\n            prevCandidate.hasBeenChained = true;\r\n    }\r\n\r\n    parent.chosenEntry = undefined;\r\n    parent.iffyWordKey = parent.parent ? parent.parent.iffyWordKey : undefined;\r\n    parent.endGrid = deepClone(parent.startGrid);\r\n\r\n    if (parent.backtracks >= 3) {\r\n        if (parent.parent && !parent.parent.isChainNode) {\r\n            parent.isChainNode = false;\r\n            parent.needsNewPriority = true;\r\n            Globals.curChainId!++;\r\n        }\r\n            \r\n        invalidateChainNode(parent);\r\n    }\r\n\r\n    if (newSecCandidateFound) {\r\n        if (node.iffyWordKey && node.chainBaseNode!.chainIffyCandidates < 24) {\r\n            node.chainBaseNode!.chainIffyCandidates++;\r\n            return;\r\n        }\r\n        else if (!node.iffyWordKey && node.chainBaseNode!.chainGoodCandidates < 4) {\r\n            node.chainBaseNode!.chainGoodCandidates++;\r\n            return;\r\n        }\r\n\r\n        let curNode = parent;\r\n        while (curNode.parent && (curNode.parent.isChainNode || curNode.parent.isSectionBase)) {\r\n            if (curNode.isSectionBase) curNode.shouldBeDeleted = true;\r\n            curNode = curNode.parent!;\r\n        }\r\n        curNode.isChainNode = false;\r\n        curNode.needsNewPriority = true;\r\n        Globals.curChainId!++;\r\n    }\r\n}\r\n\r\nfunction calculateNodePriority(node: FillNode): number {\r\n    let grid = node.startGrid;\r\n    let wordScore = 0;\r\n    grid.usedWords.forEach((_, word) => {\r\n        wordScore += getWordScore(word);\r\n    });\r\n\r\n    let situationScore: number;\r\n    if (node.isChainNode)\r\n        situationScore = 1e8 + 10000*(node.depth+1);\r\n    else if (node.isSectionBase)\r\n        situationScore = (10000 + node.depth) * 10000;\r\n    else\r\n        situationScore = (10000 - node.depth) * 10000;\r\n\r\n    return wordScore + situationScore;\r\n}\r\n\r\nfunction populateSeedNodes(fillQueue: PriorityQueue<FillNode>) {\r\n    let grid = getGrid();\r\n    let selectedSectionIds = [Globals.activeSectionId!]; //Globals.selectedSectionIds!.size > 0 ? mapKeys(Globals.selectedSectionIds!) : [0];\r\n    let activeSection = getSection();\r\n    let connectionIds = mapKeys(activeSection.connections)\r\n        .filter(id => selectedSectionIds.includes(id) && Globals.sections!.get(id)!.selectedCandidate === undefined\r\n            && Globals.sections!.get(id)!.candidates.size > 0)\r\n        .sort();\r\n    let candidateCounts = connectionIds.map(i => Globals.sections!.get(i)!.candidates.size);\r\n    \r\n    getNewPermutations(candidateCounts, activeSection);\r\n    activeSection.comboPermsQueue.forEach(perm => {\r\n        let node = makeNewNode(grid, 0, false, undefined);\r\n        if (perm[0] === -1) {\r\n            fillQueue.insert(node, calculateNodePriority(node));\r\n            return;\r\n        }\r\n        let wasSuccess = true;\r\n        for (let i = 0; i < perm.length; i++) {\r\n            let sortedCandidates = mapValues(Globals.sections!.get(connectionIds[i])!.candidates)\r\n                .sort((a, b) => b.score - a.score);\r\n            let candidate = sortedCandidates[perm[i]];\r\n            if (!insertSectionCandidateIntoGrid(node.startGrid, candidate, ContentType.Autofill))\r\n                wasSuccess = false;\r\n        }\r\n        if (wasSuccess)\r\n            fillQueue.insert(node, calculateNodePriority(node));\r\n    });\r\n}\r\n\r\nfunction getNewPermutations(candidateCounts: number[], section: Section) {\r\n    function comboKey(perm: number[]): string {\r\n        return \"[\" + perm.map(n => n.toString()).join(\",\") + \"]\";\r\n    }\r\n\r\n    if (section.comboPermsUsed.size > 0 && section.comboPermsQueue.length > 0 && section.comboPermsQueue[0][0] === -1)\r\n        section.comboPermsQueue.shift();\r\n    if (section.comboPermsUsed.size > 0 && section.comboPermsQueue.length === 0) return;\r\n\r\n    if (candidateCounts.length === 0) {\r\n        let defaultCombo = [-1];\r\n        section.comboPermsQueue = [defaultCombo];\r\n        section.comboPermsUsed.set(comboKey(defaultCombo), true);\r\n        return;\r\n    }\r\n\r\n    if (section.comboPermsUsed.size === 0) {\r\n        let allOnes = [] as number[];\r\n        for(let i = 0; i < candidateCounts.length; i++) allOnes.push(1);\r\n        section.comboPermsQueue = [allOnes];\r\n        section.comboPermsUsed.set(comboKey(allOnes), true);\r\n        return;\r\n    }\r\n\r\n    while(true) {\r\n        let perm = section.comboPermsQueue.shift()!;\r\n        if (!perm) break;\r\n        let foundNew = false;\r\n\r\n        for(let i = 0; i < perm.length; i++) {\r\n            if (perm[i] === candidateCounts[i] - 1) continue;\r\n    \r\n            let newPerm = deepClone(perm);\r\n            newPerm[i]++;\r\n            let newPermKey = comboKey(newPerm);\r\n            if (section.comboPermsUsed.has(newPermKey)) continue;\r\n\r\n            section.comboPermsUsed.set(newPermKey, true);\r\n            foundNew = true;\r\n            section.comboPermsQueue.push(newPerm);\r\n        }\r\n\r\n        if (foundNew) break;\r\n    }\r\n}\r\n\r\nexport function processSectionNode(node: FillNode, section: Section): boolean {\r\n    if (!node.fillWord)\r\n        node.fillWord = selectWordToFill(node, section);\r\n\r\n    if (node.anchorSquareKeys.length === 0 || node.anchorCombosLeft.length > 0) {\r\n        let areEligibleCandidates = populateAndScoreEntryCandidates(node, false);\r\n        if (!areEligibleCandidates) return false;\r\n    }\r\n\r\n    let eligibleCandidates = getEligibleCandidates(node);\r\n    if (eligibleCandidates.length > 0) {\r\n        node.chosenEntry = chooseEntryFromCandidates(eligibleCandidates);\r\n        processAndInsertChosenEntry(node);\r\n        return true;\r\n    }\r\n    \r\n    return false;\r\n}\r\n\r\nexport function makeNewNode(grid: GridState, depth: number, isChainNode: boolean, parent: FillNode | undefined, \r\n    isSectionBase?: boolean): FillNode {\r\n    return {\r\n        startGrid: deepClone(grid),\r\n        endGrid: deepClone(grid),\r\n        entryCandidates: [],\r\n        depth: depth,\r\n        isChainNode: isChainNode,\r\n        isSectionBase: !!isSectionBase,\r\n        backtracks: 0,\r\n        parent: parent,\r\n        chainBaseNode: isChainNode ? (parent!.isChainNode ? parent!.chainBaseNode : parent!) : undefined,\r\n        needsNewPriority: false,\r\n        shouldBeDeleted: false,\r\n        anchorSquareKeys: [],\r\n        anchorCombosLeft: [],\r\n        viableLetterCounts: new Map<string, Map<string, number>>(),\r\n        iffyWordKey: parent ? parent.iffyWordKey : undefined,\r\n        chainGoodCandidates: parent ? parent.chainGoodCandidates : 0,\r\n        chainIffyCandidates: parent ? parent.chainIffyCandidates : 0,\r\n        chainId: Globals.curChainId!,\r\n        topCrossScore: 0,\r\n        topMinCrossScore: 0,\r\n    } as FillNode;\r\n}\r\n\r\nfunction selectWordToFill(node: FillNode, section: Section): GridWord | undefined {\r\n    let grid = node.startGrid;\r\n\r\n    for (let key of section.wordOrder) {\r\n        let word = grid.words.get(key)!;\r\n        let squares = getSquaresForWord(grid, word);\r\n        if (wordKey(word) !== node.iffyWordKey && !isWordFull(squares))\r\n            return word;\r\n    }\r\n\r\n    return undefined;\r\n}\r\n\r\nexport function getPositionOfCross(wordSquares: GridSquare[], crossSquares: GridSquare[], dir: WordDirection): number {\r\n    return dir === WordDirection.Across ? \r\n            wordSquares[0].row - crossSquares[0].row : \r\n            wordSquares[0].col - crossSquares[0].col;\r\n}\r\n\r\nexport function getAllCrosses(grid: GridState, word: GridWord): GridWord[] {\r\n    let squares = getSquaresForWord(grid, word);\r\n    let crosses = squares\r\n        .map(sq => getWordAtSquare(grid, sq.row, sq.col, otherDir(word.direction)))\r\n        .filter(w => w).map(w => w!);\r\n    return crosses.length > 0 ? crosses : [];\r\n}\r\n\r\nexport function getUnfilledCrosses(grid: GridState, word: GridWord): GridWord[] {\r\n    let squares = getSquaresForWord(grid, word);\r\n    let crosses = squares\r\n        .map(sq => getWordAtSquare(grid, sq.row, sq.col, otherDir(word.direction)))\r\n        .filter(w => w && !isWordFull(getSquaresForWord(grid, w)))\r\n        .map(w => w!);\r\n    return crosses.length > 0 ? crosses : [];\r\n}\r\n\r\nexport function getEligibleCandidates(node: FillNode): EntryCandidate[] {\r\n    if (node.isChainNode) {\r\n        return node.entryCandidates.filter(ec => ec.isViable && !ec.wasChainFailure);\r\n    }\r\n    else {\r\n        return node.entryCandidates.filter(ec => ec.isViable && !ec.hasBeenChained);\r\n    }\r\n}\r\n\r\nfunction chooseEntryFromCandidates(candidates: EntryCandidate[]): EntryCandidate {\r\n    let topScore = candidates[0].score!;\r\n    let total = 0;\r\n    candidates.forEach(c => {\r\n        total += Math.pow(c.score / topScore, 4);\r\n    });\r\n\r\n    let roll = Math.random() * total;\r\n    let runningTotal = 0;\r\n    for (let can of candidates) {\r\n        runningTotal += Math.pow(can.score / topScore, 4);\r\n        if (runningTotal >= roll)\r\n            return can;\r\n    }\r\n\r\n    return candidates[0];\r\n}\r\n\r\nexport function getWordScore(word: string): number {\r\n    let qualityClass = Globals.qualityClasses!.get(word);\r\n    if (!qualityClass) return 0;\r\n\r\n    switch(qualityClass) {\r\n        case QualityClass.Lively: return 12;\r\n        case QualityClass.Normal: return 9;\r\n        case QualityClass.Crosswordese: return 3;\r\n        case QualityClass.Iffy: return 1;\r\n    }\r\n}\r\n","import { FillNode } from \"../models/FillNode\";\r\nimport { GridSquare } from \"../models/GridSquare\";\r\nimport { GridState } from \"../models/GridState\";\r\nimport { GridWord } from \"../models/GridWord\";\r\nimport { SquareType } from \"../models/SquareType\";\r\nimport { WordDirection } from \"../models/WordDirection\";\r\nimport Globals from './windowService';\r\nimport { getSquaresForWord, isBlackSquare, newWord, forAllGridSquares, isWordFull, isWordEmpty, getGrid, \r\n    isUserFilled, deepClone, wordKey, getWordAtSquare, getSquareAtKey, otherDir, squareKey, getSection, mapKeys, \r\n    fullAlphabet, letterListToLetterMatrix, letterMatrixToLetterList } from \"./util\";\r\nimport { SymmetryType } from \"../models/SymmetryType\";\r\nimport { makeNewNode } from \"./fill\";\r\nimport { ContentType } from \"../models/ContentType\";\r\nimport { processAndInsertChosenEntry } from \"./insertEntry\";\r\nimport { queryIndexedWordList } from \"./wordList\";\r\nimport { populateAndScoreEntryCandidates, populateNoHeuristicEntryCandidates } from \"./entryCandidates\";\r\nimport { getSectionsWithSelectedCandidate, getSectionWithCandidate, \r\n    getSelectedSectionCandidatesWithSquare } from \"./section\";\r\nimport { FillStatus } from \"../models/FillStatus\";\r\nimport { SectionCandidate } from \"../models/SectionCandidate\";\r\n\r\nexport function populateWords(grid: GridState) {\r\n    function processSquare(grid: GridState, row: number, col: number, dir: WordDirection) {\r\n        let sq = grid.squares[row][col];\r\n\r\n        if (isBlackSquare(sq)) return;\r\n        if (!currentWord.number && !sq.number) return; // unchecked square\r\n\r\n        if (!currentWord.number) {\r\n            currentWord.number = sq.number;\r\n            currentWord.direction = dir;\r\n            currentWord.start = [row, col]; \r\n        }\r\n\r\n        currentWord.end = [row, col];\r\n\r\n        let nextSq = dir === WordDirection.Across ? [row, col+1] : [row+1, col];\r\n        if (nextSq[0] === grid.height || nextSq[1] === grid.width || isBlackSquare(grid.squares[nextSq[0]][nextSq[1]])) {\r\n            if ((dir === WordDirection.Across && currentWord.end[1] - currentWord.start[1] > 0) ||\r\n                (dir === WordDirection.Down && currentWord.end[0] - currentWord.start[0] > 0))\r\n                grid.words.set(wordKey(currentWord), currentWord);\r\n            currentWord = newWord();\r\n        }\r\n    }\r\n\r\n    grid.words = new Map<string, GridWord>();\r\n\r\n    numberizeGrid(grid);\r\n\r\n    let currentWord: GridWord = newWord();\r\n    for (let row = 0; row < grid.height; row++) {\r\n        for (let col = 0; col < grid.width; col++) {\r\n            processSquare(grid, row, col, WordDirection.Across);\r\n        }\r\n    }\r\n\r\n    for (let col = 0; col < grid.width; col++) {\r\n        for (let row = 0; row < grid.height; row++) {\r\n            processSquare(grid, row, col, WordDirection.Down);\r\n        }\r\n    }\r\n}\r\n\r\nexport function updateGridConstraintInfo(grid: GridState) {\r\n    grid.usedWords = new Map<string, boolean>();\r\n    forAllGridSquares(grid, sq => { sq.viableLetters = undefined; });\r\n\r\n    if (!Globals.wordList) return;\r\n\r\n    let wordKeys = mapKeys(grid.words);\r\n    let sortedWordKeys = wordKeys.filter(k => k.includes(\"A\")).concat(wordKeys.filter(k => k.includes(\"D\")));\r\n    sortedWordKeys.forEach(wordKey => {\r\n        let word = grid.words.get(wordKey)!;\r\n        let newSquares = deepClone(getSquaresForWord(grid, word)) as GridSquare[];\r\n        let letters = getLettersFromSquares(newSquares);\r\n        if (!letters.includes(\"-\")) grid.usedWords.set(letters, true);\r\n        generateConstraintInfoForSquares(newSquares);\r\n        if (newSquares !== undefined && newSquares.length > 0) {\r\n            newSquares.forEach(ns => {\r\n                grid.squares[ns.row][ns.col] = ns;\r\n            });\r\n        }\r\n    });\r\n}\r\n\r\nfunction numberizeGrid(grid: GridState) {\r\n    var currentNumber = 1;\r\n\r\n    for(var row = 0; row < grid.height; row++) {\r\n        for (var col = 0; col < grid.width; col++) {\r\n            var sq = grid.squares[row][col];  \r\n            sq.number = undefined;\r\n\r\n            if (!isBlackSquare(sq)) {\r\n                let isAboveBlocked = (row === 0 || isBlackSquare(grid.squares![row-1][col]));\r\n                let isBelowBlocked = (row === grid.height-1 || isBlackSquare(grid.squares[row+1][col]));\r\n                let isLeftBlocked = (col === 0 || isBlackSquare(grid.squares[row][col-1]));\r\n                let isRightBlocked = (col === grid.width-1 || isBlackSquare(grid.squares[row][col+1]));\r\n\r\n                let isUnchecked = (isAboveBlocked && isBelowBlocked) || (isLeftBlocked && isRightBlocked);\r\n                let isUncheckedStart = (isAboveBlocked && isBelowBlocked && isLeftBlocked && !isRightBlocked) || \r\n                                       (isLeftBlocked && isRightBlocked && isAboveBlocked && !isBelowBlocked);\r\n                let isCheckedStart = isAboveBlocked || isLeftBlocked;\r\n\r\n                if ((isUnchecked && isUncheckedStart) || (!isUnchecked && isCheckedStart)) {\r\n                    sq.number = currentNumber++;\r\n                }\r\n            } \r\n        }\r\n    }\r\n}\r\n\r\nexport function generateConstraintInfoForSquares(squares: GridSquare[]) {\r\n    squares.forEach(sq => {\r\n        if (sq.content) {\r\n            sq.viableLetters = [sq.content];\r\n        }\r\n        else if (!sq.viableLetters) {\r\n            sq.viableLetters = deepClone(fullAlphabet);\r\n        }\r\n    });\r\n    if (isWordEmpty(squares) || isWordFull(squares)) return;\r\n\r\n    let pattern = getLettersFromSquares(squares);\r\n    let entryOptions = queryIndexedWordList(pattern);\r\n    if (entryOptions.length > 500) return;\r\n\r\n    for (let i = 0; i < squares.length; i++) {\r\n        let sq = squares[i];\r\n        if (sq.content) continue;\r\n        let curViableMatrix = sq.viableLetters ? letterListToLetterMatrix(sq.viableLetters) : Array<boolean>(26).fill(true);\r\n        let newViableMatrix = Array<boolean>(26).fill(false);\r\n\r\n        let letters = entryOptions.map(entry => entry[i]);\r\n        letters.forEach(ltr => {\r\n            if (sq.viableLetters && curViableMatrix[ltr.charCodeAt(0) - 65]) return;\r\n            setLettersArrayVal(newViableMatrix, ltr, true);\r\n        });\r\n        sq.viableLetters = letterMatrixToLetterList(newViableMatrix);\r\n    }\r\n}\r\n\r\nexport function getLettersArrayVal(arr: boolean[], ltr: string) {\r\n    return arr[ltr.charCodeAt(0) - 65];\r\n}\r\n\r\nexport function setLettersArrayVal(arr: boolean[], ltr: string, newVal: boolean) {\r\n    arr[ltr.charCodeAt(0) - 65] = newVal;\r\n}\r\n\r\nexport function getConstraintSquareSum(squares: GridSquare[]): number {\r\n    let total = 0;\r\n    squares.forEach(sq => {\r\n        total += sq.viableLetters ? sq.viableLetters.length : 0;\r\n    });\r\n    return total;\r\n}\r\n\r\nexport function getLettersFromSquares(squares: GridSquare[]): string {\r\n    return squares.map(sq => sq.content ? sq.content! : \"-\").join(\"\");\r\n}\r\n\r\nexport function gridToString(grid: GridState): string {\r\n    let chs: string[] = [];\r\n    forAllGridSquares(grid, sq => {\r\n        chs.push(isBlackSquare(sq) ? \".\" : sq.content ? sq.content : \"-\");\r\n    });\r\n    return chs.join(\"\");\r\n}\r\n\r\nexport function createNewGrid(width: number, height: number): GridState {\r\n    let squares: GridSquare[][] = [];\r\n\r\n    for (let row = 0; row < height; row++) {\r\n        squares.push([]);\r\n        for (let col = 0; col < width; col++) {\r\n            squares[row][col] = {\r\n                row: row,\r\n                col: col,\r\n                type: SquareType.White,\r\n                isCircled: false,\r\n                contentType: ContentType.Autofill,\r\n            } as GridSquare;\r\n        }\r\n    }\r\n\r\n    let grid: GridState = {\r\n        height: height,\r\n        width: width,\r\n        squares: squares,\r\n        words: new Map<string, GridWord>(),\r\n        usedWords: new Map<string, boolean>(),\r\n        userFilledSectionCandidates: new Map<string, boolean>(),\r\n    };\r\n\r\n    populateWords(grid);\r\n\r\n    return grid;\r\n}\r\n\r\nexport function getUncheckedSquareDir(grid: GridState, row: number, col: number): WordDirection | undefined {\r\n    if (grid.squares[row][col].type === SquareType.Black) return undefined;\r\n    if ((col === 0 || grid.squares[row][col-1].type === SquareType.Black) &&\r\n        (col === grid.width-1 || grid.squares[row][col+1].type === SquareType.Black))\r\n        return WordDirection.Down;\r\n    if ((row === 0 || grid.squares[row-1][col].type === SquareType.Black) &&\r\n        (row === grid.height-1 || grid.squares[row+1][col].type === SquareType.Black))\r\n        return WordDirection.Across;\r\n\r\n    return undefined;\r\n}\r\n\r\nexport function getSymmetrySquares(initSquare: [number, number]): [number, number][] {\r\n    let grid = getGrid();\r\n    let w = grid.width - 1;\r\n    let h = grid.height - 1;\r\n    let r = initSquare[0];\r\n    let c = initSquare[1];\r\n    let ret = [initSquare];\r\n\r\n    switch (Globals.gridSymmetry!) {\r\n        case SymmetryType.Rotate180:\r\n            ret.push([h - r, w - c]);\r\n            break;\r\n        case SymmetryType.Rotate90:\r\n            ret.push([c, h - r]);\r\n            ret.push([h - r, w - c]);\r\n            ret.push([w - c, r]);\r\n            break;\r\n        case SymmetryType.MirrorHorizontal:\r\n            ret.push([r, w - c]);\r\n            break;\r\n        case SymmetryType.MirrorVertical:\r\n            ret.push([h - r, c]);\r\n            break;\r\n        case SymmetryType.MirrorNWSE:\r\n            ret.push([w - c, h - r]);\r\n            break;\r\n        case SymmetryType.MirrorNESW:\r\n            ret.push([c, r]);\r\n            break;\r\n    }\r\n\r\n    return ret;\r\n}\r\n\r\nexport function insertEntryIntoGrid(node: FillNode, wordKey: string, entry: string, iffyWordKey?: string, contentType?: ContentType) {\r\n    let grid = node.startGrid;\r\n    node.fillWord = grid.words.get(wordKey)!;\r\n    node.chosenEntry = node.entryCandidates.find(ec => ec.word === entry && ec.iffyWordKey === iffyWordKey);\r\n    processAndInsertChosenEntry(node, contentType);\r\n}\r\n\r\nexport function eraseGridSquare(grid: GridState, sq: GridSquare, dir: WordDirection) {\r\n    if (sq.content === undefined) return;\r\n\r\n    let word = getWordAtSquare(grid, sq.row, sq.col, dir)!;\r\n    let squares = word ? getSquaresForWord(grid, word) : [sq];\r\n\r\n    let otherDirWord = getWordAtSquare(grid, sq.row, sq.col, dir)!;\r\n    let otherDirSquares = otherDirWord ? getSquaresForWord(grid, otherDirWord) : [sq];\r\n    if (squares.length > 1 && isWordFull(squares)) grid.usedWords.delete(getLettersFromSquares(squares));\r\n    if (otherDirSquares.length > 1 && isWordFull(otherDirSquares)) grid.usedWords.delete(getLettersFromSquares(otherDirSquares));\r\n\r\n    if (squares.find(sq => sq.contentType === ContentType.Autofill)) {\r\n        ; // autofill is ephemeral, no need to explicitly delete\r\n    }\r\n    else if (squares.find(sq => [ContentType.User, ContentType.ChosenWord].includes(sq.contentType))) {\r\n        let isInSection = getSectionsWithSelectedCandidate().find(sec => sec.squares.has(squareKey(sq)));\r\n\r\n        squares.forEach(wsq => {\r\n            if (wsq.contentType === ContentType.User) return;\r\n            let cross = getWordAtSquare(grid, wsq.row, wsq.col, otherDir(dir))!;\r\n            let crossSquares = getSquaresForWord(grid, cross);\r\n            if (crossSquares.find(csq => [ContentType.Autofill, ContentType.ChosenSection].includes(csq.contentType))) {\r\n                if (isInSection)\r\n                    wsq.contentType = ContentType.ChosenSection;\r\n                else\r\n                    wsq.contentType = ContentType.Autofill;\r\n            }\r\n        });\r\n    }\r\n        \r\n    sq.content = undefined;\r\n    sq.contentType = ContentType.Autofill;\r\n    clearFill(grid);\r\n}\r\n\r\nexport function eraseSectionCandidateFromGrid(grid: GridState, sc: SectionCandidate) {\r\n    let section = getSectionWithCandidate(sc);\r\n    Globals.selectedSectionCandidateKeys?.delete(section.id);\r\n    section.squares.forEach((_, sqKey) => {\r\n        let sq = getSquareAtKey(grid, sqKey);\r\n        let scs = getSelectedSectionCandidatesWithSquare(sqKey);\r\n        if (scs.length > 1) return;\r\n        if (sq.contentType === ContentType.ChosenSection)\r\n            sq.contentType = ContentType.Autofill;\r\n    });\r\n}\r\n\r\nexport function clearFill(grid: GridState) {\r\n    Globals.selectedWordNode = undefined;\r\n    let section = getSection();\r\n    section.fillQueue = undefined;\r\n    section.comboPermsQueue = [];\r\n    section.comboPermsUsed = new Map<string, boolean>();\r\n    Globals.fillStatus = Globals.wordList !== undefined ? FillStatus.Ready : FillStatus.NoWordList;\r\n\r\n    forAllGridSquares(grid, sq => {\r\n        if (!isUserFilled(sq)) {\r\n            sq.content = undefined;\r\n        }\r\n    });\r\n\r\n    updateGridConstraintInfo(grid);\r\n}\r\n\r\nexport function updateManualEntryCandidates(grid: GridState) {\r\n    if (!Globals.selectedWordKey || !Globals.wordList) {\r\n        Globals.selectedWordNode = undefined;\r\n        return;\r\n    }\r\n\r\n    let node = makeNewNode(grid, 0, false, undefined);\r\n    node.fillWord = grid.words.get(Globals.selectedWordKey!);\r\n    if (Globals.useManualHeuristics!) {\r\n        populateAndScoreEntryCandidates(node, true);\r\n    }\r\n    else {\r\n        populateNoHeuristicEntryCandidates(node);\r\n    }\r\n    Globals.selectedWordNode = node;\r\n}\r\n","import { CluesViewProp } from \"./CluesViewProp\";\r\nimport React, { createRef, useEffect, useRef, useState } from 'react';\r\nimport \"./CluesView.scss\";\r\nimport { wordKey, deepClone, getSquaresForWord, getGrid, mapValues } from \"../../lib/util\";\r\nimport Globals from '../../lib/windowService';\r\nimport { getLettersFromSquares } from \"../../lib/grid\";\r\nimport { WordDirection } from \"../../models/WordDirection\";\r\n\r\nfunction CluesView(props: any) {\r\n    const [clueProps, setClueProps] = useState(initClueProps());\r\n    const [selectedKey, setSelectedKey] = useState(\"\");\r\n    const textareasRef = useRef([] as any[]);\r\n\r\n    useEffect(() => {\r\n        setClueProps(initClueProps());\r\n        setSelectedKey(Globals.selectedWordKey!);\r\n    }, [props.updateSemaphore])\r\n\r\n    function initClueProps(): CluesViewProp[] {\r\n        let props = [] as CluesViewProp[];\r\n        if (!Globals.puzzle) return props;\r\n\r\n        let grid = getGrid();\r\n        let words = grid.words;\r\n        let clues = Globals.puzzle.clues;\r\n        mapValues(words).sort((a, b) => (a.number || 0) - (b.number || 0)).forEach(word => {\r\n            let key = wordKey(word);\r\n            let squares = getSquaresForWord(grid, word);\r\n            let prop = {\r\n                number: word.number!,\r\n                key: key,\r\n                direction: word.direction,\r\n                clue: clues.get(key)! || \"\",\r\n                entry: getLettersFromSquares(squares),\r\n                isOpenForEditing: false,\r\n            } as CluesViewProp;\r\n            props.push(prop);\r\n        });\r\n        return props;\r\n    }\r\n\r\n    function handleClueClick(event: any) {\r\n        let target = event.target;\r\n        while (![\"clue\"].includes(target.classList[0])) {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n        let targetKey = target.attributes[\"data-key\"].value;\r\n        let refIndex = +target.attributes[\"data-ref-index\"].value;\r\n        let textareaEl = textareasRef.current[refIndex].current;\r\n        \r\n        let newClueProps = deepClone(clueProps) as CluesViewProp[];\r\n        let propToToggle = newClueProps.find(p => p.key === targetKey)!;\r\n        propToToggle.isOpenForEditing = !propToToggle.isOpenForEditing;\r\n        setClueProps(newClueProps);\r\n\r\n        if (propToToggle.isOpenForEditing) {\r\n            textareaEl.value = propToToggle.clue;\r\n            textareaEl.style.display = \"inherit\"; // have to do this before we can autofocus\r\n            textareaEl.focus();\r\n        }\r\n    }\r\n\r\n    function handleKeyDown(event: any) {\r\n        let target = event.target;\r\n        let targetKey: string = target.attributes[\"data-key\"].value;\r\n        let keyPressed: string = event.key.toUpperCase();\r\n\r\n        if (keyPressed === \"ENTER\") {\r\n            applyClueChange(targetKey, target.value);\r\n        }\r\n    }\r\n\r\n    function handleFocus(event: any) {\r\n        event.target.select();\r\n    }\r\n\r\n    function applyClueChange(targetKey: string, newValue: string) {\r\n        let newClueProps = deepClone(clueProps) as CluesViewProp[];\r\n        let targetProp = newClueProps.find(p => p.key === targetKey)!;\r\n        targetProp.clue = newValue === \"(blank clue)\" ? \"\" : newValue;\r\n        targetProp.isOpenForEditing = false;\r\n        Globals.puzzle!.clues.set(targetKey, newValue);\r\n        setClueProps(newClueProps);\r\n    }\r\n\r\n    function renderCluesContainer(isAcross: boolean, clueList: CluesViewProp[], refIndex: number) {\r\n        return (\r\n            <div className=\"clues-container\">\r\n                <div className=\"clues-header\">{isAcross ? \"ACROSS\" : \"DOWN\"}</div>\r\n                <div className=\"clues-clues\">\r\n                    {clueList.map(clue => {\r\n                        textareasRef.current.push(createRef());\r\n                        let ret = (\r\n                            <div key={clue.key}>\r\n                                <div className={\"clue\" + (clue.key === selectedKey ? \" clue-selected\" : \"\")}\r\n                                    data-key={clue.key} onClick={handleClueClick} data-ref-index={refIndex}>\r\n                                    <div className=\"clue-number\">{clue.number}</div>\r\n                                    <div className=\"clue-entry\">{clue.entry}</div>\r\n                                    {clue.entry.length > 15 && <br />}\r\n                                    {clue.clue.length > 0 ? clue.clue : \"(blank clue)\"}\r\n                                </div>\r\n                                <textarea className=\"clue-editor\" defaultValue={clue.clue} data-key={clue.key} \r\n                                    style={{display: clue.isOpenForEditing ? \"inherit\" : \"none\"}}\r\n                                    onKeyDown={handleKeyDown} onFocus={handleFocus}\r\n                                    ref={textareasRef.current[refIndex]}>\r\n                                </textarea>\r\n                            </div>\r\n                        );\r\n                        refIndex++;\r\n                        return ret;\r\n                    })}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    textareasRef.current = [] as any[];\r\n    let acrossClues = clueProps.filter(p => p.direction === WordDirection.Across);\r\n    let downClues = clueProps.filter(p => p.direction === WordDirection.Down);\r\n\r\n    return (\r\n        <div className=\"clues-view\">\r\n            {renderCluesContainer(true, acrossClues, 0)}\r\n            {renderCluesContainer(false, downClues, acrossClues.length)}\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default CluesView;\r\n","import React, { useContext, useState } from 'react';\r\nimport { SymmetryType } from '../../models/SymmetryType';\r\nimport \"./FillView.scss\";\r\nimport Globals from '../../lib/windowService';\r\nimport { FillStatus } from '../../models/FillStatus';\r\nimport { getEntryAtWordKey, getGrid, getSection, getSquaresForWord, mapKeys, mapValues } from '../../lib/util';\r\nimport { calculateSectionOrder, getLongestStackWord, getPhoneticName, insertSectionCandidateIntoGrid, \r\n    makeNewSection, sectionCandidateKey, updateSectionFilters } from '../../lib/section';\r\nimport { clearFill, eraseSectionCandidateFromGrid, getLettersFromSquares, insertEntryIntoGrid, updateGridConstraintInfo, updateManualEntryCandidates } from '../../lib/grid';\r\nimport { fillSectionWord, makeNewNode } from '../../lib/fill';\r\nimport { FillNode } from '../../models/FillNode';\r\nimport { AppContext } from '../../AppContext';\r\nimport { ContentType } from '../../models/ContentType';\r\nimport { Section } from '../../models/Section';\r\nimport { processWordListData } from '../../lib/wordList';\r\nimport { useInterval } from '../../lib/useInterval';\r\nimport { SectionCandidate } from '../../models/SectionCandidate';\r\nimport { QualityClass } from '../../models/QualityClass';\r\n\r\nfunction FillView() {\r\n    const appContext = useContext(AppContext);\r\n    const [showSectionCandidates, setShowSectionCandidates] = useState(true);\r\n    const [isWordListLoading, setIsWordListLoading] = useState(false);\r\n    const [isFillRunning, setIsFillRunning] = useState(false);\r\n\r\n    function triggerUpdate() {\r\n        appContext.triggerUpdate();\r\n    }\r\n\r\n    function setFillStatus(newStatus: FillStatus) {\r\n        Globals.fillStatus = newStatus;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleToggleFill() {\r\n        if (Globals.fillStatus === FillStatus.Complete) return;\r\n\r\n        if (isFillRunning) {\r\n            clearFill(getGrid());\r\n            setFillStatus(FillStatus.Ready);\r\n            setIsFillRunning(false);\r\n            triggerUpdate();\r\n        }\r\n        else {\r\n            setFillStatus(FillStatus.Running);\r\n            setIsFillRunning(true);\r\n        }\r\n    }\r\n    \r\n    function doFillWord() {\r\n        if (Globals.fillStatus === FillStatus.Complete) return;\r\n        if (!fillSectionWord()) {\r\n            clearFill(getGrid());\r\n            setFillStatus(FillStatus.Complete);\r\n            setIsFillRunning(false);\r\n        }\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleFillWordClick(event: any) {\r\n        if (!Globals.wordList) return;\r\n\r\n        if (!fillSectionWord()) {\r\n            clearFill(getGrid());\r\n            setFillStatus(FillStatus.Complete);\r\n        }\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleSymmetryChange(event: any) {\r\n        Globals.gridSymmetry = +SymmetryType[event.target[event.target.selectedIndex].value] as SymmetryType;\r\n    }\r\n\r\n    function handleIffyLengthChange(event: any) {\r\n        Globals.maxIffyLength = +event.target[event.target.selectedIndex].value;\r\n    }\r\n\r\n    function getSymmetryTypeString(type: string): string {\r\n        switch(type) {\r\n            case \"None\": return \"None\";\r\n            case \"Rotate180\": return \"180° Rotational\";\r\n            case \"Rotate90\": return \"90° Rotational\";\r\n            case \"MirrorHorizontal\": return \"Mirror Horizontally\";\r\n            case \"MirrorVertical\": return \"Mirror Vertically\";\r\n            case \"MirrorNWSE\": return \"Mirror NW to SE\";\r\n            case \"MirrorNESW\": return \"Mirror NE to SW\";\r\n        }\r\n        return \"\";\r\n    }\r\n\r\n    function getSymmetryTypesForRectGrids(): string[] {\r\n        return [\"None\", \"Rotate180\", \"MirrorHorizontal\", \"MirrorVertical\"];\r\n    }\r\n\r\n    function getFillStatusString(status: FillStatus): string {\r\n        switch(status) {\r\n            case FillStatus.NoWordList: return \"No Word List Loaded\";\r\n            case FillStatus.Ready: return \"Ready to Fill\";\r\n            case FillStatus.Running: return \"Fill Running...\";\r\n            case FillStatus.Complete: return \"Fill Complete\";\r\n            default: return \"\";\r\n        }\r\n    }\r\n\r\n    function getManualEntryNode(entry: string, iffyWordKey?: string, isHover?: boolean): FillNode {\r\n        let node = Globals.selectedWordNode!;\r\n        let wordKey = Globals.selectedWordKey!;\r\n        insertEntryIntoGrid(node, wordKey, entry, iffyWordKey, isHover ? ContentType.HoverChosenWord : ContentType.ChosenWord);\r\n        return node;\r\n    }\r\n\r\n    function getManualSectionNode(sectionCandidateKey: string, isHover: boolean): FillNode {\r\n        let grid = getGrid();\r\n\r\n        let node = makeNewNode(grid, 0, false, undefined);\r\n        let section = getSection();\r\n        let candidate = section.candidates.get(sectionCandidateKey)!;\r\n        insertSectionCandidateIntoGrid(node.endGrid, candidate, \r\n            isHover ? ContentType.HoverChosenSection : ContentType.ChosenSection);\r\n        return node;\r\n    }\r\n\r\n    function handleEntryCandidateClick(event: any) {\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        if (!Globals.selectedWordKey) return;\r\n\r\n        let entry = target.attributes[\"data-word\"].value as string;\r\n        let iffyWordKey = target.attributes[\"data-iffykey\"].value as string | undefined;\r\n        if (iffyWordKey === \"na\") iffyWordKey = undefined;\r\n        let node = getManualEntryNode(entry, iffyWordKey, false);\r\n\r\n        Globals.manualIffyKey = iffyWordKey;\r\n\r\n        updateManualEntryCandidates(node.endGrid);\r\n\r\n        Globals.activeGrid = node.endGrid;\r\n        updateSectionFilters();\r\n        Globals.hoverGrid = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleEntryCandidateHover(event: any) {\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        if (!Globals.selectedWordKey) return;\r\n\r\n        let entry = target.attributes[\"data-word\"].value as string;\r\n        let iffyWordKey = target.attributes[\"data-iffykey\"].value as string | undefined;\r\n        if (iffyWordKey === \"na\") iffyWordKey = undefined;\r\n        let node = getManualEntryNode(entry, iffyWordKey, true);\r\n\r\n        Globals.hoverGrid = node.endGrid;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleEntryCandidateBlur() {\r\n        Globals.hoverGrid = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleSectionClick(event: any) {\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n            if (target.classList[0] === \"section-checkbox\") return;\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        let sectionId = +target.attributes[\"data-id\"].value;\r\n        clearFill(getGrid());\r\n\r\n        if (sectionId === Globals.activeSectionId!) {\r\n            Globals.activeSectionId = 0;\r\n            Globals.selectedSectionIds = new Map<number, boolean>();\r\n            Globals.selectedSectionIds!.set(sectionId, true);\r\n        }\r\n        else {\r\n            Globals.activeSectionId = sectionId;\r\n            Globals.selectedSectionIds = new Map<number, boolean>();\r\n            Globals.selectedSectionIds!.set(sectionId, true);\r\n        }\r\n\r\n        Globals.hoverGrid = undefined;\r\n        Globals.hoverSectionId = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleSectionCheckClick(event: any) {\r\n        return;\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        let sectionId = +target.attributes[\"data-id\"].value;\r\n        if (Globals.selectedSectionIds!.get(sectionId))\r\n            Globals.selectedSectionIds!.delete(sectionId);\r\n        else\r\n            Globals.selectedSectionIds!.set(sectionId, true);\r\n    }\r\n\r\n    function handleSectionHover(event: any) {\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        let sectionId = +target.attributes[\"data-id\"].value;\r\n        Globals.hoverSectionId = sectionId;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleSectionBlur() {\r\n        Globals.hoverSectionId = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleSectionCandidateClick(event: any) {\r\n        function eraseSc() {\r\n            section.selectedCandidate = undefined;\r\n            section.comboPermsQueue = [];\r\n            section.comboPermsUsed = new Map<string, boolean>();\r\n            let sc = section.candidates.get(candidateKey)!;\r\n            eraseSectionCandidateFromGrid(grid, sc);\r\n            clearFill(grid);\r\n        }\r\n\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        let section = getSection();\r\n        let grid = getGrid();\r\n        let candidateKey = target.attributes[\"data-candidate-key\"].value as string;\r\n\r\n        if (section.selectedCandidate === candidateKey) {\r\n            eraseSc();\r\n        }\r\n        else {\r\n            if (section.selectedCandidate) eraseSc();\r\n\r\n            let node = getManualSectionNode(candidateKey, false);\r\n            Globals.selectedSectionCandidateKeys!.set(section.id, candidateKey);\r\n            section.selectedCandidate = candidateKey;\r\n\r\n            updateManualEntryCandidates(node.endGrid);\r\n\r\n            Globals.activeGrid = node.endGrid;\r\n        }\r\n        \r\n        updateSectionFilters();\r\n        Globals.hoverGrid = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleSectionCandidateHover(event: any) {\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        let candidateKey = target.attributes[\"data-candidate-key\"].value as string;\r\n        let node = getManualSectionNode(candidateKey, true);\r\n\r\n        Globals.hoverGrid = node.endGrid;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleShowSectionCandidatesToggle() {\r\n        setShowSectionCandidates(!showSectionCandidates);\r\n    }\r\n\r\n    function clearSectionCandidates() {\r\n        if (!window.confirm(\"Are you sure you want to clear the fills?\")) return;\r\n\r\n        let section = getSection();\r\n        section.candidates = new Map<string, SectionCandidate>();\r\n        section.selectedCandidate = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleUseHeuristicsToggle() {\r\n        let newValue = Globals.useManualHeuristics !== undefined ? !Globals.useManualHeuristics! : false;\r\n        Globals.useManualHeuristics = newValue;\r\n\r\n        triggerUpdate();\r\n        let node = Globals.selectedWordNode;\r\n        if (!node) return;\r\n\r\n        updateManualEntryCandidates(grid);\r\n    }\r\n\r\n    function handleSectionCandidateBlur() {\r\n        Globals.hoverGrid = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function loadWordList() {\r\n        document.getElementById(\"open-wordlist-input\")!.click();\r\n    }\r\n\r\n    function clearWordLists() {\r\n        if (!window.confirm(\"Are you sure you want to clear the word lists?\")) return;\r\n\r\n        Globals.wordList = undefined;\r\n        Globals.wordLists = [];\r\n        setFillStatus(FillStatus.NoWordList);\r\n        Globals.selectedWordNode = undefined;\r\n        Globals.qualityClasses = new Map<string, QualityClass>();\r\n    }\r\n\r\n    function onWordListUpload(event: any) {\r\n        let file = event.target.files[0];\r\n        event.target.value = null;\r\n        setIsWordListLoading(true);\r\n\r\n        setTimeout(() => {\r\n            processWordListData(file.name, file).then(wordList => {\r\n                if (wordList) {\r\n                    Globals.wordLists!.push(wordList);\r\n                    setFillStatus(FillStatus.Ready);\r\n                    let grid = getGrid();\r\n                    updateGridConstraintInfo(grid);\r\n                    updateManualEntryCandidates(grid);\r\n                    setIsWordListLoading(false);\r\n                    triggerUpdate();\r\n                }\r\n            });\r\n        }, 5);\r\n    }\r\n\r\n    useInterval(() => {\r\n        doFillWord();\r\n    }, isFillRunning ? 5 : null);\r\n\r\n    let grid = getGrid();\r\n    let selectedSymmetry = SymmetryType[Globals.gridSymmetry!];\r\n    let symmetryOptions = (!grid || grid.width === grid.height) ?\r\n        Object.values(SymmetryType).filter(t => isNaN(Number(t))) :\r\n        getSymmetryTypesForRectGrids();\r\n\r\n    let fillStatusStr = getFillStatusString(Globals.fillStatus!);\r\n    \r\n    let wordLists = Globals.wordLists || [];\r\n\r\n    let entryCandidates = Globals.selectedWordNode ? Globals.selectedWordNode.entryCandidates : [];\r\n    let isNoEntryCandidates = Globals.selectedWordNode && entryCandidates.length === 0;\r\n\r\n    let sections = [] as Section[];\r\n    if (Globals.sections!) {\r\n        let sectionsOrder = calculateSectionOrder(mapValues(Globals.sections!));\r\n        sections = sectionsOrder.map(id => Globals.sections!.get(id)!);\r\n    }\r\n    let activeSection = Globals.sections ? Globals.sections!.get(Globals.activeSectionId!)! : makeNewSection(-1);\r\n    let selectedScKey = activeSection.selectedCandidate;\r\n    let selectedSectionIds = mapKeys(Globals.selectedSectionIds!) || [0];\r\n    let sectionCandidates = mapValues(activeSection.candidates)\r\n        .filter(sc => !sc.isFilteredOut).sort((a, b) => b.score - a.score);\r\n    let selectedEntry = Globals.selectedWordKey ? getEntryAtWordKey(grid, Globals.selectedWordKey!) : \"\";\r\n    let selectedMaxIffyLength = Globals.maxIffyLength || 0;\r\n    let useManualHeuristics = Globals.useManualHeuristics !== undefined ? Globals.useManualHeuristics : true;\r\n\r\n    let wordListsStyle = {\r\n        gridTemplateColumns: `4fr 1fr`\r\n    } as React.CSSProperties;\r\n\r\n    let entryCandidatesStyle = {\r\n        gridTemplateColumns: `4fr 1fr 2fr`\r\n    } as React.CSSProperties;\r\n\r\n    let sectionsStyle = {\r\n        gridTemplateColumns: `1fr 2fr 1fr 1fr 1fr`\r\n    } as React.CSSProperties;\r\n\r\n    let fillsStyle = {\r\n        gridTemplateColumns: `4fr 1fr 2fr`\r\n    } as React.CSSProperties;\r\n\r\n    return (\r\n        <div id=\"FillView\" className=\"fill-container\">\r\n            <input id=\"open-wordlist-input\" hidden type=\"file\" accept=\".dict,.txt\" onChange={onWordListUpload} />\r\n            <div id=\"loader\" style={{display: isWordListLoading ? \"block\" : \"none\"}}></div>\r\n\r\n            <div className={\"fill-status\" +\r\n                (Globals.fillStatus! === FillStatus.NoWordList ? \" fill-status-red\" :\r\n                Globals.fillStatus! === FillStatus.Running ? \" fill-status-green\" : \"\")}>{fillStatusStr}</div>\r\n            {wordLists.length > 0 &&\r\n            <>\r\n                <div className=\"custom-control custom-switch fill-switch\">\r\n                    <input type=\"checkbox\" className=\"custom-control-input\" id=\"fillSwitch\" \r\n                        checked={isFillRunning} onChange={handleToggleFill} />\r\n                    <label className=\"custom-control-label\" htmlFor=\"fillSwitch\">Fill</label>\r\n                </div>\r\n                <br />\r\n                Max Iffy Length: <br />\r\n                <select className=\"custom-select iffy-select\" defaultValue={selectedMaxIffyLength} onChange={handleIffyLengthChange}>\r\n                    <option value={0} key={0}>Off</option>\r\n                    {[2, 3, 4, 5, 6, 7].map(length => (\r\n                        <option value={length} key={length}>{length}</option>\r\n                    ))}\r\n                </select>\r\n            </>\r\n            }\r\n            \r\n            <br /><br />\r\n            Grid Symmetry: <br />\r\n            <select className=\"custom-select symmetry-select\" defaultValue={selectedSymmetry} onChange={handleSymmetryChange}>\r\n                {symmetryOptions.map(type => (\r\n                    <option value={type} key={type}>{getSymmetryTypeString(type.toString())}</option>\r\n                ))}\r\n            </select>\r\n            <br /><br />\r\n            <button className=\"btn btn-primary\" onClick={handleFillWordClick} style={{display: \"none\"}}>Fill Word</button>\r\n\r\n            <div className=\"fill-lists\">\r\n                <div className=\"fill-list-box\">\r\n                    <div className=\"fill-list-title\">Word Lists</div>\r\n                    <div className=\"fill-list-button\" onClick={clearWordLists}>Clear</div>\r\n                    <div className=\"fill-list-button\" onClick={loadWordList}>Load</div>\r\n                    <div className=\"fill-list\" style={wordListsStyle}>\r\n                        <div className=\"fill-list-header\">Filename</div>\r\n                        <div className=\"fill-list-header\">Count</div>\r\n                        { wordLists.length === 0 && (\r\n                            <div className=\"fill-list-row-wrapper\" style={{cursor: \"auto\"}}>\r\n                                <div><i>No word lists loaded</i></div><div></div>\r\n                            </div>\r\n                        )}\r\n                        { wordLists.map(wl => (\r\n                            <div className=\"fill-list-row-wrapper\" style={{cursor: \"auto\"}} key={wl.filename}>\r\n                                <div>{wl.filename}</div>\r\n                                <div>{wl.wordCount}</div>\r\n                            </div>\r\n                        ))}\r\n                    </div>\r\n                </div>\r\n                <div className=\"fill-list-box\" onMouseOut={handleEntryCandidateBlur}>\r\n                    <div className=\"fill-list-title entry-color\">Entry Candidates</div>\r\n                    <div className=\"fill-sec-checkbox\">\r\n                        <input type=\"checkbox\" className=\"section-checkbox\" id=\"use-heuristics-box\"\r\n                                    checked={useManualHeuristics} onChange={handleUseHeuristicsToggle} />\r\n                        <label htmlFor=\"use-heuristics-box\">Use heuristics</label>\r\n                    </div>\r\n                    <div className=\"fill-list\" style={entryCandidatesStyle}>\r\n                        <div className=\"fill-list-header\">Entry</div>\r\n                        <div className=\"fill-list-header\">Score</div>\r\n                        <div className=\"fill-list-header\">Iffy</div>\r\n                        { isNoEntryCandidates && useManualHeuristics && (\r\n                            <div className=\"fill-list-row-wrapper\">\r\n                                <div><i>No viable entries</i></div><div></div><div></div>\r\n                            </div>\r\n                        )}\r\n                        { entryCandidates.map(ec => (\r\n                            <div className={\"fill-list-row-wrapper\" + (selectedEntry === ec.word ? \" fill-list-row-selected\" : \"\")} \r\n                                key={ec.word + (ec.iffyEntry || \"\")} data-word={ec.word} data-iffykey={ec.iffyWordKey || \"na\"}\r\n                                onClick={handleEntryCandidateClick} onMouseOver={handleEntryCandidateHover}>\r\n                                <div>{ec.word}</div>\r\n                                <div>{ec.score.toFixed(0)}</div>\r\n                                <div>{ec.iffyEntry || \"\"}</div>\r\n                            </div>\r\n                        ))}\r\n                    </div>\r\n                </div>\r\n                <div className=\"fill-list-box\" onMouseOut={handleSectionBlur}>\r\n                    <div className=\"fill-list-title section-color\">Sections</div>\r\n                    <div className=\"fill-list\" style={sectionsStyle}>\r\n                        <div className=\"fill-list-header\">Active</div>\r\n                        <div className=\"fill-list-header\">ID</div>\r\n                        <div className=\"fill-list-header\">Size</div>\r\n                        <div className=\"fill-list-header\">Conn</div>\r\n                        <div className=\"fill-list-header\">Fills</div>\r\n                        { sections.map(sec => (\r\n                            <div className={\"fill-list-row-wrapper\" + (sec.id === activeSection.id ? \" fill-list-row-selected\" : \"\")} \r\n                                key={sec.id} data-id={sec.id} onClick={handleSectionClick} onMouseOver={handleSectionHover}>\r\n                                <div><input type=\"checkbox\" className=\"section-checkbox\"\r\n                                    checked={selectedSectionIds.includes(sec.id)} onChange={handleSectionCheckClick} /></div>\r\n                                <div>{getPhoneticName(sec.id)}</div>\r\n                                <div>{sec.squares.size}</div>\r\n                                <div>{sec.connections.size}</div>\r\n                                <div>{sec.candidates.size}</div>\r\n                            </div>\r\n                        ))}\r\n                    </div>\r\n                </div>\r\n                <div className=\"fill-list-box\" onMouseOut={handleSectionCandidateBlur}>\r\n                    <div className=\"fill-list-title\">Fills {sectionCandidates.length > 0 ? `(${sectionCandidates.length})` : \"\"}</div>\r\n                    <div className=\"fill-list-button\" onClick={clearSectionCandidates}>Clear</div>\r\n                    <div className=\"fill-sec-checkbox\">\r\n                        <input type=\"checkbox\" className=\"section-checkbox\" id=\"show-fills-box\"\r\n                                    checked={showSectionCandidates} onChange={handleShowSectionCandidatesToggle} />\r\n                        <label htmlFor=\"show-fills-box\">Show</label>\r\n                    </div>\r\n                    <div className=\"fill-list\" style={fillsStyle}>\r\n                        <div className=\"fill-list-header\">Longest</div>\r\n                        <div className=\"fill-list-header\">Score</div>\r\n                        <div className=\"fill-list-header\">Iffy</div>\r\n                        {!showSectionCandidates && (\r\n                            <div className=\"fill-list-row-wrapper\">\r\n                                <div><i>Hidden</i></div><div></div><div></div>\r\n                            </div>\r\n                        )}\r\n                        {showSectionCandidates && Globals.fillStatus === FillStatus.Complete && sectionCandidates.length === 0 && (\r\n                            <div className=\"fill-list-row-wrapper\">\r\n                                <div><i>No fills found</i></div><div></div><div></div>\r\n                            </div>\r\n                        )}\r\n                        {showSectionCandidates && sectionCandidates.map(sc => {\r\n                            let entry = getLettersFromSquares(getSquaresForWord(sc.grid, getLongestStackWord(activeSection)));\r\n                            let candidateKey = sectionCandidateKey(activeSection, sc.grid);\r\n\r\n                            return (\r\n                            <div className={\"fill-list-row-wrapper\" + (selectedScKey === candidateKey ? \" fill-list-row-selected\" : \"\")}\r\n                                key={candidateKey} data-candidate-key={candidateKey}\r\n                                onClick={handleSectionCandidateClick} onMouseOver={handleSectionCandidateHover}>\r\n                                <div>{entry}</div>\r\n                                <div>{sc.score.toFixed(2)}</div>\r\n                                <div>{sc.iffyEntry || \"\"}</div>\r\n                            </div>\r\n                        )})}\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default FillView;\r\n","import { useEffect, useRef } from 'react';\r\n\r\nexport function useInterval(callback: () => void, delay: number | null) {\r\n  const savedCallback = useRef<() => void>();\r\n\r\n  // Remember the latest callback.\r\n  useEffect(() => {\r\n    savedCallback.current = callback;\r\n  }, [callback]);\r\n\r\n  // Set up the interval.\r\n  useEffect(() => {\r\n    function tick() {\r\n      if (savedCallback.current) savedCallback.current();\r\n    }\r\n    if (delay !== null) {\r\n      let id = setInterval(tick, delay);\r\n      return () => clearInterval(id);\r\n    }\r\n  }, [delay]);\r\n}\r\n","import React from 'react';\r\nimport { ContentType } from '../../models/ContentType';\r\nimport { QualityClass } from '../../models/QualityClass';\r\nimport { SquareType } from '../../models/SquareType';\r\nimport { SquareProps } from './SquareProps';\r\n\r\nfunction Square(props: SquareProps) {\r\n    return getSquareElement(props);\r\n}\r\n\r\nfunction getSquareElement(props: SquareProps) {\r\n    let content = props.content || \"\";\r\n    if (props.type === SquareType.White) {\r\n        return <div \r\n                    className={\"grid-square\" + \r\n                        (props.isSelected ? \" grid-square-selected\" : \r\n                        props.isInSelectedWord ? \" grid-square-selected-word\" : \r\n                        props.isInSelectedSection ? \" grid-square-selected-section\" : \"\") +\r\n                        (props.content ? \"\" :\r\n                        props.constraintSum === 0 ? \" grid-square-error-word\" :\r\n                        between(props.constraintSum, 1, 1) ? \" grid-square-constrained-5\" : \r\n                        between(props.constraintSum, 1, 3) ? \" grid-square-constrained-4\" : \r\n                        between(props.constraintSum, 1, 5) ? \" grid-square-constrained-3\" : \r\n                        between(props.constraintSum, 1, 10) ? \" grid-square-constrained-2\" : \r\n                        between(props.constraintSum, 1, 15) ? \" grid-square-constrained-1\" : \"\"\r\n                        )} \r\n                    data-row={props.row} data-col={props.col}>\r\n            {props.isCircled && \r\n                <div className=\"grid-square-circled\"></div>\r\n            }\r\n            <div className=\"grid-number\">{props.number ?? \"\"}</div>\r\n            <div className={\"grid-content\" + \r\n                        (content.length > 1 ? \" grid-content-rebus\" : \"\") +\r\n                        (props.content && props.contentType === ContentType.User ? \"\" :\r\n                         props.content && props.contentType === ContentType.ChosenWord ? \" grid-content-chosen-word\" :\r\n                         props.content && props.contentType === ContentType.HoverChosenWord ? \" grid-content-chosen-word-hover\" :\r\n                         props.content && props.contentType === ContentType.ChosenSection ? \" grid-content-chosen-section\" :\r\n                         props.content && props.contentType === ContentType.HoverChosenSection ? \" grid-content-chosen-section-hover\" :\r\n                         props.qualityClass === QualityClass.Lively ? \" grid-content-lively\" :\r\n                         props.qualityClass === QualityClass.Normal ? \" grid-content-normal\" :\r\n                         props.qualityClass === QualityClass.Crosswordese ? \" grid-content-crosswordese\" :\r\n                         props.qualityClass === QualityClass.Iffy ? \" grid-content-iffy\" :\r\n                         props.qualityClass === QualityClass.NotAThing ? \" grid-content-notathing\" : \"\"\r\n                        )}>\r\n                    {content}\r\n            </div>\r\n        </div>\r\n    }\r\n    else {\r\n        return <div className={\"grid-square-black\" + (props.isSelected ? \" grid-square-black-selected\" : \"\")} \r\n            data-row={props.row} data-col={props.col}>\r\n        </div>\r\n    }\r\n}\r\n\r\nfunction between(input: number, min: number, max: number): boolean {\r\n    return input >= min && input <= max;\r\n}\r\n\r\nexport default Square;\r\n","import React, { useContext, useState } from 'react';\r\nimport { SquareType } from '../../models/SquareType';\r\nimport { SquareProps } from '../Square/SquareProps';\r\nimport \"./Grid.scss\";\r\nimport Square from '../Square/Square';\r\nimport { GridState } from '../../models/GridState';\r\nimport { WordDirection } from '../../models/WordDirection';\r\nimport Globals from '../../lib/windowService';\r\nimport { compareTuples, doesWordContainSquare, getGrid, getSection, getSelectedWord, getSquaresForWord, \r\n    getWordAtSquare, initializeSessionGlobals, isWordFull, mapValues, otherDir, \r\n    squareKey, wordKey } from '../../lib/util';\r\nimport { clearFill, eraseGridSquare, getLettersFromSquares, getSymmetrySquares, getUncheckedSquareDir, populateWords, \r\n    updateGridConstraintInfo, updateManualEntryCandidates } from '../../lib/grid';\r\nimport { GridWord } from '../../models/GridWord';\r\nimport { AppContext } from '../../AppContext';\r\nimport { ContentType } from '../../models/ContentType';\r\nimport { updateSectionFilters } from '../../lib/section';\r\nimport { QualityClass } from '../../models/QualityClass';\r\nimport { GridSquare } from '../../models/GridSquare';\r\nimport { Section } from '../../models/Section';\r\n\r\nfunction Grid() {\r\n    const [selectedSquare, setSelectedSquare] = useState([-1, -1] as [number, number]);\r\n    const appContext = useContext(AppContext);\r\n\r\n    function handleClick(event: any) {\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || ![\"grid-square\", \"grid-square-black\"].includes(target.classList[0])) {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        let row = +target.attributes[\"data-row\"].value;\r\n        let col = +target.attributes[\"data-col\"].value;\r\n        let grid = getGrid();\r\n        \r\n        let newDirection = Globals.selectedWordDir || WordDirection.Across;\r\n\r\n        let uncheckedSquareDir = getUncheckedSquareDir(grid, row, col);\r\n        if (uncheckedSquareDir !== undefined) {\r\n            newDirection = uncheckedSquareDir;\r\n            setSelectedSquare([row, col]);\r\n        }\r\n        else if (compareTuples([row, col], selectedSquare)) {\r\n            newDirection = otherDir(newDirection);\r\n        }\r\n        else {\r\n            setSelectedSquare([row, col]);\r\n        }\r\n\r\n        Globals.selectedWordDir = newDirection;\r\n        setSelWordAtSelSquare([row, col]);\r\n\r\n        updateManualEntryCandidates(grid);\r\n\r\n        appContext.triggerUpdate();\r\n    }\r\n    \r\n    function handleKeyDown(event: any) {\r\n        if (!isSquareSelected()) return;\r\n\r\n        let grid = getGrid();\r\n        let row = selectedSquare[0];\r\n        let col = selectedSquare[1];\r\n\r\n        let key: string = event.key.toUpperCase();\r\n        let letterChanged = false;\r\n        let blackSquareChanged = false;\r\n        let sq = grid.squares[row][col];\r\n        let newSelSq = [-1,-1] as [number, number];\r\n\r\n        if (key.match(/^[A-Z]$/)) {\r\n            newSelSq = advanceCursor();\r\n\r\n            if (sq.type === SquareType.Black) return;\r\n            if (sq.content === key && sq.contentType === ContentType.User) return;\r\n\r\n            letterChanged = true;\r\n            if (sq.content !== key && sq.contentType !== ContentType.User)\r\n                eraseGridSquare(grid, sq, Globals.selectedWordDir!);\r\n\r\n            sq = grid.squares[row][col];\r\n            sq.content = key;\r\n            sq.contentType = ContentType.User;\r\n        }\r\n        if (key === \"BACKSPACE\") {\r\n            newSelSq = backupCursor();\r\n\r\n            if (sq.content !== undefined) {\r\n                eraseGridSquare(grid, sq, Globals.selectedWordDir!);\r\n                letterChanged = true;\r\n            }\r\n                \r\n            if (sq.type === SquareType.Black) {\r\n                getSymmetrySquares([row, col]).forEach(res => {\r\n                    let resSq = grid.squares[res[0]][res[1]];\r\n                    resSq.type = SquareType.White;\r\n                });\r\n\r\n                blackSquareChanged = true;\r\n            }\r\n        }\r\n        // toggle black square\r\n        if (key === \".\") {\r\n            newSelSq = advanceCursor();\r\n\r\n            eraseGridSquare(grid, sq, Globals.selectedWordDir!);\r\n\r\n            let newSquareType = sq.type === SquareType.White ? SquareType.Black : SquareType.White;\r\n            getSymmetrySquares([row, col]).forEach(res => {\r\n                let resSq = grid.squares[res[0]][res[1]];\r\n                resSq.type = newSquareType;\r\n            });\r\n\r\n            blackSquareChanged = true;\r\n        }\r\n        // toggle circled square\r\n        if (key === \",\") {\r\n            if (sq.type === SquareType.Black) return;\r\n            sq.isCircled = !sq.isCircled;\r\n            newSelSq = advanceCursor();\r\n            setSelWordAtSelSquare(newSelSq);\r\n        }\r\n\r\n        if (blackSquareChanged) {\r\n            populateWords(grid);\r\n            initializeSessionGlobals();\r\n            clearFill(grid);\r\n            setSelWordAtSelSquare(newSelSq);\r\n            updateGridConstraintInfo(grid);\r\n        }\r\n        else if (letterChanged)  {\r\n            updateSectionFilters();\r\n            updateGridConstraintInfo(grid);\r\n        }\r\n\r\n        updateManualEntryCandidates(grid);\r\n\r\n        appContext.triggerUpdate();\r\n    }\r\n\r\n    function advanceCursor(): [number, number] {\r\n        let selSq = selectedSquare;\r\n        if (!isSquareSelected()) return selSq;\r\n    \r\n        let grid = getGrid();\r\n        let dir = Globals.selectedWordDir!;\r\n        if ((dir === WordDirection.Across && selSq[1] === grid.width-1) || (dir === WordDirection.Down && selSq[0] === grid.height-1))\r\n            return selSq;\r\n\r\n        let newSelSq = (dir === WordDirection.Across ? [selSq[0], selSq[1] + 1] : [selSq[0] + 1, selSq[1]]) as [number, number];\r\n        setSelectedSquare(newSelSq);\r\n        setSelWordAtSelSquare(newSelSq);\r\n        return newSelSq;\r\n    }\r\n    \r\n    function backupCursor(): [number, number] {\r\n        let selSq = selectedSquare;\r\n        if (!isSquareSelected()) return selSq;\r\n    \r\n        let dir = Globals.selectedWordDir!;\r\n        if ((dir === WordDirection.Across && selSq[1] === 0) || (dir === WordDirection.Down && selSq[0] === 0))\r\n            return selSq;\r\n\r\n        let newSelSq = (dir === WordDirection.Across ? [selSq[0], selSq[1] - 1] : [selSq[0] - 1, selSq[1]]) as [number, number];\r\n        setSelectedSquare(newSelSq);\r\n        setSelWordAtSelSquare(newSelSq);\r\n        return newSelSq;\r\n    }\r\n\r\n    function isSquareSelected(): boolean {\r\n        return selectedSquare[0] > -1;\r\n    }\r\n    \r\n    function isWordSelected(): boolean {\r\n        return !!getSelectedWord();\r\n    }\r\n\r\n    function isSquareInSection(section: Section, sq: GridSquare): boolean {\r\n        return section.squares.has(squareKey(sq));\r\n    }\r\n\r\n    function setSelWordAtSelSquare(newSelSquare: [number, number]) {\r\n        let grid = getGrid();\r\n        let word = getWordAtSquare(grid, newSelSquare[0], newSelSquare[1], Globals.selectedWordDir!);\r\n        Globals.selectedWordKey = word ? wordKey(word) : undefined;\r\n    }\r\n\r\n    function getSquareProps(grid: GridState, row: number, col: number, \r\n        selectedSquare: [number, number], selectedWord: GridWord | undefined): SquareProps {\r\n        let square = grid.squares[row][col];\r\n    \r\n        return {\r\n            key: `${row},${col}`,\r\n            row: row,\r\n            col: col,\r\n            number: square.number,\r\n            type: square.type,\r\n            content: square.content,\r\n            contentType: square.contentType,\r\n            qualityClass: qualityClassMap.get(squareKey(square)) || QualityClass.Normal,\r\n            isSelected: isSquareSelected() && compareTuples(selectedSquare, [row, col]),\r\n            isInSelectedWord: isWordSelected() && doesWordContainSquare(selectedWord!, row, col),\r\n            isInSelectedSection: (Globals.activeSectionId !== 0 && isSquareInSection(getSection(), square)) ||\r\n                (Globals.hoverSectionId !== undefined && isSquareInSection(Globals.sections!.get(Globals.hoverSectionId)!, square)),\r\n            constraintSum: square.viableLetters ? square.viableLetters.length : 26,\r\n            isCircled: square.isCircled,\r\n        };\r\n    }\r\n\r\n    function getSquareElement(props: SquareProps) {\r\n        return <Square {...props}></Square>\r\n    }\r\n\r\n    function suppressEnterKey(event: any) {\r\n        let keyPressed: string = event.key.toUpperCase();\r\n\r\n        if (keyPressed === \"ENTER\") {\r\n            event.preventDefault();\r\n        }\r\n    }\r\n\r\n    function handleFocus(event: any) {\r\n        selectElementContents(event.target);\r\n    }\r\n\r\n    // https://stackoverflow.com/questions/6139107/programmatically-select-text-in-a-contenteditable-html-element/6150060#6150060\r\n    function selectElementContents(el: any) {\r\n        var range = document.createRange();\r\n        range.selectNodeContents(el);\r\n        var sel = window.getSelection();\r\n        sel!.removeAllRanges();\r\n        sel!.addRange(range);\r\n    }\r\n\r\n    function setTitle() {\r\n        let newTitle = document.getElementById(\"puzzleTitle\")!.innerText;\r\n        Globals.puzzle!.title = newTitle === \"(title)\" ? \"Untitled\" : newTitle;\r\n    }\r\n\r\n    function setAuthor() {\r\n        let newAuthor = document.getElementById(\"puzzleAuthor\")!.innerText;\r\n        Globals.puzzle!.author = newAuthor === \"(author)\" ? \"\" : newAuthor;\r\n    }\r\n\r\n    function setCopyright() {\r\n        let newCopyright = document.getElementById(\"puzzleCopyright\")!.innerText;\r\n        Globals.puzzle!.copyright = newCopyright === \"© copyright\" ? \"\" : newCopyright;\r\n    }\r\n\r\n    function setNotes() {\r\n        let newNotes = document.getElementById(\"puzzleNotes\")!.innerText;\r\n        Globals.puzzle!.notes = newNotes === \"(notes)\" ? \"\" : newNotes;\r\n    }\r\n\r\n    function generateQualityClassMap(grid: GridState): Map<string, QualityClass> {\r\n        let ret = new Map<string, QualityClass>();\r\n\r\n        let acrossWords = mapValues(grid.words).filter(w => w.direction === WordDirection.Across);\r\n        acrossWords.forEach(w => {\r\n            let squares = getSquaresForWord(grid, w);\r\n            if (isWordFull(squares)) {\r\n                let letters = getLettersFromSquares(squares);\r\n                let qc = Globals.qualityClasses ? Globals.qualityClasses!.get(letters) : QualityClass.Normal;\r\n                squares.forEach(sq => {\r\n                    if (sq.contentType === ContentType.Autofill)\r\n                        ret.set(squareKey(sq), qc || QualityClass.Iffy);\r\n                });\r\n            }\r\n        });\r\n\r\n        let downWords = mapValues(grid.words).filter(w => w.direction === WordDirection.Down);\r\n        downWords.forEach(w => {\r\n            let squares = getSquaresForWord(grid, w);\r\n            if (isWordFull(squares)) {\r\n                let letters = getLettersFromSquares(squares);\r\n                let qc = Globals.qualityClasses ? Globals.qualityClasses!.get(letters) : QualityClass.Normal;\r\n                squares.forEach(sq => {\r\n                    if (sq.contentType === ContentType.Autofill) {\r\n                        let curQc = ret.get(squareKey(sq)) || QualityClass.Normal;\r\n                        if (!qc || qc < curQc)\r\n                            ret.set(squareKey(sq), qc || QualityClass.Iffy);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n\r\n        return ret;\r\n    }\r\n\r\n    let puzzle = Globals.puzzle!;\r\n    let grid = Globals.hoverGrid ? Globals.hoverGrid! : getGrid();\r\n    let qualityClassMap = generateQualityClassMap(grid);\r\n\r\n    let squareElements = [];\r\n    for (let row = 0; row < grid.height; row++) {\r\n        for (let col = 0; col < grid.width; col++) {\r\n            let sqProps = getSquareProps(grid, row, col, selectedSquare, getSelectedWord());\r\n            squareElements.push(getSquareElement(sqProps));\r\n        }\r\n    }\r\n\r\n    let columnTemplateStyle = {\r\n        gridTemplateColumns: `repeat(${grid.width}, 1fr)`\r\n    } as React.CSSProperties;\r\n\r\n    return (\r\n        <>\r\n            <div className=\"puzzle-author-by\">&nbsp;</div>\r\n            <div id=\"puzzleTitle\" className=\"puzzle-title editable\" contentEditable={true} suppressContentEditableWarning={true}\r\n                onKeyDown={suppressEnterKey} onBlur={setTitle} onFocusCapture={handleFocus}>{puzzle.title || \"(title)\"}</div>\r\n            <div className=\"puzzle-author-by\">by&nbsp;</div>\r\n            <div id=\"puzzleAuthor\" className=\"puzzle-author editable\" contentEditable={true} suppressContentEditableWarning={true}\r\n                onKeyDown={suppressEnterKey} onBlur={setAuthor} onFocusCapture={handleFocus}>{puzzle.author || \"(author)\"}</div>\r\n            <div className=\"puzzle-author-by\">&nbsp;</div>\r\n            <div id=\"puzzleCopyright\" className=\"puzzle-copyright editable\" contentEditable={true} suppressContentEditableWarning={true}\r\n                onKeyDown={suppressEnterKey} onBlur={setCopyright} onFocusCapture={handleFocus}>{puzzle.copyright || \"© copyright\"}</div>\r\n            \r\n            <div id=\"Grid\" className=\"grid-container\" style={columnTemplateStyle}\r\n                onClick={handleClick} onKeyDown={handleKeyDown} tabIndex={0}>\r\n                {squareElements}\r\n            </div>\r\n\r\n            <div className=\"puzzle-notes-label\">Notes:</div>\r\n            <div id=\"puzzleNotes\" className=\"puzzle-notes editable\" contentEditable={true} suppressContentEditableWarning={true}\r\n                onKeyDown={suppressEnterKey} onBlur={setNotes} onFocusCapture={handleFocus}>{puzzle.notes || \"(notes)\"}</div>\r\n        </>\r\n    );\r\n}\r\n\r\nexport default Grid;\r\n","import { ContentType } from \"../models/ContentType\";\r\nimport { GridWord } from \"../models/GridWord\";\r\nimport { Puzzle } from \"../models/Puzzle\";\r\nimport { SquareType } from \"../models/SquareType\";\r\nimport { WordDirection } from \"../models/WordDirection\";\r\nimport { createNewGrid, populateWords } from \"./grid\";\r\nimport { deepClone, getGrid, mapValues, newPuzzle, wordKey } from \"./util\";\r\nimport Globals from '../lib/windowService';\r\n\r\n// https://code.google.com/archive/p/puz/wikis/FileFormat.wiki\r\n\r\nexport async function loadPuzFile(url: string): Promise<Puzzle | undefined> {\r\n    let response = await fetch(url);\r\n    let data: Blob = await response.blob();\r\n\r\n    return processPuzData(data);\r\n}\r\n\r\nexport async function processPuzData(data: Blob): Promise<Puzzle | undefined> {\r\n    let magicString = await data.slice(0x02, 0x0e).text();\r\n    if (magicString !== \"ACROSS&DOWN\\0\") return undefined;\r\n\r\n    let width = new Uint8Array(await data.slice(0x2c, 0x2d).arrayBuffer())[0];\r\n    let height = new Uint8Array(await data.slice(0x2d, 0x2e).arrayBuffer())[0];\r\n\r\n    let puzzle = newPuzzle();\r\n    let restOfFile = await blobToText(await data.slice(0x34, data.size));\r\n    let grid = createNewGrid(width, height);\r\n\r\n    let i = 0;\r\n    for (let row = 0; row < height; row++) {\r\n        for (let col = 0; col < width; col++) {\r\n            let curChar = restOfFile[i];\r\n            let square = grid.squares[row][col];\r\n            if (curChar === \".\")\r\n                square.type = SquareType.Black;\r\n            if (curChar === \"-\") {} // no data entered\r\n            if (curChar.match(/[A-Z]/)) {\r\n                square.content = curChar;\r\n                square.contentType = ContentType.User;\r\n            }\r\n            i++;\r\n        }\r\n    }\r\n    i *= 2; // skip over user progress\r\n\r\n    populateWords(grid);\r\n    \r\n    [puzzle.title, i] = getNextString(restOfFile, i);\r\n    [puzzle.author, i] = getNextString(restOfFile, i);\r\n    [puzzle.copyright, i] = getNextString(restOfFile, i);\r\n\r\n    let sortedWords = sortWordsForPuz(mapValues(grid.words));\r\n    sortedWords.forEach(word => {\r\n        let clue = \"\";\r\n        [clue, i] = getNextString(restOfFile, i);\r\n        let key = wordKey(word);\r\n        puzzle.clues.set(key, clue);\r\n    });\r\n\r\n    [puzzle.notes, i] = getNextString(restOfFile, i);\r\n\r\n    let rebusSquareMappings = new Map<string, number>();\r\n    let rebusValues = new Map<number, string>();\r\n\r\n    while (i < restOfFile.length) {\r\n        let sectionType = restOfFile.slice(i, i+4);\r\n        i += 4;\r\n        let dlI = 0x34 + i;\r\n        let dataLength = new Uint16Array(await data.slice(dlI, dlI+2).arrayBuffer())[0];\r\n        i += 2;\r\n        i += 2; // skip checksum\r\n\r\n        if (sectionType === \"GRBS\") { // rebus grid\r\n            let secI = 0x34 + i;\r\n            for (let row = 0; row < height; row++) {\r\n                for (let col = 0; col < width; col++) {\r\n                    let n = new Uint8Array(await data.slice(secI, secI + 1).arrayBuffer())[0];\r\n                    secI++;\r\n                    if (n > 0) {\r\n                        rebusSquareMappings.set(`${row},${col}`, n-1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (sectionType === \"RTBL\") { // rebus values\r\n            let valuesStr = restOfFile.slice(i, i + dataLength);\r\n            let valueStrs = valuesStr.split(\";\");\r\n            valueStrs.forEach(str => {\r\n                let tokens = str.split(\":\");\r\n                let n = +tokens[0].trim();\r\n                let val = tokens[1];\r\n                if (n > 0) rebusValues.set(n, val);\r\n            });\r\n        }\r\n        if (sectionType === \"GEXT\") { // extra flags\r\n            let secI = 0x34 + i;\r\n            for (let row = 0; row < height; row++) {\r\n                for (let col = 0; col < width; col++) {\r\n                    let n = new Uint8Array(await data.slice(secI, secI + 1).arrayBuffer())[0];\r\n                    secI++;\r\n                    if (n & 0x80) {\r\n                        grid.squares[row][col].isCircled = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        i += dataLength + 1;\r\n    }\r\n\r\n    if (rebusSquareMappings.size > 0) {\r\n        rebusSquareMappings.forEach((v, k) => {\r\n            let tokens = k.split(\",\");\r\n            let square = grid.squares[+tokens[0]][+tokens[1]];\r\n            square.content = rebusValues.get(v)![0]; // TODO: Use full value when we have rebus support\r\n            square.contentType = ContentType.User;\r\n        });\r\n    }\r\n\r\n    Globals.activeGrid = grid;\r\n    return puzzle;\r\n}\r\n\r\nasync function blobToText(blob: Blob): Promise<string> {\r\n    let arr = Array.from(new Uint8Array(await blob.arrayBuffer()));\r\n    return arr.map(x => String.fromCharCode(x)).join(\"\");\r\n}\r\n\r\nfunction getNextString(data: string, i: number): [string, number] {\r\n    let ret = \"\";\r\n    while(data[i] !== \"\\0\") {\r\n        ret += data[i];\r\n        i++;\r\n    }\r\n    i++;\r\n    return [ret.trim(), i];\r\n}\r\n\r\nexport function generatePuzFile(puzzle: Puzzle): Blob {\r\n    let grid = getGrid();\r\n    let bytes = new Uint8Array(128_000);\r\n    insertString(bytes, \"ACROSS&DOWN\\0\", 0x02);\r\n    insertString(bytes, \"1.3\\0\", 0x18);\r\n\r\n    insertNumber(bytes, grid.width, 0x2c, 1);\r\n    insertNumber(bytes, grid.height, 0x2d, 1);\r\n    insertNumber(bytes, grid.words.size, 0x2e, 2);\r\n    insertNumber(bytes, 1, 0x30, 2);\r\n    insertNumber(bytes, 0, 0x32, 2);\r\n\r\n    let pos = 0x34;\r\n    let solutionPos = pos;\r\n    let areCircledSquares = false;\r\n    for (let row = 0; row < grid.height; row++) {\r\n        for (let col = 0; col < grid.width; col++) {\r\n            let sq = grid.squares[row][col];\r\n            let char = sq.type === SquareType.Black ? \".\" : sq.content ? sq.content : \" \";\r\n            insertString(bytes, char, pos);\r\n            pos++;\r\n\r\n            if (sq.isCircled) areCircledSquares = true;\r\n        }\r\n    }\r\n    let gridPos = pos;\r\n    for (let row = 0; row < grid.height; row++) {\r\n        for (let col = 0; col < grid.width; col++) {\r\n            let sq = grid.squares[row][col];\r\n            let char = sq.type === SquareType.Black ? \".\" : \"-\";\r\n            insertString(bytes, char, pos);\r\n            pos++;\r\n        }\r\n    }\r\n\r\n    let titlePos = pos;\r\n    insertString(bytes, puzzle.title + \"\\0\", pos);\r\n    pos += puzzle.title.length + 1;\r\n    let authorPos = pos;\r\n    insertString(bytes, puzzle.author + \"\\0\", pos);\r\n    pos += puzzle.author.length + 1;\r\n    let copyrightPos = pos;\r\n    insertString(bytes, puzzle.copyright + \"\\0\", pos);\r\n    pos += puzzle.copyright.length + 1;\r\n\r\n    let orderedClues = [] as string[];\r\n    let sortedWords = sortWordsForPuz(mapValues(grid.words));\r\n    sortedWords.forEach(word => {\r\n        let key = wordKey(word);\r\n        orderedClues.push(puzzle.clues.get(key)! || \"\");\r\n    });\r\n\r\n    let cluesPos = pos;\r\n    orderedClues.forEach(oc => {\r\n        insertString(bytes, oc + \"\\0\", pos);\r\n        pos += oc.length + 1;\r\n    });\r\n\r\n    insertString(bytes, puzzle.notes + \"\\0\", pos);\r\n    pos++;\r\n\r\n    if (areCircledSquares) {\r\n        let sectionSize = grid.width * grid.height;\r\n        insertString(bytes, \"GEXT\", pos);\r\n        pos += 4;\r\n        insertNumber(bytes, sectionSize, pos, 2);\r\n        pos += 2;\r\n        let checksumPos = pos;\r\n        pos += 2;\r\n        for (let row = 0; row < grid.height; row++) {\r\n            for (let col = 0; col < grid.width; col++) {\r\n                let sq = grid.squares[row][col];\r\n                insertNumber(bytes, sq.isCircled ? 0x80 : 0, pos, 1);\r\n                pos++;\r\n            }\r\n        }\r\n        insertString(bytes, \"\\0\", pos);\r\n        pos++;\r\n\r\n        let cksum = cksum_region(bytes, checksumPos + 2, sectionSize, 0);\r\n        insertNumber(bytes, cksum, checksumPos, 2);\r\n    }\r\n\r\n    let c_cib = cksum_region(bytes, 0x2c, 8, 0);\r\n    let cksum = c_cib;\r\n    let squaresTotal = grid.width*grid.height;\r\n    cksum = cksum_region(bytes, solutionPos, squaresTotal, cksum);\r\n    cksum = cksum_region(bytes, gridPos, squaresTotal, cksum);\r\n    if (puzzle.title.length > 0) cksum = cksum_region(bytes, titlePos, puzzle.title.length+1, cksum);\r\n    if (puzzle.author.length > 0) cksum = cksum_region(bytes, authorPos, puzzle.author.length+1, cksum);\r\n    if (puzzle.copyright.length > 0) cksum = cksum_region(bytes, copyrightPos, puzzle.copyright.length+1, cksum);\r\n    let cluePos = cluesPos;\r\n    for(let i = 0; i < orderedClues.length; i++) {\r\n        let clue = orderedClues[i];\r\n        cksum = cksum_region(bytes, cluePos, clue.length, cksum);\r\n        cluePos += clue.length+1;\r\n    }\r\n    insertNumber(bytes, c_cib, 0x0e, 2);\r\n    insertNumber(bytes, cksum, 0x00, 2);\r\n\r\n    let c_sol = cksum_region(bytes, solutionPos, squaresTotal, 0);\r\n    let c_grid = cksum_region(bytes, gridPos, squaresTotal, 0);\r\n    let c_part = 0;\r\n    if (puzzle.title.length > 0) c_part = cksum_region(bytes, titlePos, puzzle.title.length+1, c_part);\r\n    if (puzzle.author.length > 0) c_part= cksum_region(bytes, authorPos, puzzle.author.length+1, c_part);\r\n    if (puzzle.copyright.length > 0) c_part = cksum_region(bytes, copyrightPos, puzzle.copyright.length+1, c_part);\r\n    cluePos = cluesPos;\r\n    for(let i = 0; i < orderedClues.length; i++) {\r\n        let clue = orderedClues[i];\r\n        c_part = cksum_region(bytes, cluePos, clue.length, c_part);\r\n        cluePos += clue.length+1;\r\n    }\r\n    insertNumber(bytes, 0x49 ^ (c_cib & 0xFF), 0x10, 1);\r\n    insertNumber(bytes, 0x43 ^ (c_sol & 0xFF), 0x11, 1);\r\n    insertNumber(bytes, 0x48 ^ (c_grid & 0xFF), 0x12, 1);\r\n    insertNumber(bytes, 0x45 ^ (c_part & 0xFF), 0x13, 1);\r\n    insertNumber(bytes, 0x41 ^ ((c_cib & 0xFF00) >> 8), 0x14, 1);\r\n    insertNumber(bytes, 0x54 ^ ((c_sol & 0xFF00) >> 8), 0x15, 1);\r\n    insertNumber(bytes, 0x45 ^ ((c_grid & 0xFF00) >> 8), 0x16, 1);\r\n    insertNumber(bytes, 0x44 ^ ((c_part & 0xFF00) >> 8), 0x17, 1);\r\n\r\n    let finalArray = bytes.slice(0, pos);\r\n    return new Blob([finalArray], {type: \"application/octet-stream; charset=ISO-8859-1\"});\r\n}\r\n\r\n// http://www.keiranking.com/phil/\r\nfunction cksum_region(bytes: Uint8Array, startPos: number, len: number, cksum: number) {\r\n    for (let i = 0; i < len; i++) {\r\n        cksum = (cksum >> 1) | ((cksum & 1) << 15);\r\n        cksum = (cksum + bytes[startPos + i]) & 0xffff;\r\n    }\r\n    \r\n    return cksum; \r\n}\r\n\r\nfunction insertString(bytes: Uint8Array, str: string, pos: number) {\r\n    for (let i = 0; i < str.length; i++) {\r\n        bytes[pos] = str[i].charCodeAt(0);\r\n        pos++;\r\n    }\r\n}\r\n\r\nfunction insertNumber(bytes: Uint8Array, n: number, pos: number, size: number) {\r\n    for (var index = size-1; index >= 0; --index) {\r\n      bytes[pos] = n % 256;\r\n      n = n >> 8;\r\n      pos++;\r\n    }\r\n}\r\n\r\nfunction sortWordsForPuz(words: GridWord[]): GridWord[] {\r\n    let sortedWords = (deepClone(words) as GridWord[]).sort((a, b) => {\r\n        if (a.start[0] !== b.start[0]) return a.start[0] - b.start[0];\r\n        if (a.start[1] !== b.start[1]) return a.start[1] - b.start[1];\r\n        return a.direction === WordDirection.Across ? -1 : 1;\r\n    });\r\n    return sortedWords;\r\n}\r\n","import React, { createRef, useContext, useRef } from 'react';\r\nimport \"./Menu.scss\";\r\nimport { MenuProps } from './MenuProps';\r\nimport { AppContext } from '../../AppContext';\r\nimport { processPuzData } from '../../lib/puzFiles';\r\n\r\nfunction Menu(props: MenuProps) {\r\n    const appContext = useContext(AppContext);\r\n    const sizeRefs = useRef([createRef(), createRef()] as any[]);\r\n\r\n    function handleViewChange(event: any) {\r\n        let target = event.target;\r\n        let newView = target.attributes[\"data-view-id\"].value;\r\n        \r\n        appContext.switchActiveView(newView);\r\n    }\r\n\r\n    function handleNewPuzzle() {\r\n        if (!window.confirm(\"Are you sure you want to start a new puzzle?\")) return;\r\n\r\n        let newWidth = +sizeRefs.current[0].current.value;\r\n        let newHeight = +sizeRefs.current[1].current.value;\r\n\r\n        appContext.createNewPuzzle(newWidth, newHeight);\r\n    }\r\n\r\n    function handleLoadPuz() {\r\n        document.getElementById(\"open-puzzle-input\")!.click();\r\n    }\r\n\r\n    function handleExportPuz() {\r\n        appContext.exportPuz();\r\n    }\r\n\r\n    function handleFocus(event: any) {\r\n        event.target.select();\r\n    }\r\n\r\n    function onFileUpload(event: any) {\r\n        let file = event.target.files[0];\r\n        event.target.value = null;\r\n\r\n        processPuzData(file).then(puzzle => {\r\n            if (puzzle) {\r\n                appContext.setPuzzle(puzzle);\r\n            }\r\n        });\r\n    }\r\n\r\n    return (\r\n        <div id=\"Menu\">\r\n            <input id=\"open-puzzle-input\" hidden type=\"file\" accept=\".puz\" onChange={onFileUpload} />\r\n\r\n            <div className=\"site-title\">CrossHatch</div>\r\n\r\n            <div className=\"menu-label\">View: </div>\r\n            <div className=\"btn-group\" role=\"group\" id=\"view-change-group\">\r\n                <button type=\"button\" data-view-id=\"Clues\"\r\n                    className={\"btn\" + (props.openView === \"Clues\" ? \" btn-primary\" : \" btn-secondary\")}\r\n                    onClick={handleViewChange}>\r\n                    Clues\r\n                </button>\r\n                <button type=\"button\" data-view-id=\"Fill\"\r\n                    className={\"btn\" + (props.openView === \"Fill\" ? \" btn-primary\" : \" btn-secondary\")}\r\n                    onClick={handleViewChange}>\r\n                    Fill\r\n                </button>\r\n            </div>\r\n            \r\n            <div className=\"new-grid-group\">\r\n                <div className=\"btn btn-primary\" onClick={handleNewPuzzle}>New Puzzle</div>\r\n                <input type=\"text\" className=\"form-control\" defaultValue={props.gridWidth} onFocus={handleFocus}\r\n                    ref={sizeRefs.current[0]}></input>\r\n                <div className=\"menu-gridsize-sep\"><div style={{height:\"6px\", float:\"none\"}}></div>x</div>\r\n                <input type=\"text\" className=\"form-control\" defaultValue={props.gridHeight} onFocus={handleFocus}\r\n                    ref={sizeRefs.current[1]}></input>\r\n            </div>\r\n            \r\n            <div id=\"loadPuz\" className=\"btn btn-primary menu-button\" onClick={handleLoadPuz}>Load .puz</div>\r\n            <div id=\"exportPuz\" className=\"btn btn-primary menu-button\" onClick={handleExportPuz}>Export .puz</div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Menu;\r\n","import React, { useEffect, useState } from 'react';\r\nimport { AppContext } from './AppContext';\r\nimport { AppProps } from './AppProps';\r\nimport CluesView from './components/CluesView/CluesView';\r\nimport FillView from './components/FillView/FillView';\r\nimport Grid from './components/Grid/Grid';\r\nimport Menu from './components/Menu/Menu';\r\nimport Globals from './lib/windowService';\r\nimport \"./App.scss\";\r\nimport { Puzzle } from './models/Puzzle';\r\nimport { getGrid, initializeSessionGlobals, newPuzzle } from './lib/util';\r\nimport { generatePuzFile } from './lib/puzFiles';\r\nimport { SymmetryType } from './models/SymmetryType';\r\nimport { clearFill, createNewGrid } from './lib/grid';\r\nimport { WordDirection } from './models/WordDirection';\r\nimport { FillStatus } from './models/FillStatus';\r\n\r\nfunction App(props: AppProps) {\r\n  const [activeView, setActiveView] = useState(props.activeView);\r\n  const [gridWidth, setGridWidth] = useState(7);\r\n  const [gridHeight, setGridHeight] = useState(7);\r\n  const [updateSemaphore, setUpdateSemaphore] = useState(0);\r\n  const [appState, setAppState] = useState(getAppContext());\r\n\r\n  useEffect(() => {\r\n    setAppState(getAppContext());\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [updateSemaphore]);\r\n\r\n  function getAppContext() {\r\n    return { \r\n      triggerUpdate: triggerUpdate,\r\n      switchActiveView: switchActiveView,\r\n      setPuzzle: setPuzzle,\r\n      createNewPuzzle: createNewPuzzle,\r\n      exportPuz: exportPuz,\r\n    }\r\n  }\r\n\r\n  function triggerUpdate() {\r\n    setUpdateSemaphore(updateSemaphore + 1);\r\n  }\r\n\r\n  function switchActiveView(newView: string) {\r\n    setActiveView(newView);\r\n  }\r\n\r\n  function createNewPuzzle(width: number, height: number) {\r\n    initializeGlobals(undefined, width, height);\r\n    triggerUpdate();\r\n  }\r\n\r\n  function setPuzzle(puzzle: Puzzle) {\r\n    let grid = getGrid();\r\n    initializeGlobals(puzzle, grid.width, grid.height);\r\n    triggerUpdate();\r\n  }\r\n\r\n  function exportPuz() {\r\n    let puzzle = Globals.puzzle!;\r\n    let blob = generatePuzFile(puzzle);\r\n    let filename = (puzzle.title || \"Untitled\")+\".puz\";\r\n    let file = new File([blob], filename);\r\n    const url= window.URL.createObjectURL(file);\r\n    let puzzleLink = document.getElementById(\"download-puzzle-link\");\r\n    puzzleLink!.setAttribute(\"href\", url);\r\n    puzzleLink!.setAttribute(\"download\", filename);\r\n    puzzleLink!.click();\r\n  }\r\n\r\n  function initializeGlobals(puzzle?: Puzzle, width?: number, height?: number) {\r\n    let isNewPuzzle = !!puzzle;\r\n    Globals.puzzle = puzzle || newPuzzle();\r\n    if (width === undefined) width = gridWidth;\r\n    if (height === undefined) height = gridHeight;\r\n    if (!Globals.activeGrid || !isNewPuzzle)\r\n      Globals.activeGrid = createNewGrid(width, height);\r\n    Globals.hoverGrid = undefined;\r\n    Globals.selectedWordKey = undefined;\r\n    Globals.selectedWordDir = WordDirection.Across;\r\n    if (!Globals.gridSymmetry) Globals.gridSymmetry = SymmetryType.Rotate180;\r\n    if (Globals.useManualHeuristics === undefined) Globals.useManualHeuristics = true;\r\n    if (Globals.maxIffyLength === undefined) Globals.maxIffyLength = 0;\r\n    Globals.selectedWordNode = undefined;\r\n    Globals.curChainId = 1;\r\n    if (Globals.wordLists === undefined) Globals.wordLists = [];\r\n    Globals.fillStatus = Globals.wordList !== undefined ? FillStatus.Ready : FillStatus.NoWordList;\r\n\r\n    initializeSessionGlobals();\r\n    clearFill(Globals.activeGrid!);\r\n\r\n    setGridWidth(width);\r\n    setGridHeight(height);\r\n  }\r\n\r\n  if (!Globals.puzzle) {\r\n    initializeGlobals();\r\n    triggerUpdate();\r\n  }\r\n\r\n  return (\r\n    <AppContext.Provider value={appState}>\r\n      <a id=\"download-puzzle-link\" href=\"http://www.example.com\" style={{display: \"none\"}}>stuff</a>\r\n\r\n      <Menu gridHeight={gridHeight} gridWidth={gridWidth} openView={activeView}></Menu>\r\n\r\n      <div className=\"left-panel\">\r\n        {activeView === \"Clues\" && \r\n            <CluesView updateSemaphore={updateSemaphore}></CluesView>\r\n        }\r\n        {activeView === \"Fill\" && \r\n            <FillView></FillView>\r\n        }\r\n      </div>\r\n      \r\n      <div className=\"right-panel\">\r\n        <Grid></Grid>\r\n      </div>\r\n    </AppContext.Provider>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\nimport 'bootstrap/dist/css/bootstrap.css';\r\n\r\n// import { loadWordListFromLocalhost } from './lib/wordList';\r\n// import Globals from './lib/windowService';\r\n// import { FillStatus } from './models/FillStatus';\r\n// loadWordListFromLocalhost(\"http://localhost/classifier/mainBrodaEntries.txt\").then(() => {\r\n//   Globals.fillStatus = FillStatus.Ready;\r\n// });\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App activeView=\"Fill\" />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n"],"sourceRoot":""}