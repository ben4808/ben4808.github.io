{"version":3,"sources":["models/SquareType.ts","models/WordDirection.ts","AppContext.ts","lib/windowService.tsx","models/SymmetryType.ts","models/ContentType.ts","models/QualityClass.ts","lib/wordList.ts","lib/entryCandidates.ts","lib/util.ts","lib/section.ts","lib/insertEntry.ts","lib/priorityQueue.ts","models/FillStatus.ts","lib/fill.ts","lib/grid.ts","components/CluesView/CluesView.tsx","components/FillView/FillView.tsx","lib/useInterval.ts","components/Square/Square.tsx","components/Grid/Grid.tsx","lib/puzFiles.ts","components/Menu/Menu.tsx","App.tsx","index.tsx"],"names":["SquareType","WordDirection","AppContext","React","createContext","triggerUpdate","switchActiveView","_","setPuzzle","createNewPuzzle","w","h","exportPuz","window","Globals","SymmetryType","ContentType","QualityClass","filename","data","a","text","lines","split","indexWordList","words","parseWordList","wordList","wordCount","length","qcMap","qualityClasses","Map","forEach","line","tokens","trim","match","score","qualityClass","Lively","Normal","Crosswordese","word","has","push","set","queryIndexedWordList","pattern","wl","letters","i","buckets","oneVal","charCodeAt","pos1","pos2","val1","val2","twoVal","filter","entries","existingList","ch1","ch2","populateAndScoreEntryCandidates","node","isForManualFill","anchorSquareKeys","fillWord","anchorInfo","populateFillWordAnchors","getSquaresForWord","startGrid","anchorCombosLeft","eligibleCandidates","heuristicsLevel","processAnchorCombo","getEligibleCandidates","ec","iffyWordKey","entryCandidates","sort","b","squares","calculatedSquares","anchorKeyCounts","sq","count","squareKey","get","viableLetters","constraintLetterCount","combos","constraintLetters","map","sqKey","find","fullAlphabet","comboScores","letter1","letter2","letterFrequencies","Math","random","generateAnchorCombos","grid","combo","pop","fillWordKey","wordKey","wordSquares","patternWithAnchor","getLettersFromSquares","insertLetterIntoPattern","isWordFull","isViable","hasBeenChained","wasChainFailure","crossScore","minCrossScore","crossKeys","crossCrossKeys","getAllCrosses","cross","crossCross","size","manualIffyKey","getWordAtSquare","row","col","otherDir","direction","csq","content","deepClone","getFilteredEntries","undefined","usedWords","entry","processEntry","maxIffyLength","ck","wordLength","wordScore","getWordScore","topCrossScore","topMinCrossScore","calculateEntryCandidateScore","distillIndex","crossSquares","includes","foundCountReduction","wKey","wordPattern","filteredEntries","anchorComboCount","newPattern","fe","reduce","newMatrix","Array","fill","letterMatrixToLetterList","existingCounts","iffyEntry","iffyWord","iffySquares","isq","idx","calSq","substring","anchorPattern","constraintCounts","x","curPatterns","lowestCount","index","newCurPatterns","ltr","broadenAnchorPatterns","newLetter","findIndex","updateSectionFilters","sections","getGrid","sec","candidates","can","sqKeys","mapKeys","isFilteredOut","gridSq","getSquareAtKey","canSq","isUserOrWordFilled","insertSectionCandidateIntoGrid","candidate","contentType","ChosenSection","newGrid","section","sectionId","foundDiscrepancy","candidateSq","HoverChosenSection","Autofill","forAllGridSquares","newSq","key","neighboringCrosses","generateConstraintInfoForSquares","userFilledSectionCandidates","sectionCandidateKey","generateGridSections","usedSquares","nextSectionId","fullSection","makeNewSection","isBlackSquare","isOpenSquare","newSection","iterateSection","openSquareCount","getNeighboringSquares","neighbor","Across","Down","dir","wsq","id","delete","stackWords","stackedNeighbors","otherKey","otherWord","isAcross","abs","start","min","end","max","sk","crossKey","wordOrder","calculateSectionOrder","mapValues","secOrder","calculateWordOrder","wk","connections","wordsSort","iterateWordGroup","group","centerIndex","floor","rowOrCol","slice","acrossSortedStackWords","downSortedStackWords","longestStack","stack","curGroup","prevRowOrCol","j","newWord","newRowOrCol","neighbors","n","ret","nClear","sClear","height","wClear","eClear","width","calculateSectionCandidateScore","total","foundIffy","natoAlphabet","k","join","comboPermsQueue","comboPermsUsed","getSelectedSectionCandidates","selectedSectionCandidateKeys","scKey","getSectionWithCandidate","sc","getSectionsWithWord","processAndInsertChosenEntry","chosenEntry","crosses","HoverChosenWord","ChosenWord","newSquares","getSectionCandidatesFromKeys","removeNonmatchingSectionCandidates","endGrid","FillStatus","fillSectionWord","getSection","fillQueue","newFillQueue","heap","left","right","hasRight","swap","temp","isEmpty","peek","value","insert","item","prio","p","tmp","current","largerChild","priorityQueue","populateSeedNodes","needsNewPriority","shouldBeDeleted","calculateNodePriority","isChainNode","chainId","curChainId","activeGrid","selectWordToFill","topScore","c","pow","roll","runningTotal","chooseEntryFromCandidates","processSectionNode","sectionString","getSectionString","newSecCandidateFound","newCandidate","getEntryAtWordKey","newSectionCandidate","invalidateChainNode","newNode","makeNewNode","depth","nextFillWord","curSections","nextSections","cs","ns","selectedWordNode","parent","prevCandidate","backtracks","chainBaseNode","chainIffyCandidates","chainGoodCandidates","curNode","isSectionBase","situationScore","selectedSectionIds","activeSection","connectionIds","selectedCandidate","candidateCounts","comboKey","perm","toString","shift","defaultCombo","allOnes","foundNew","newPerm","newPermKey","getNewPermutations","wasSuccess","viableLetterCounts","Iffy","populateWords","processSquare","currentWord","number","nextSq","currentNumber","isAboveBlocked","isBelowBlocked","isLeftBlocked","isRightBlocked","isUnchecked","isUncheckedStart","isCheckedStart","numberizeGrid","updateGridConstraintInfo","wordKeys","concat","isWordEmpty","entryOptions","curViableMatrix","list","matrix","letterListToLetterMatrix","newViableMatrix","arr","newVal","setLettersArrayVal","createNewGrid","type","White","isCircled","getSymmetrySquares","initSquare","r","gridSymmetry","Rotate180","Rotate90","MirrorHorizontal","MirrorVertical","MirrorNWSE","MirrorNESW","eraseGridSquare","otherDirWord","otherDirSquares","User","isInSection","clearFill","eraseSectionCandidateFromGrid","getSelectedSectionCandidatesWithSquare","fillStatus","Ready","NoWordList","isUserFilled","updateManualEntryCandidates","selectedWordKey","useManualHeuristics","populateNoHeuristicEntryCandidates","obj","Date","getTime","from","Object","keys","newObj","compareTuples","first","second","Black","doesWordContainSquare","func","newPuzzle","title","author","copyright","clues","notes","activeSectionId","getSelectedWord","values","sck","initializeSessionGlobals","hoverSectionId","String","fromCharCode","CluesView","props","useState","initClueProps","clueProps","setClueProps","selectedKey","setSelectedKey","textareasRef","useRef","puzzle","prop","clue","isOpenForEditing","handleClueClick","event","target","classList","parentElement","targetKey","attributes","refIndex","textareaEl","newClueProps","propToToggle","style","display","focus","handleKeyDown","toUpperCase","newValue","targetProp","applyClueChange","handleFocus","select","renderCluesContainer","clueList","className","createRef","data-key","onClick","data-ref-index","defaultValue","onKeyDown","onFocus","ref","useEffect","updateSemaphore","acrossClues","downClues","FillView","appContext","useContext","showSectionCandidates","setShowSectionCandidates","isWordListLoading","setIsWordListLoading","isFillRunning","setIsFillRunning","setFillStatus","newStatus","getManualEntryNode","isHover","insertEntryIntoGrid","getManualSectionNode","handleEntryCandidateClick","hoverGrid","handleEntryCandidateHover","handleSectionClick","handleSectionCheckClick","handleSectionHover","handleSectionCandidateClick","eraseSc","candidateKey","handleSectionCandidateHover","callback","delay","savedCallback","setInterval","clearInterval","useInterval","Complete","selectedSymmetry","symmetryOptions","t","isNaN","Number","fillStatusStr","status","Running","getFillStatusString","wordLists","isNoEntryCandidates","selectedScKey","sectionCandidates","selectedEntry","selectedMaxIffyLength","hidden","accept","onChange","file","files","setTimeout","processWordListData","name","then","checked","htmlFor","selectedIndex","getSymmetryTypeString","confirm","document","getElementById","click","gridTemplateColumns","cursor","onMouseOut","data-word","data-iffykey","onMouseOver","toFixed","data-id","getLongest","getLongestStackWord","data-candidate-key","between","input","Square","isSelected","isInSelectedWord","isInSelectedSection","constraintSum","data-row","data-col","NotAThing","getSquareElement","Grid","selectedSquare","setSelectedSquare","advanceCursor","selSq","isSquareSelected","selectedWordDir","newSelSq","setSelWordAtSelSquare","isSquareInSection","newSelSquare","getSquareProps","selectedWord","square","qualityClassMap","suppressEnterKey","preventDefault","el","range","createRange","selectNodeContents","sel","getSelection","removeAllRanges","addRange","selectElementContents","qc","curQc","generateQualityClassMap","squareElements","sqProps","columnTemplateStyle","contentEditable","suppressContentEditableWarning","onBlur","newTitle","innerText","onFocusCapture","newAuthor","newCopyright","newDirection","uncheckedSquareDir","getUncheckedSquareDir","letterChanged","blackSquareChanged","backupCursor","res","newSquareType","tabIndex","newNotes","processPuzData","Uint8Array","arrayBuffer","blobToText","restOfFile","curChar","getNextString","sortWordsForPuz","rebusSquareMappings","rebusValues","sectionType","dlI","Uint16Array","dataLength","secI","valuesStr","str","val","v","blob","cksum_region","bytes","startPos","len","cksum","insertString","pos","insertNumber","Menu","sizeRefs","handleViewChange","newView","role","data-view-id","openView","newWidth","newHeight","gridWidth","float","gridHeight","App","activeView","setActiveView","setGridWidth","setGridHeight","setUpdateSemaphore","getAppContext","appState","setAppState","initializeGlobals","solutionPos","areCircledSquares","char","gridPos","titlePos","authorPos","copyrightPos","orderedClues","cluesPos","oc","sectionSize","checksumPos","c_cib","squaresTotal","cluePos","c_sol","c_grid","c_part","finalArray","Blob","generatePuzFile","File","url","URL","createObjectURL","puzzleLink","setAttribute","isNewPuzzle","Provider","href","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.d134670a.chunk.js","sourcesContent":["export enum SquareType {\r\n    White,\r\n    Black,\r\n    //Blank,\r\n}\r\n","export enum WordDirection {\r\n    Across,\r\n    Down,\r\n}\r\n","import React from \"react\";\r\nimport { Puzzle } from \"./models/Puzzle\";\r\n\r\nexport const AppContext = React.createContext({\r\n    triggerUpdate: () => {},\r\n    switchActiveView: (_: string) => {},\r\n    setPuzzle: (_: Puzzle) => {},\r\n    createNewPuzzle: (w: number, h: number) => {},\r\n    exportPuz: () => {},\r\n  });\r\n  ","import { GlobalsObj } from \"../models/GlobalsObj\";\r\n\r\ndeclare const window: any;\r\nwindow.Globals = {} as GlobalsObj;\r\nexport default window.Globals as GlobalsObj;\r\n","export enum SymmetryType {\r\n    None,\r\n    Rotate180,\r\n    Rotate90,\r\n    MirrorHorizontal,\r\n    MirrorVertical,\r\n    MirrorNWSE,\r\n    MirrorNESW,\r\n}\r\n","export enum ContentType {\r\n    User,\r\n    ChosenWord,\r\n    HoverChosenWord,\r\n    ChosenSection,\r\n    HoverChosenSection,\r\n    Autofill,\r\n}\r\n","export enum QualityClass {\r\n    NotAThing,\r\n    Iffy,\r\n    Crosswordese,\r\n    Normal,\r\n    Lively,\r\n}\r\n","import { IndexedWordList } from \"../models/IndexedWordList\";\r\nimport { QualityClass } from \"../models/QualityClass\";\r\nimport { WordList } from \"../models/WordList\";\r\nimport Globals from './windowService';\r\n\r\nexport async function processWordListData(filename: string, data: Blob): Promise<WordList | undefined> {\r\n    let lines = (await data.text()).split(\"\\n\");\r\n    let words = parseWordList(lines);\r\n    indexWordList(words, Globals.wordList);\r\n\r\n    return {\r\n        filename: filename,\r\n        wordCount: words.length,\r\n    } as WordList;\r\n}\r\n\r\nexport async function loadWordListFromLocalhost(url: string) {\r\n    var response = await fetch(url);\r\n    const lines = (await response.text()).split('\\n');\r\n    let words = parseWordList(lines);\r\n    indexWordList(words, Globals.wordList);\r\n    let filenameTokens = url.split(\"/\");\r\n    let filename = filenameTokens[filenameTokens.length - 1];\r\n\r\n    Globals.wordLists = [];\r\n    Globals.wordLists!.push({\r\n        filename: filename,\r\n        wordCount: words.length,\r\n    });\r\n\r\n    console.log(\"Word List loaded\");\r\n}\r\n\r\nfunction parseWordList(lines: string[]): string[] {\r\n    let qcMap = Globals.qualityClasses || new Map<string, QualityClass>();\r\n    let words = [] as string[];\r\n\r\n    lines.forEach(line => {\r\n        let tokens = line.trim().split(\";\");\r\n        if (tokens.length > 2) return;\r\n        if (!tokens[0].match(/^[A-Z]+$/)) return;\r\n\r\n        let score = tokens.length === 2 ? +tokens[1] : 50;\r\n        let qualityClass = score >= 100 ? QualityClass.Lively :\r\n                           score >= 50 ? QualityClass.Normal :\r\n                           QualityClass.Crosswordese;\r\n        let word = tokens[0];\r\n        if (word.length >= 2 && word.length <= 15) {\r\n            if (!qcMap.has(word)) words.push(word);\r\n            qcMap.set(word, qualityClass);\r\n        }\r\n    });\r\n\r\n    Globals.qualityClasses = qcMap;\r\n\r\n    return words;\r\n}\r\n\r\nexport function queryIndexedWordList(pattern: string): string[] {\r\n    let wl = Globals.wordList!;\r\n    let words = [] as string[];\r\n    let letters = [] as [number, string][];\r\n    let length = pattern.length;\r\n    for (let i = 0; i < pattern.length; i++) {\r\n        if (pattern[i] !== \"-\") {\r\n            letters.push([i+1, pattern[i]]);\r\n        }\r\n    }\r\n\r\n    if (letters.length === 1) {\r\n        words = wl.buckets.oneVal[length-2][letters[0][0]-1][letters[0][1].charCodeAt(0)-65];\r\n    }\r\n    else if (letters.length === pattern.length) {\r\n        words = Globals.qualityClasses?.has(pattern) ? [pattern] : [];\r\n    }\r\n    else if (letters.length > 1) {\r\n        let pos1 = letters[0][0];\r\n        let pos2 = letters[1][0];\r\n        let val1 = letters[0][1];\r\n        let val2 = letters[1][1];\r\n        words = wl.buckets.twoVal[length-2][pos1-1][pos2-(pos1+1)][val1.charCodeAt(0)-65][val2.charCodeAt(0)-65];\r\n\r\n        for (let i = 2; i < letters.length; i++) {\r\n            words = words.filter(w => w[letters[i][0]-1] === letters[i][1]);\r\n        }\r\n    }\r\n\r\n    return words;\r\n}\r\n\r\nfunction indexWordList(entries: string[], existingList?: IndexedWordList) {\r\n    let buckets = existingList ? existingList.buckets : {\r\n        oneVal: [] as any[],\r\n        twoVal: [] as any[],\r\n    };\r\n\r\n    for (let length = 2; length <= 15; length++) {\r\n        buckets.oneVal.push([] as any[]);\r\n        for (let pos1 = 1; pos1 <= length; pos1++) {\r\n            buckets.oneVal[length-2].push([] as any[]);\r\n            for (let ch1 = 65; ch1 <= 90; ch1++) {\r\n                buckets.oneVal[length-2][pos1-1].push([] as string[]);\r\n            }\r\n        }\r\n    }\r\n\r\n    for (let length = 2; length <= 15; length++) {\r\n        buckets.twoVal.push([] as any[]);\r\n        for (let pos1 = 1; pos1 <= length-1; pos1++) {\r\n            buckets.twoVal[length-2].push([] as any[]);\r\n            for (let pos2 = pos1+1; pos2 <= length; pos2++) {\r\n                buckets.twoVal[length-2][pos1-1].push([] as any[]);\r\n                for (let ch1 = 65; ch1 <= 90; ch1++) {\r\n                    buckets.twoVal[length-2][pos1-1][pos2-(pos1+1)].push([] as any[]);\r\n                    for (let ch2 = 65; ch2 <= 90; ch2++) {\r\n                        buckets.twoVal[length-2][pos1-1][pos2-(pos1+1)][ch1-65].push([] as string[]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    entries.forEach(word => {\r\n        // 1-position entries\r\n        for (let pos1 = 1; pos1 <= word.length; pos1++) {\r\n            buckets.oneVal[word.length-2][pos1-1][word[pos1-1].charCodeAt(0)-65].push(word);\r\n        }\r\n\r\n        // 2-position entries\r\n        for (let pos1 = 1; pos1 < word.length; pos1++) {\r\n            for (let pos2 = pos1 + 1; pos2 <= word.length; pos2++) {\r\n                buckets.twoVal[word.length-2][pos1-1][pos2-(pos1+1)][word[pos1-1].charCodeAt(0)-65][word[pos2-1].charCodeAt(0)-65].push(word);\r\n            }\r\n        }\r\n    });\r\n\r\n    Globals.wordList = { buckets: buckets } as IndexedWordList;\r\n}\r\n","import { EntryCandidate } from \"../models/EntryCandidate\";\r\nimport { FillNode } from \"../models/FillNode\";\r\nimport { GridSquare } from \"../models/GridSquare\";\r\nimport { getAllCrosses, getEligibleCandidates, getWordScore } from \"./fill\";\r\nimport { getLettersFromSquares } from \"./grid\";\r\nimport { constraintLetterCount, deepClone, fullAlphabet, getSquaresForWord, getWordAtSquare, isUserFilled, \r\n    isWordFull, letterMatrixToLetterList, otherDir, squareKey, sum, wordKey, wordLength } from \"./util\";\r\nimport { queryIndexedWordList } from \"./wordList\";\r\nimport Globals from './windowService';\r\n\r\n// returns false if no viable candidates were found or iffy was set\r\nexport function populateAndScoreEntryCandidates(node: FillNode, isForManualFill: boolean): boolean {\r\n    if (node.anchorSquareKeys.length === 0) {\r\n        let word = node.fillWord!;\r\n        let squares = getSquaresForWord(node.startGrid, word);\r\n        let anchorInfo = populateFillWordAnchors(squares);\r\n        node.anchorCombosLeft = anchorInfo.anchorCombosLeft;\r\n        node.anchorSquareKeys = anchorInfo.anchorSquareKeys;\r\n    }\r\n\r\n    let eligibleCandidates = [] as EntryCandidate[];\r\n    let heuristicsLevel = node.anchorCombosLeft.length > 100 ? 1 : node.anchorCombosLeft.length > 25 ? 2 : 3;\r\n\r\n    while(true) {\r\n        processAnchorCombo(node, isForManualFill, heuristicsLevel);\r\n        eligibleCandidates = getEligibleCandidates(node);\r\n        if (node.anchorCombosLeft.length === 0) break;\r\n        if (eligibleCandidates.filter(ec => !ec.iffyWordKey).length > (isForManualFill ? 100 : 0)) break;\r\n    }\r\n\r\n    node.entryCandidates.sort((a, b) => b.score! - a.score!);\r\n    return true;\r\n}\r\n\r\nexport function populateNoHeuristicEntryCandidates(node: FillNode) {\r\n    let word = node.fillWord!;\r\n    let squares = deepClone(getSquaresForWord(node.startGrid, word)) as GridSquare[];\r\n    squares.forEach(sq => {\r\n        if (!isUserFilled(sq)) sq.content = undefined;\r\n    });\r\n    let pattern = getLettersFromSquares(squares);\r\n    let entries = queryIndexedWordList(pattern).sort((a, b) => Globals.qualityClasses!.get(b)! - Globals.qualityClasses!.get(a)!);\r\n\r\n    node.entryCandidates = [];\r\n    entries.forEach(entry => {\r\n        node.entryCandidates.push({\r\n            word: entry,\r\n            score: getWordScore(entry),\r\n            isViable: true,\r\n            hasBeenChained: false,\r\n            wasChainFailure: false,\r\n            crossScore: 0,\r\n            minCrossScore: 0,\r\n        } as EntryCandidate);\r\n    });\r\n}\r\n\r\nfunction populateFillWordAnchors(squares: GridSquare[], calculatedSquares?: Map<string, string[]>):\r\n    { anchorSquareKeys: string[], anchorCombosLeft: [string, string][] } {\r\n    let anchorKeyCounts = [] as [string, number][];\r\n\r\n    squares.forEach(sq => {\r\n        let count = (calculatedSquares && calculatedSquares.has(squareKey(sq))) ? \r\n            calculatedSquares!.get(squareKey(sq))!.length : constraintLetterCount(sq);\r\n        if (count === 0) return; // don't anchor iffy\r\n\r\n        if (anchorKeyCounts.length < 2) {\r\n            anchorKeyCounts.push([squareKey(sq), count]);\r\n            anchorKeyCounts.sort((a, b) => a[1] - b[1]);\r\n            return;\r\n        }\r\n\r\n        if (count < anchorKeyCounts[1][1]) {\r\n            anchorKeyCounts[1] = [squareKey(sq), count];\r\n            anchorKeyCounts.sort((a, b) => a[1] - b[1]);\r\n        }\r\n    });\r\n\r\n    if (anchorKeyCounts.length < 2) {\r\n        return {\r\n            anchorSquareKeys: [],\r\n            anchorCombosLeft: [],\r\n        };\r\n    }\r\n\r\n    let anchorSquareKeys = [anchorKeyCounts[0][0], anchorKeyCounts[1][0]];\r\n    let combos = generateAnchorCombos(squares, anchorSquareKeys, calculatedSquares);\r\n\r\n    return {\r\n        anchorSquareKeys: anchorSquareKeys,\r\n        anchorCombosLeft: combos,\r\n    };\r\n}\r\n\r\nconst letterFrequencies = {\r\n    \"A\": 8.2, \"B\": 1.5, \"C\": 2.8, \"D\": 4.3,\r\n    \"E\": 13, \"F\": 2.2, \"G\": 2, \"H\": 6.1,\r\n    \"I\": 7, \"J\": 0.15, \"K\": 0.77, \"L\": 4,\r\n    \"M\": 2.4, \"N\": 6.7, \"O\": 7.5, \"P\": 1.9,\r\n    \"Q\": 0.095, \"R\": 6, \"S\": 6.3, \"T\": 9.1,\r\n    \"U\": 2.8, \"V\": 0.98, \"W\": 2.4, \"X\": 0.15,\r\n    \"Y\": 2, \"Z\": 0.074,\r\n} as any;\r\n\r\nfunction generateAnchorCombos(squares: GridSquare[], anchorSquareKeys: string[], \r\n    calculatedSquares?: Map<string, string[]>): [string, string][] {\r\n    let constraintLetters = anchorSquareKeys\r\n        .map(sqKey => squares.find(sq => squareKey(sq) === sqKey)!)\r\n        .map(sq => (calculatedSquares && calculatedSquares.has(squareKey(sq))) ? \r\n        calculatedSquares!.get(squareKey(sq))! : sq.viableLetters || fullAlphabet);\r\n\r\n    let combos = [] as [string, string][];\r\n    let comboScores = new Map<string, number>();\r\n    for (var letter1 of constraintLetters[0]) {\r\n        for (var letter2 of constraintLetters[1]) {\r\n            combos.push([letter1, letter2]);\r\n            comboScores.set(`[${letter1},${letter2}]`, letterFrequencies[letter1] * letterFrequencies[letter2] * Math.random());\r\n        }\r\n    }\r\n\r\n    combos.sort((a, b) => {\r\n        return comboScores.get(`[${a[0]},${a[1]}]`)! - comboScores.get(`[${b[0]},${b[1]}]`)!;\r\n    });\r\n\r\n    return combos;\r\n}\r\n\r\nfunction processAnchorCombo(node: FillNode, isForManualFill: boolean, heuristicsLevel: number) {\r\n    let grid = node.startGrid;\r\n    let combo = node.anchorCombosLeft.pop()!;\r\n\r\n    let fillWordKey = wordKey(node.fillWord!);\r\n    let wordSquares = getSquaresForWord(grid, node.fillWord!);\r\n    let patternWithAnchor = getLettersFromSquares(wordSquares);\r\n    node.anchorSquareKeys.forEach((sqKey, i) => {\r\n        patternWithAnchor = insertLetterIntoPattern(patternWithAnchor, combo[i], wordSquares, sqKey);\r\n    });\r\n    if (isForManualFill && isWordFull(wordSquares)) {\r\n        node.entryCandidates.push({\r\n            word: patternWithAnchor,\r\n            score: 1,\r\n            isViable: true,\r\n            hasBeenChained: false,\r\n            wasChainFailure: false,\r\n            crossScore: 0,\r\n            minCrossScore: 0,\r\n        } as EntryCandidate);\r\n        return;\r\n    }\r\n\r\n    let crossKeys = new Map<string, boolean>();\r\n    let crossCrossKeys = new Map<string, boolean>();\r\n    getAllCrosses(grid, node.fillWord!).forEach(cross => {\r\n        crossKeys.set(wordKey(cross), true);\r\n        getAllCrosses(grid, cross).forEach(crossCross => {\r\n            crossCrossKeys.set(wordKey(crossCross), true);\r\n        });\r\n    });\r\n\r\n    if (wordSquares.length < 6 || (wordSquares.length < 7 && crossKeys.size + crossCrossKeys.size <= 15))\r\n        heuristicsLevel = 3;\r\n    if (heuristicsLevel === 3 && wordSquares.length > 8 && crossKeys.size + crossCrossKeys.size > 20)\r\n        heuristicsLevel = 2;\r\n\r\n    let iffyWordKey = isForManualFill ? Globals.manualIffyKey : node.iffyWordKey;\r\n    if (iffyWordKey) {\r\n        wordSquares.forEach(sq => {\r\n            let cross = getWordAtSquare(grid, sq.row, sq.col, otherDir(node.fillWord!.direction))!;\r\n            if (wordKey(cross) === iffyWordKey) {\r\n                let crossSquares = getSquaresForWord(grid, cross);\r\n                crossSquares.forEach(csq => {\r\n                    if (!csq.content)\r\n                        csq.viableLetters = deepClone(fullAlphabet);\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    let entries = getFilteredEntries(wordSquares, patternWithAnchor, undefined, grid.usedWords);\r\n\r\n    entries.forEach(entry => {\r\n        let success = processEntry(entry, iffyWordKey);\r\n\r\n        if (!success && !node.iffyWordKey && heuristicsLevel === 3 && Globals.maxIffyLength! > 0) {\r\n            crossKeys.forEach((_, ck) => {\r\n                let cross = grid.words.get(ck)!;\r\n                if (wordLength(cross) > Globals.maxIffyLength!) return;\r\n                processEntry(entry, ck);\r\n            });\r\n        }\r\n    });\r\n\r\n    node.entryCandidates.forEach(ec => {\r\n        if(ec.score === -1) {\r\n            ec.score = calculateEntryCandidateScore(node, ec);\r\n        }\r\n    });\r\n\r\n    function processEntry(entry: string, iffyWordKey?: string): boolean {\r\n        let isViable = true;\r\n        let distillIndex = 1;\r\n        let calculatedSquares = new Map<string, string[]>();\r\n        let crossScore = 0;\r\n        let minCrossScore = 1e8;\r\n        let usedWords = deepClone(grid.usedWords) as Map<string, boolean>;\r\n        usedWords.set(entry, true);\r\n\r\n        wordSquares.forEach((sq, i) => {\r\n            let sqKey = squareKey(sq);\r\n            calculatedSquares.set(sqKey, [entry[i]]);\r\n\r\n            let cross = getWordAtSquare(grid, sq.row, sq.col, otherDir(node.fillWord!.direction))!;\r\n            let crossSquares = getSquaresForWord(grid, cross);\r\n            let pattern = getLettersFromSquares(crossSquares);\r\n            insertLetterIntoPattern(pattern, entry[i], crossSquares, sqKey);\r\n            if (!pattern.includes(\"-\"))\r\n                usedWords.set(pattern, true);\r\n\r\n            if (wordKey(cross) === iffyWordKey) {\r\n                crossSquares.forEach(csq => {\r\n                    if (!csq.content)\r\n                        csq.viableLetters = deepClone(fullAlphabet);\r\n                });\r\n            }\r\n        });\r\n\r\n        while(true) {\r\n            let wordKeys = distillIndex % 2 === 1  ? crossKeys : crossCrossKeys;\r\n            let foundCountReduction = false;\r\n    \r\n            // eslint-disable-next-line\r\n            wordKeys.forEach((_, wKey) => {\r\n                if (!isViable) return;\r\n                if (wKey === fillWordKey) return;\r\n                if (wKey === iffyWordKey) return;\r\n\r\n                let word = grid.words.get(wKey)!;\r\n                let squares = getSquaresForWord(grid, word);\r\n                if (isWordFull(squares)) return;\r\n                if (distillIndex === 1 && squares.filter(sq => !calculatedSquares.has(squareKey(sq)) && \r\n                    (!sq.viableLetters || sq.viableLetters.length < 20)).length === 0) return;\r\n                let wordPattern = getLettersFromSquares(squares);\r\n                let filteredEntries = [] as string[];\r\n                let anchorInfo = populateFillWordAnchors(squares, calculatedSquares);\r\n                let anchorComboCount = anchorInfo.anchorCombosLeft.length;\r\n                if (distillIndex > 1 && anchorComboCount > 20) return;\r\n\r\n                anchorInfo.anchorCombosLeft.forEach(combo => {\r\n                    let newPattern = wordPattern;\r\n                    anchorInfo.anchorSquareKeys.forEach((sqKey, i) => {\r\n                        newPattern = insertLetterIntoPattern(newPattern, combo[i], squares, sqKey);\r\n                    });\r\n                    filteredEntries.push(...getFilteredEntries(squares, newPattern, calculatedSquares, usedWords));\r\n                });\r\n    \r\n                if (filteredEntries.length === 0) {\r\n                    isViable = false;\r\n                    return;\r\n                }\r\n\r\n                if (distillIndex === 1) {\r\n                    let score = sum(filteredEntries.map(fe => getWordScore(fe)));\r\n                    crossScore += score;\r\n                    if (score < minCrossScore) minCrossScore = score;\r\n                }\r\n\r\n                if (heuristicsLevel === 1) return;\r\n                if (distillIndex === 2 && heuristicsLevel === 2) return;\r\n    \r\n                squares.forEach((sq, i) => {\r\n                    let newMatrix = Array<boolean>(26).fill(false);\r\n                    filteredEntries.forEach(entry => {\r\n                        newMatrix[entry[i].charCodeAt(0) - 65] = true;\r\n                    });\r\n                    let letters = letterMatrixToLetterList(newMatrix);\r\n\r\n                    let existingCounts = calculatedSquares.get(squareKey(sq))!;\r\n                    if (!existingCounts || existingCounts.length > letters.length)\r\n                        foundCountReduction = true;\r\n\r\n                    calculatedSquares.set(squareKey(sq), letters);\r\n                });\r\n            });\r\n\r\n            if (distillIndex === 3) break;\r\n            if (!foundCountReduction) break;\r\n            if (!isViable) break;\r\n            if (distillIndex > 0 && heuristicsLevel === 1) break;\r\n            if (distillIndex === 2 && heuristicsLevel === 2) break;\r\n\r\n            distillIndex++;\r\n        }\r\n\r\n        if (!isViable) return false;\r\n\r\n        if (crossScore > node.topCrossScore) node.topCrossScore = crossScore;\r\n        if (minCrossScore > node.topMinCrossScore) node.topMinCrossScore = minCrossScore;\r\n\r\n        let iffyEntry = undefined as string | undefined;\r\n        if (iffyWordKey) {\r\n            let iffyWord = grid.words.get(iffyWordKey)!;\r\n            let iffySquares = getSquaresForWord(grid, iffyWord);\r\n            let pattern = getLettersFromSquares(iffySquares);\r\n            iffySquares.forEach((isq, idx) => {\r\n                let calSq = calculatedSquares.get(squareKey(isq));\r\n                if (!isq.content && calSq && calSq.length === 1)\r\n                    pattern = pattern.substring(0, idx) + calSq[0] + pattern.substring(idx+1);\r\n            });\r\n            iffyEntry = pattern;\r\n        }\r\n\r\n        if (iffyEntry && usedWords.has(iffyEntry)) return false;\r\n\r\n        node.entryCandidates.push({\r\n            word: entry,\r\n            score: -1,\r\n            isViable: isViable,\r\n            hasBeenChained: false,\r\n            wasChainFailure: false,\r\n            iffyEntry: iffyEntry,\r\n            iffyWordKey: iffyWordKey,\r\n            crossScore: crossScore,\r\n            minCrossScore: minCrossScore,\r\n        } as EntryCandidate);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\nfunction getFilteredEntries(squares: GridSquare[], anchorPattern: string, calculatedSquares?: Map<string, string[]>,\r\n    usedWords?: Map<string, boolean>): string[] {\r\n    let entries = [] as string[];\r\n    broadenAnchorPatterns(squares, anchorPattern, calculatedSquares).forEach(pattern => {\r\n        entries.push(...queryIndexedWordList(pattern));\r\n    });\r\n\r\n    let filteredEntries = entries.filter(entry => {\r\n        if (usedWords && usedWords.has(entry)) return false;\r\n\r\n        for (let i = 0; i < squares.length; i++) {\r\n            let sq = squares[i];\r\n            let sqKey = squareKey(sq);\r\n            \r\n            if (calculatedSquares && calculatedSquares.has(sqKey) && !calculatedSquares.get(sqKey)!.includes(entry[i])) {\r\n                return false;\r\n            }\r\n            else if (sq.viableLetters && !sq.viableLetters.includes(entry[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        \r\n        return true;\r\n    });\r\n\r\n    return filteredEntries;\r\n}\r\n\r\nfunction broadenAnchorPatterns(squares: GridSquare[], anchorPattern: string, calculatedSquares?: Map<string, string[]>): string[] {\r\n    let constraintCounts = squares.map((sq, i) => {\r\n        if (anchorPattern[i] !== \"-\") return [i, [anchorPattern[i]]] as [number, string[]];\r\n        if (calculatedSquares && calculatedSquares.has(squareKey(sq))) {\r\n            return [i, calculatedSquares.get(squareKey(sq))!] as [number, string[]];\r\n        }\r\n        return [i, sq.viableLetters || fullAlphabet] as [number, string[]];\r\n    })\r\n    .filter(x => x[1].length > 0).sort((a, b) => b[1].length - a[1].length);\r\n\r\n    let curPatterns = [anchorPattern];\r\n    while(constraintCounts.length > 0 && curPatterns.length < 12) {\r\n        let lowestCount = constraintCounts.pop()!;\r\n        if (lowestCount[1].length >= 6) \r\n            return curPatterns;\r\n\r\n        let index = lowestCount[0];\r\n        let viableLetters = lowestCount[1];\r\n        let newCurPatterns = [] as string[];\r\n        // eslint-disable-next-line\r\n        viableLetters.forEach(ltr => {\r\n            curPatterns.forEach(pattern => {\r\n                newCurPatterns.push(pattern.substring(0, index) + ltr + pattern.substring(index+1));\r\n            });\r\n        });\r\n        curPatterns = newCurPatterns;\r\n    }\r\n\r\n    return curPatterns;\r\n}\r\n\r\nfunction calculateEntryCandidateScore(node: FillNode, ec: EntryCandidate): number {\r\n    let wordScore = getWordScore(ec.word);\r\n    let crossScore = node.topCrossScore > 0 ? ec.crossScore / node.topCrossScore : 1;\r\n    let minCrossScore = node.topMinCrossScore > 0 ? ec.minCrossScore / node.topMinCrossScore : 1;\r\n    let ret = (crossScore + minCrossScore) * wordScore * (ec.iffyWordKey ? 1 : 10);\r\n    return ret;\r\n}\r\n\r\nfunction insertLetterIntoPattern(pattern: string, newLetter: string, squares: GridSquare[], sqKey: string): string {\r\n    let i = squares.findIndex(sq => squareKey(sq) === sqKey);\r\n    return pattern.substring(0, i) + newLetter + pattern.substring(i+1);\r\n}\r\n","import { GridSquare } from \"../models/GridSquare\";\r\nimport { GridState } from \"../models/GridState\";\r\nimport { GridWord } from \"../models/GridWord\";\r\nimport { SquareType } from \"../models/SquareType\";\r\nimport { WordDirection } from \"../models/WordDirection\";\r\nimport Globals from './windowService';\r\nimport { Puzzle } from \"../models/Puzzle\";\r\nimport { getLettersFromSquares } from \"./grid\";\r\nimport { ContentType } from \"../models/ContentType\";\r\nimport { Section } from \"../models/Section\";\r\nimport { SectionCandidate } from \"../models/SectionCandidate\";\r\nimport { generateGridSections } from \"./section\";\r\n\r\nexport const fullAlphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".split(\"\");\r\n\r\nexport function average(arr: number[]): number {\r\n    return arr.reduce((a,b) => a + b, 0) / arr.length;\r\n}\r\n\r\nexport function sum(arr: number[]): number {\r\n    return arr.reduce((a,b) => a + b, 0);\r\n}\r\n\r\n// https://stackoverflow.com/questions/38416020/deep-copy-in-es6-using-the-spread-syntax\r\nexport function deepClone(obj: any): any {\r\n    if(typeof obj !== 'object' || obj === null) {\r\n        return obj;\r\n    }\r\n\r\n    if(obj instanceof Date) {\r\n        return new Date(obj.getTime());\r\n    }\r\n\r\n    if(obj instanceof Map) {\r\n        return new Map(Array.from(obj.entries()));\r\n    }\r\n\r\n    if(obj instanceof Array) {\r\n        return obj.reduce((arr, item, i) => {\r\n            arr[i] = deepClone(item);\r\n            return arr;\r\n        }, []);\r\n    }\r\n\r\n    if(obj instanceof Object) {\r\n        return Object.keys(obj).reduce((newObj: any, key) => {\r\n            newObj[key] = deepClone(obj[key]);\r\n            return newObj;\r\n        }, {})\r\n    }\r\n}\r\n\r\nexport function compareTuples(first: [number, number], second: [number, number]): boolean {\r\n    return first[0] === second[0] && first[1] === second[1];\r\n}\r\n\r\nexport function isBlackSquare(sq: GridSquare): boolean {\r\n    return sq.type === SquareType.Black;\r\n}\r\n\r\nexport function otherDir(dir: WordDirection): WordDirection {\r\n    return dir === WordDirection.Across ? WordDirection.Down : WordDirection.Across;\r\n}\r\n\r\nexport function getSquaresForWord(grid: GridState, word: GridWord): GridSquare[] {\r\n    let row = word.start[0];\r\n    let col = word.start[1];\r\n    let squares = [grid.squares[row][col]];\r\n    while (!compareTuples([row, col], word.end)) {\r\n        row = word.direction === WordDirection.Across ? row : row+1;\r\n        col = word.direction === WordDirection.Across ? col+1 : col;\r\n        squares.push(grid.squares[row][col]);\r\n    }\r\n\r\n    return squares;\r\n}\r\n\r\nexport function getWordAtSquare(grid: GridState, row: number, col: number, dir: WordDirection): GridWord | undefined {\r\n    let ret = undefined as GridWord | undefined;\r\n\r\n    grid.words.forEach((word, _) => {\r\n        if (dir === WordDirection.Across && word.direction === dir && word.start[0] === row &&\r\n            word.start[1] <= col && word.end[1] >= col)\r\n            ret = word;\r\n        if (dir === WordDirection.Down && word.direction === dir && word.start[1] === col &&\r\n            word.start[0] <= row && word.end[0] >= row)\r\n            ret = word;\r\n    });\r\n\r\n    return ret;\r\n}\r\n\r\nexport function newWord(): GridWord {\r\n    return {\r\n        number: undefined,\r\n        direction: WordDirection.Across,\r\n        start: [-1, -1],\r\n        end: [-1, -1],\r\n    }\r\n}\r\n\r\nexport function doesWordContainSquare(word: GridWord, row: number, col: number): boolean {\r\n    if (word.direction === WordDirection.Across) {\r\n        return word.start[0] === row && word.start[1] <= col && word.end[1] >= col;\r\n    }\r\n    else {\r\n        return word.start[1] === col && word.start[0] <= row && word.end[0] >= row;\r\n    }\r\n}\r\n\r\nexport function isWordEmpty(squares: GridSquare[]): boolean {\r\n    return !squares.find(x => !isBlackSquare(x) && x.content);\r\n}\r\n\r\nexport function isWordFull(squares: GridSquare[]): boolean {\r\n    return !squares.find(x => !isBlackSquare(x) && !x.content);\r\n}\r\n\r\nexport function shuffleArray(array: any[]) {\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1));\r\n        [array[i], array[j]] = [array[j], array[i]];\r\n    }\r\n}\r\n\r\nexport function forAllGridSquares(grid: GridState, func: (sq: GridSquare) => void) {\r\n    grid.squares.forEach(row => {\r\n        row.forEach(sq => {\r\n            func(sq);\r\n        });\r\n    });\r\n}\r\n\r\nexport function wordLength(word: GridWord): number {\r\n    if (word.direction === WordDirection.Across)\r\n        return word.end[1] - word.start[1] + 1;\r\n    else\r\n        return word.end[0] - word.start[0] + 1;\r\n}\r\n\r\nexport function newPuzzle(): Puzzle {\r\n    return {\r\n        title: \"\",\r\n        author: \"\",\r\n        copyright: \"\",\r\n        clues: new Map<string, string>(),\r\n        notes: \"\",\r\n    } as Puzzle;    \r\n}\r\n\r\nexport function wordKey(word: GridWord): string {\r\n    return `[${word.start[0]},${word.start[1]},${word.direction === WordDirection.Across ? \"A\" : \"D\"}]`;\r\n}\r\n\r\nexport function squareKey(sq: GridSquare | undefined): string {\r\n    return sq ? `[${sq.row},${sq.col}]` : \"\";\r\n}\r\n\r\nexport function getGrid(): GridState {\r\n    return Globals.activeGrid!;\r\n}\r\n\r\nexport function getSection(): Section {\r\n    return Globals.sections!.get(Globals.activeSectionId!)!;\r\n}\r\n\r\nexport function getSelectedWord(): GridWord | undefined {\r\n    let grid = getGrid();\r\n    if (!Globals.selectedWordKey) return undefined;\r\n    return grid.words.get(Globals.selectedWordKey);\r\n}\r\n\r\nexport function mapKeys<TKey, TVal>(map: Map<TKey, TVal>): TKey[] {\r\n    return Array.from(map.keys()) || [];\r\n}\r\n\r\nexport function mapValues<TKey, TVal>(map: Map<TKey, TVal>): TVal[] {\r\n    return Array.from(map.values()) || [];\r\n}\r\n\r\nexport function isUserFilled(sq: GridSquare): boolean {\r\n    return sq.contentType === ContentType.User || sq.contentType === ContentType.ChosenWord \r\n        || sq.contentType === ContentType.ChosenSection;\r\n}\r\n\r\nexport function isUserOrWordFilled(sq: GridSquare): boolean {\r\n    return sq.contentType === ContentType.User || sq.contentType === ContentType.ChosenWord;\r\n}\r\n\r\nexport function isAcross(word: GridWord): boolean {\r\n    return word.direction === WordDirection.Across;\r\n}\r\n\r\nexport function getSquareAtKey(grid: GridState, squareKey: string): GridSquare {\r\n    let tokens = squareKey.substring(1, squareKey.length - 1).split(\",\");\r\n    return grid.squares[+tokens[0]][+tokens[1]];\r\n}\r\n\r\nexport function isPartOfIffyWord(sq: GridSquare): boolean {\r\n    if (!sq.viableLetters) return false;\r\n    return sq.viableLetters.length === 0;\r\n}\r\n\r\n// https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\r\nexport function shuffle(array: any[]) {\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1));\r\n        [array[i], array[j]] = [array[j], array[i]];\r\n    }\r\n}\r\n\r\nexport function getEntryAtWordKey(grid: GridState, wordKey: string): string {\r\n    return getLettersFromSquares(getSquaresForWord(grid, grid.words.get(wordKey)!));\r\n}\r\n\r\nexport function getSectionCandidatesFromKeys(keys: string[]): SectionCandidate[] {\r\n    return keys\r\n        .map(sck => mapValues(Globals.sections!).find(sec => sec.candidates.has(sck))?.candidates.get(sck))\r\n        .filter(sck => sck !== undefined)\r\n        .map(sck => sck!);\r\n}\r\n\r\nexport function constraintLetterCount(sq: GridSquare): number {\r\n    if (!sq.viableLetters) return 26;\r\n\r\n    return sq.viableLetters.length;\r\n}\r\n\r\nexport function isPatternFull(pattern: string): boolean {\r\n    return !pattern.includes(\"-\");\r\n}\r\n\r\nexport function getUserFilledSections(grid: GridState): Section[] {\r\n    let sectionCandidates = getSectionCandidatesFromKeys(mapKeys(grid.userFilledSectionCandidates));\r\n    return sectionCandidates.map(sc => Globals.sections!.get(sc.sectionId)!);\r\n}\r\n\r\nexport function getUserFilledSectionCandidates(grid: GridState): SectionCandidate[] {\r\n    return getSectionCandidatesFromKeys(mapKeys(grid.userFilledSectionCandidates));\r\n}\r\n\r\nexport function initializeSessionGlobals() {\r\n    let grid = getGrid();\r\n    Globals.sections = generateGridSections(grid);\r\n    Globals.activeSectionId = 0;\r\n    Globals.hoverSectionId = undefined;\r\n    Globals.selectedSectionIds = new Map<number, boolean>();\r\n    Globals.selectedSectionCandidateKeys = new Map<number, string>();\r\n}\r\n\r\nexport function letterMatrixToLetterList(matrix: boolean[]): string[] {\r\n    return matrix.map((x, i) => x ? String.fromCharCode(i + 65) : \"\").filter(x => x);\r\n}\r\n\r\nexport function letterListToLetterMatrix(list: string[]): boolean[] {\r\n    let matrix = Array<boolean>(26).fill(false);\r\n    list.forEach(ltr => {\r\n        matrix[ltr.charCodeAt(0)] = true;\r\n    });\r\n    return matrix;\r\n}\r\n","import { ContentType } from \"../models/ContentType\";\r\nimport { FillNode } from \"../models/FillNode\";\r\nimport { GridSquare } from \"../models/GridSquare\";\r\nimport { GridState } from \"../models/GridState\";\r\nimport { GridWord } from \"../models/GridWord\";\r\nimport { Section } from \"../models/Section\";\r\nimport { SectionCandidate } from \"../models/SectionCandidate\";\r\nimport { WordDirection } from \"../models/WordDirection\";\r\nimport { getAllCrosses, getWordScore } from \"./fill\";\r\nimport { generateConstraintInfoForSquares, getLettersFromSquares } from \"./grid\";\r\nimport { forAllGridSquares, getEntryAtWordKey, getGrid, getSquaresForWord, getWordAtSquare, getSquareAtKey, isAcross, \r\n    isBlackSquare, mapKeys, squareKey, wordKey, wordLength, mapValues, isUserOrWordFilled, deepClone } from \"./util\";\r\nimport Globals from './windowService';\r\n\r\nexport function updateSectionFilters() {\r\n    let sections = Globals.sections!;\r\n    let grid = getGrid();\r\n    sections.forEach(sec => {\r\n        sec.candidates.forEach((can, _) => {\r\n            let sqKeys = mapKeys(sec.squares);\r\n            can.isFilteredOut = false;\r\n            for (let sqKey of sqKeys) {\r\n                let gridSq = getSquareAtKey(grid, sqKey);\r\n                let canSq = getSquareAtKey(can.grid, sqKey);\r\n                if (isUserOrWordFilled(gridSq) && canSq.content !== gridSq.content)\r\n                    can.isFilteredOut = true;\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\nexport function getSectionString(grid: GridState, section: Section): string {\r\n    let ret = [] as string[];\r\n    mapKeys(section.squares).sort().forEach(sqKey => {\r\n        let sq = getSquareAtKey(grid, sqKey);\r\n        let content = sq.content;\r\n        ret.push(content ? content! : \"-\");\r\n    });\r\n    return ret.join(\"\");\r\n}\r\n\r\n// returns whether it was a success\r\nexport function insertSectionCandidateIntoGrid(grid: GridState, candidate: SectionCandidate, contentType?: ContentType): boolean {\r\n    if (contentType === undefined) contentType = ContentType.ChosenSection;\r\n    let newGrid = deepClone(grid) as GridState;\r\n    let section = Globals.sections!.get(candidate.sectionId)!;\r\n    let foundDiscrepancy = false;\r\n    section.squares.forEach((_, sqKey) => {\r\n        let sq = getSquareAtKey(newGrid, sqKey);\r\n        let candidateSq = getSquareAtKey(candidate.grid, sqKey);\r\n        if (isUserOrWordFilled(sq) && sq.content! !== candidateSq.content!)\r\n            foundDiscrepancy = true;\r\n        sq.content = candidateSq.content;\r\n        sq.viableLetters = [sq.content!];\r\n        if (!isUserOrWordFilled(sq)) {\r\n            sq.contentType = [ContentType.HoverChosenSection, ContentType.Autofill].includes(contentType!) ? \r\n                ContentType.Autofill : ContentType.ChosenSection;\r\n        }\r\n    });\r\n    if (foundDiscrepancy) return false;\r\n    else {\r\n        forAllGridSquares(newGrid, newSq => {\r\n            grid.squares[newSq.row][newSq.col] = newSq;\r\n        });\r\n    }\r\n\r\n    section.words.forEach((_, key) => {\r\n        let word = grid.words.get(key)!;\r\n        let squares = getSquaresForWord(grid, word);\r\n        grid.usedWords.set(getLettersFromSquares(squares), true);\r\n    });\r\n\r\n    section.neighboringCrosses.forEach((_, key) => {\r\n        let word = grid.words.get(key)!;\r\n        let squares = getSquaresForWord(grid, word);\r\n        generateConstraintInfoForSquares(squares);\r\n    });\r\n\r\n    grid.userFilledSectionCandidates.set(sectionCandidateKey(section, grid), true);\r\n    return true;\r\n}\r\n\r\nexport function generateGridSections(grid: GridState): Map<number, Section> {\r\n    function iterateSection(section: Section, grid: GridState, sq: GridSquare, usedSquares: Map<string, boolean>) {\r\n        section.openSquareCount++;\r\n        usedSquares.set(squareKey(sq), true);\r\n\r\n        getNeighboringSquares(grid, sq).forEach(neighbor => {\r\n            if (!usedSquares.has(squareKey(neighbor)) && isOpenSquare(grid, neighbor)) {\r\n                iterateSection(section, grid, neighbor, usedSquares);\r\n            }\r\n\r\n            [WordDirection.Across, WordDirection.Down].forEach(dir => {\r\n                let word = getWordAtSquare(grid, neighbor.row, neighbor.col, dir)!;\r\n                if (word !== undefined && !section.words.has(wordKey(word))) {\r\n                    section.words.set(wordKey(word), true);\r\n                    let squares = getSquaresForWord(grid, word);\r\n                    squares.forEach(wsq => {\r\n                        section.squares.set(squareKey(wsq), true);\r\n                    });\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    let sections = new Map<number, Section>();\r\n    let usedSquares = new Map<string, boolean>();\r\n    let nextSectionId = 1;\r\n\r\n    // add full grid section\r\n    let fullSection = makeNewSection(0);\r\n    forAllGridSquares(grid, sq => {\r\n        if (!isBlackSquare(sq)) fullSection.squares.set(squareKey(sq), true);\r\n    });\r\n    grid.words.forEach(w => {\r\n        fullSection.words.set(wordKey(w), true);\r\n    });\r\n    sections.set(0, fullSection);\r\n\r\n    // populate sections\r\n    forAllGridSquares(grid, sq => {\r\n        if (!usedSquares.has(squareKey(sq)) && isOpenSquare(grid, sq)) {\r\n            let newSection = makeNewSection(nextSectionId);\r\n            iterateSection(newSection, grid, sq, usedSquares);\r\n            if (newSection.openSquareCount === 1) return;\r\n            sections.set(newSection.id, newSection);\r\n            nextSectionId++;\r\n        }\r\n    });\r\n    if (sections.size === 2) sections.delete(1);\r\n\r\n    // populate stackWords\r\n    sections.forEach(section => {\r\n        section.stackWords = new Map<string, boolean>();\r\n\r\n        section.words.forEach((_, key) => {\r\n            if (section.stackWords.has(key)) return;\r\n\r\n            let word = grid.words.get(key)!;\r\n            let stackedNeighbors = mapKeys(section.words).filter(otherKey => {\r\n                if (otherKey === key) return false;\r\n\r\n                let otherWord = grid.words.get(otherKey)!;\r\n                if (isAcross(word) && isAcross(otherWord) && Math.abs(word.start[0] - otherWord.start[0]) === 1) {\r\n                    let intersectionCount = Math.min(word.end[1], otherWord.end[1]) - Math.max(word.start[1], otherWord.start[1]) + 1;\r\n                    return intersectionCount >= 5;\r\n                }\r\n                if (!isAcross(word) && !isAcross(otherWord) && Math.abs(word.start[1] - otherWord.start[1]) === 1) {\r\n                    let intersectionCount = Math.min(word.end[0], otherWord.end[0]) - Math.max(word.start[0], otherWord.start[0]) + 1;\r\n                    return intersectionCount >= 5;\r\n                }\r\n                return false;\r\n            }); \r\n\r\n            if (stackedNeighbors.length > 0) {\r\n                section.stackWords.set(key, true);\r\n                stackedNeighbors.forEach(sk => {\r\n                    section.stackWords.set(sk, true);\r\n                });\r\n            }\r\n        });\r\n    });\r\n\r\n    // populate neighboringCrosses\r\n    sections.forEach(section => {\r\n        section.words.forEach((_, key) => {\r\n            let word = grid.words.get(key)!;\r\n            let crosses = getAllCrosses(grid, word);\r\n            crosses.forEach(cross => {\r\n                let crossKey = wordKey(cross);\r\n                if (!section.words.has(crossKey))\r\n                    section.neighboringCrosses.set(crossKey, true);\r\n            });\r\n        });\r\n    });\r\n\r\n    // calculate word order\r\n    sections.forEach(section => {\r\n        if (section.id === 0) {\r\n            let wordOrder = [] as string[];\r\n            let usedWords = new Map<string, boolean>();\r\n            let orderedSections = calculateSectionOrder(mapValues(sections));\r\n            orderedSections.forEach(id => {\r\n                if (id === 0 && sections.size > 1) return;\r\n                let secOrder = calculateWordOrder(grid, sections.get(id)!);\r\n                wordOrder.push(...secOrder.filter(wk => !usedWords.has(wk)));\r\n                secOrder.forEach(wk => {usedWords.set(wk, true);});\r\n            });\r\n            mapKeys(section.words).filter(wKey => !usedWords.has(wKey)).forEach(wk => {\r\n                wordOrder.push(wk);\r\n            });\r\n            section.wordOrder = wordOrder;\r\n            return;\r\n        }\r\n\r\n        section.wordOrder = calculateWordOrder(grid, section);\r\n    });\r\n\r\n    // calculate connections\r\n    sections.forEach(section => {\r\n        sections.forEach((sec, id) => {\r\n            if (id === section.id) return;\r\n            if (mapKeys(sec.words).find(wk => section.words.has(wk)))\r\n                section.connections.set(id, true);\r\n        });\r\n    });\r\n\r\n    return sections;\r\n}\r\n\r\nexport function calculateSectionOrder(sections: Section[]): number[] {\r\n    return sections.sort((a, b) => {\r\n        if (a.id === 0) return -1;\r\n        if (b.id === 0) return 1;\r\n        if (a.connections.size !== b.connections.size) return b.connections.size - a.connections.size;\r\n        return b.squares.size - a.squares.size;\r\n    }).map(sec => sec.id);\r\n}\r\n\r\nfunction calculateWordOrder(grid: GridState, section: Section): string[] {\r\n    function wordsSort(a: GridWord, b: GridWord): number {\r\n        if (wordLength(a) !== wordLength(b)) return wordLength(b) - wordLength(a);\r\n        return a.direction === WordDirection.Across ? a.start[0] - b.start[0] : a.start[1] - b.start[1];\r\n    }\r\n\r\n    function iterateWordGroup(group: GridWord[]) {\r\n        if (group.length === 0) return;\r\n        if (group.length === 1) {\r\n            wordOrder.push(wordKey(group[0]));\r\n            usedWords.set(wordKey(group[0]), true);\r\n            return;\r\n        }\r\n\r\n        let centerIndex = Math.floor((rowOrCol(group[group.length-1]) - rowOrCol(group[0])) / 2);\r\n        wordOrder.push(wordKey(group[centerIndex]));\r\n        usedWords.set(wordKey(group[centerIndex]), true);\r\n        iterateWordGroup(group.slice(0, centerIndex));\r\n        iterateWordGroup(group.slice(centerIndex + 1));\r\n    }\r\n\r\n    let wordOrder = [] as string[];\r\n    let usedWords = new Map<string, boolean>();\r\n\r\n    // stack words\r\n    if (section.stackWords.size > 0) {\r\n        let acrossSortedStackWords = mapKeys(section.stackWords).map(wKey => grid.words.get(wKey)!)\r\n            .filter(word => word.direction === WordDirection.Across).sort(wordsSort);\r\n        let downSortedStackWords = mapKeys(section.stackWords).map(wKey => grid.words.get(wKey)!)\r\n            .filter(word => word.direction === WordDirection.Down).sort(wordsSort);\r\n        let longestStack = downSortedStackWords.length === 0 ? acrossSortedStackWords :\r\n            acrossSortedStackWords.length === 0 ? downSortedStackWords :\r\n            wordLength(acrossSortedStackWords[0]) >= wordLength(downSortedStackWords[0]) ? acrossSortedStackWords :\r\n            downSortedStackWords;\r\n        let otherStack = longestStack === acrossSortedStackWords ? downSortedStackWords : acrossSortedStackWords;\r\n        [longestStack, otherStack].forEach(stack => {\r\n            for (let i = 0; i < stack.length; i++) {\r\n                let word = stack[i];\r\n                let length = wordLength(word);\r\n                let curGroup = [word];\r\n                let prevRowOrCol = rowOrCol(word);\r\n                for (let j = i+1; j < stack.length && wordLength(stack[j]) === length; j++) {\r\n                    let newWord = stack[j];\r\n                    let newRowOrCol = rowOrCol(newWord);\r\n                    if (newRowOrCol - prevRowOrCol === 1) {\r\n                        curGroup.push(newWord);\r\n                        prevRowOrCol = newRowOrCol;\r\n                        i++;\r\n                    }\r\n                    else break;\r\n                }\r\n    \r\n                iterateWordGroup(curGroup);\r\n            }\r\n        });\r\n    }\r\n\r\n    // restOfWords\r\n    let remainingWords = mapKeys(section.words).filter(wKey => !usedWords.has(wKey))\r\n        .map(wKey => grid.words.get(wKey)!).sort(wordsSort);\r\n    remainingWords.forEach(word => {\r\n        wordOrder.push(wordKey(word));\r\n    });\r\n\r\n    return wordOrder;\r\n}\r\n\r\nfunction rowOrCol(word: GridWord): number {\r\n    return word.direction === WordDirection.Across ? word.start[0] : word.start[1];\r\n}\r\n\r\nfunction isOpenSquare(grid: GridState, sq: GridSquare): boolean {\r\n    let neighbors = getNeighboringSquares(grid, sq);\r\n    return neighbors.length === 8 && !neighbors.find(n => isBlackSquare(n));\r\n}\r\n\r\nfunction getNeighboringSquares(grid: GridState, sq: GridSquare): GridSquare[] {\r\n    let ret = [] as GridSquare[];\r\n    let nClear = sq.row > 0;\r\n    let sClear = sq.row < grid.height-1;\r\n    let wClear = sq.col > 0;\r\n    let eClear = sq.col < grid.width-1;\r\n\r\n    if (nClear && wClear) ret.push(grid.squares[sq.row-1][sq.col-1]);\r\n    if (nClear) ret.push(grid.squares[sq.row-1][sq.col]);\r\n    if (nClear && eClear) ret.push(grid.squares[sq.row-1][sq.col+1]);\r\n    if (eClear) ret.push(grid.squares[sq.row][sq.col+1]);\r\n    if (sClear && eClear) ret.push(grid.squares[sq.row+1][sq.col+1]);\r\n    if (sClear) ret.push(grid.squares[sq.row+1][sq.col]);\r\n    if (sClear && wClear) ret.push(grid.squares[sq.row+1][sq.col-1]);\r\n    if (wClear) ret.push(grid.squares[sq.row][sq.col-1]);\r\n\r\n    return ret;\r\n}\r\n\r\nexport function newSectionCandidate(node: FillNode, section: Section): SectionCandidate {\r\n    let grid = node.endGrid;\r\n    return {\r\n        sectionId: section.id,\r\n        grid: grid,\r\n        score: calculateSectionCandidateScore(grid, section),\r\n        iffyEntry: node.iffyWordKey ? getEntryAtWordKey(grid, node.iffyWordKey) : undefined,\r\n        isFilteredOut: false,\r\n    } as SectionCandidate;\r\n}\r\n\r\nexport function calculateSectionCandidateScore(grid: GridState, section: Section): number {\r\n    let total = 0;\r\n    let foundIffy = false;\r\n    section.words.forEach((_, wordKey) => {\r\n        let word = grid.words.get(wordKey)!;\r\n        let squares = getSquaresForWord(grid, word);\r\n        let str = getLettersFromSquares(squares);\r\n        let score = getWordScore(str);\r\n        if (score < 3) foundIffy = true;\r\n        total += score;\r\n    });\r\n\r\n    if (!foundIffy) total *= 10;\r\n    return total / section.words.size;\r\n}\r\n\r\nconst natoAlphabet = {\r\n    \"A\": \"Alfa\",   \"B\": \"Bravo\",   \"C\": \"Charlie\",\r\n    \"D\": \"Delta\",  \"E\": \"Echo\",    \"F\": \"Foxtrot\",\r\n    \"G\": \"Golf\",   \"H\": \"Hotel\",   \"I\": \"India\",\r\n    \"J\": \"Juliett\",\"K\": \"Kilo\",    \"L\": \"Lima\",\r\n    \"M\": \"Mike\",   \"N\": \"November\",\"O\": \"Oscar\",\r\n    \"P\": \"Papa\",   \"Q\": \"Quebec\",  \"R\": \"Romeo\",\r\n    \"S\": \"Sierra\", \"T\": \"Tango\",   \"U\": \"Uniform\",\r\n    \"V\": \"Victor\", \"W\": \"Whiskey\", \"X\": \"X-ray\",\r\n    \"Y\": \"Yankee\", \"Z\": \"Zulu\"\r\n} as any;\r\n\r\nexport function getPhoneticName(n: number): string {\r\n    if (n === 0) return \"Full Grid\";\r\n    return n <= 26 ? natoAlphabet[String.fromCharCode(n+64)] : \"Section \" + n.toString();\r\n}\r\n\r\nexport function sectionCandidateKey(section: Section, grid: GridState): string {\r\n    let keys = mapKeys(section.squares).sort();\r\n    return keys.map(k => getSquareAtKey(grid, k).content!).join(\"\");\r\n}\r\n\r\nexport function makeNewSection(id: number): Section {\r\n    return {\r\n        id: id,\r\n        openSquareCount: 0,\r\n        squares: new Map<string, boolean>(),\r\n        words: new Map<string, boolean>(),\r\n        stackWords: new Map<string, boolean>(),\r\n        wordOrder: [],\r\n        neighboringCrosses: new Map<string, boolean>(),\r\n        candidates: new Map<string, SectionCandidate>(),\r\n        connections: new Map<number, boolean>(),\r\n        comboPermsQueue: [],\r\n        comboPermsUsed: new Map<string, boolean>(),\r\n    } as Section;\r\n}\r\n\r\nexport function getLongestStackWord(section: Section): GridWord {\r\n    function getLongest(wordKeys: string[]): GridWord {\r\n        return wordKeys.map(w => grid.words.get(w)!).sort((a, b) => wordLength(b) - wordLength(a))[0];\r\n    }\r\n\r\n    let grid = getGrid();\r\n    if (section.stackWords.size > 0)\r\n        return getLongest(mapKeys(section.stackWords))\r\n    else\r\n        return getLongest(mapKeys(section.words));\r\n}\r\n\r\nexport function getSelectedSections(): Section[] {\r\n    if (Globals.selectedSectionIds!.size === 0) return [Globals.sections!.get(0)!];\r\n    return mapKeys(Globals.selectedSectionIds!).sort().map(id => Globals.sections!.get(id)!);\r\n}\r\n\r\nexport function getSelectedSectionCandidates(): SectionCandidate[] {\r\n    let ret = [] as SectionCandidate[];\r\n    Globals.sections!.forEach((section, _) => {\r\n        Globals.selectedSectionCandidateKeys!.forEach((scKey, _) => {\r\n            if (section.candidates.has(scKey))\r\n                ret.push(section.candidates.get(scKey)!);\r\n        });\r\n    });\r\n    return ret;\r\n}\r\n\r\nexport function getSelectedSectionCandidatesWithWord(wordKey: string): SectionCandidate[] {\r\n    let ret = [] as SectionCandidate[];\r\n    getSelectedSectionCandidates().forEach(sc => {\r\n        let section = Globals.sections!.get(sc.sectionId)!;\r\n        if (section.words.has(wordKey))\r\n            ret.push(sc);\r\n    });\r\n    return ret;\r\n}\r\n\r\nexport function getSelectedSectionCandidatesWithSquare(squareKey: string): SectionCandidate[] {\r\n    let ret = [] as SectionCandidate[];\r\n    getSelectedSectionCandidates().forEach(sc => {\r\n        let section = Globals.sections!.get(sc.sectionId)!;\r\n        if (section.squares.has(squareKey))\r\n            ret.push(sc);\r\n    });\r\n    return ret;\r\n}\r\n\r\nexport function getSectionsWithSelectedCandidate(): Section[] {\r\n    return getSelectedSectionCandidates().map(sc => getSectionWithCandidate(sc));\r\n}\r\n\r\nexport function getSectionWithCandidate(sc: SectionCandidate): Section {\r\n    return Globals.sections!.get(sc.sectionId)!;\r\n}\r\n\r\nexport function getUnfilteredSectionCandidates(section: Section): SectionCandidate[] {\r\n    return mapValues(section.candidates).filter(sc => !sc.isFilteredOut);\r\n}\r\n\r\nexport function getSectionsWithWord(word: GridWord): Section[] {\r\n    return mapValues(Globals.sections!).filter(sec => sec.id > 0 && sec.words.has(wordKey(word)));\r\n}\r\n","import { ContentType } from \"../models/ContentType\";\r\nimport { FillNode } from \"../models/FillNode\";\r\nimport { GridSquare } from \"../models/GridSquare\";\r\nimport { GridState } from \"../models/GridState\";\r\nimport { getAllCrosses } from \"./fill\";\r\nimport { generateConstraintInfoForSquares, getLettersFromSquares } from \"./grid\";\r\nimport { sectionCandidateKey } from \"./section\";\r\nimport { deepClone, getSectionCandidatesFromKeys, getSquaresForWord, isWordFull, mapKeys } from \"./util\";\r\nimport Globals from './windowService';\r\n\r\nexport function processAndInsertChosenEntry(node: FillNode, contentType?: ContentType) {\r\n    if (contentType === undefined) contentType = ContentType.Autofill;\r\n    if (!node.chosenEntry) return false;\r\n\r\n    let grid = deepClone(node.startGrid) as GridState;\r\n    let word = node.fillWord!;\r\n    let wordSquares = getSquaresForWord(grid, word);\r\n    let crosses = getAllCrosses(grid, word);\r\n\r\n    wordSquares.forEach((sq, i) => {\r\n        sq.content = node.chosenEntry!.word[i];\r\n        if ([ContentType.Autofill, ContentType.ChosenSection, ContentType.HoverChosenWord].includes(sq.contentType))\r\n            sq.contentType = contentType!;\r\n    });\r\n    grid.usedWords.set(getLettersFromSquares(wordSquares), true);\r\n    node.iffyWordKey = node.chosenEntry!.iffyWordKey;\r\n\r\n    if (contentType === ContentType.ChosenWord) {\r\n        removeNonmatchingSectionCandidates(grid, wordSquares, node.chosenEntry!.word);\r\n    }  \r\n\r\n    crosses.forEach(cross => {\r\n        let newSquares = getSquaresForWord(grid, cross);\r\n        generateConstraintInfoForSquares(newSquares);\r\n\r\n        if (isWordFull(newSquares)) {\r\n            grid.usedWords.set(getLettersFromSquares(newSquares), true);\r\n        }\r\n    });\r\n    \r\n    node.endGrid = grid;\r\n}\r\n\r\nfunction removeNonmatchingSectionCandidates(grid: GridState, newSquares: GridSquare[], chosenEntry: string) {\r\n    let sectionCandidates = getSectionCandidatesFromKeys(mapKeys(grid.userFilledSectionCandidates));\r\n    sectionCandidates.forEach(sc => {\r\n        let section = Globals.sections!.get(sc.sectionId)!;\r\n        newSquares.forEach((sq, i) => {\r\n            if (sc.grid.squares[sq.row][sq.col].content !== chosenEntry[i])\r\n                grid.userFilledSectionCandidates.delete(sectionCandidateKey(section, grid));\r\n        });\r\n    });\r\n}\r\n","// https://itnext.io/priority-queue-in-typescript-6ef23116901\r\n\r\n  interface Node<T> {\r\n    key: number\r\n    value: T\r\n  }\r\n\r\n  export interface PriorityQueue<T> {\r\n      isEmpty: () => boolean,\r\n      peek: () => T | null,\r\n      size: () => number,\r\n      insert: (item: T, prio: number) => void,\r\n      pop: () => T | null,\r\n  }\r\n  \r\n  export const priorityQueue = <T>(): PriorityQueue<T> => {\r\n    let heap: Node<T>[] = []\r\n\r\n    const parent = (index: number) => Math.floor((index - 1) / 2)\r\n    const left = (index: number) => 2 * index + 1\r\n    const right = (index: number) =>  2 * index + 2\r\n    const hasLeft = (index: number) => left(index) < heap.length\r\n    const hasRight = (index: number) => right(index) < heap.length\r\n\r\n    const swap = (a: number, b: number) => {\r\n        let temp = heap[a];\r\n        heap[a] = heap[b];\r\n        heap[b] = temp;\r\n    }\r\n  \r\n    return {\r\n      \r\n      isEmpty: () => heap.length === 0,\r\n  \r\n      peek: () => heap.length === 0 ? null : heap[0].value,\r\n      \r\n      size: () => heap.length,\r\n\r\n      insert: (item, prio) => {\r\n        heap.push({key: prio, value: item})\r\n  \r\n        let i = heap.length -1\r\n        while(i > 0) {\r\n          const p = parent(i)\r\n          if(heap[p].key > heap[i].key) break\r\n          const tmp = heap[i]\r\n          heap[i] = heap[p]\r\n          heap[p] = tmp\r\n          i = p\r\n        }\r\n      },\r\n\r\n      pop: () => {\r\n        if(heap.length === 0) return null\r\n        \r\n        swap(0, heap.length - 1)\r\n        const item = heap.pop()\r\n  \r\n        let current = 0\r\n        while(hasLeft(current)) {\r\n          let largerChild = left(current)\r\n          if(hasRight(current) && heap[right(current)].key > heap[left(current)].key) \r\n            largerChild = right(current)\r\n  \r\n          if(heap[largerChild].key < heap[current].key) break\r\n  \r\n          swap(current, largerChild)\r\n          current = largerChild\r\n        }\r\n  \r\n        return item!.value\r\n      }\r\n    }\r\n  }\r\n  ","export enum FillStatus {\r\n    NoWordList,\r\n    Ready,\r\n    Running,\r\n    Complete,\r\n}\r\n","import { ContentType } from '../models/ContentType';\r\nimport { EntryCandidate } from '../models/EntryCandidate';\r\nimport { FillNode } from '../models/FillNode';\r\nimport { GridSquare } from '../models/GridSquare';\r\nimport { GridState } from '../models/GridState';\r\nimport { GridWord } from '../models/GridWord';\r\nimport { QualityClass } from '../models/QualityClass';\r\nimport { Section } from '../models/Section';\r\nimport { WordDirection } from '../models/WordDirection';\r\nimport { populateAndScoreEntryCandidates } from './entryCandidates';\r\nimport { processAndInsertChosenEntry } from './insertEntry';\r\nimport { PriorityQueue, priorityQueue } from './priorityQueue';\r\nimport { getSectionString, getSectionsWithWord, insertSectionCandidateIntoGrid, newSectionCandidate } from './section';\r\nimport { deepClone, getSquaresForWord, mapKeys, isWordFull, \r\n    getWordAtSquare, otherDir, mapValues, getSection, getGrid, wordKey } from './util';\r\nimport Globals from './windowService';\r\n\r\nexport function fillSectionWord(): boolean {\r\n    let section = getSection();\r\n    let fillQueue = section.fillQueue;\r\n    if (!fillQueue) {\r\n        let newFillQueue = priorityQueue<FillNode>();\r\n        populateSeedNodes(newFillQueue);\r\n        fillQueue = newFillQueue;\r\n        section.fillQueue = newFillQueue;\r\n    }\r\n\r\n    let node = fillQueue.peek()!;\r\n    if (!node) {\r\n        populateSeedNodes(fillQueue);\r\n        node = fillQueue.peek()!;\r\n        if (!node) {\r\n            return false;\r\n        }\r\n    }\r\n    while (node.needsNewPriority || node.shouldBeDeleted) {\r\n        node.needsNewPriority = false;\r\n        fillQueue.pop();\r\n        if (!node.shouldBeDeleted) fillQueue.insert(node, calculateNodePriority(node));\r\n        node = fillQueue.peek()!;\r\n        if (!node) return false;\r\n    }\r\n    while (node.isChainNode && node.chainId! !== Globals.curChainId!) {\r\n        fillQueue.pop();\r\n        node = fillQueue.peek()!;\r\n        if (!node) return false;\r\n    }\r\n\r\n    if (!node.isChainNode && Globals.activeGrid !== node.startGrid) {\r\n        Globals.activeGrid = node.startGrid;\r\n        return true;\r\n    }\r\n\r\n    let success = processSectionNode(node, section);\r\n    if (success) {\r\n        let sectionString = getSectionString(node.endGrid, section);\r\n        // is section filled?\r\n        if (!sectionString.includes(\"-\")) {\r\n            let newSecCandidateFound = false;\r\n            if (!section.candidates.has(sectionString)) {\r\n                let newCandidate = newSectionCandidate(node, section);\r\n                section.candidates.set(sectionString, newCandidate);\r\n                Globals.activeGrid = node.endGrid;\r\n                newSecCandidateFound = true;\r\n            }\r\n            \r\n            invalidateChainNode(node, newSecCandidateFound);\r\n            fillQueue.pop();\r\n            return true;\r\n        }\r\n\r\n        Globals.activeGrid = node.endGrid;\r\n        let newNode = makeNewNode(node.endGrid, node.depth + 1, true, node);\r\n        \r\n        if (section.id === 0) {\r\n            let nextFillWord = selectWordToFill(node, getSection());\r\n            let curSections = getSectionsWithWord(node.fillWord!);\r\n            let nextSections = getSectionsWithWord(nextFillWord!);\r\n            if (curSections.length > 0 && !curSections.find(cs => nextSections.find(ns => ns.id === cs.id))) {\r\n                newNode = makeNewNode(node.endGrid, node.depth + 1, false, node, true);\r\n                Globals.curChainId!++;\r\n            }\r\n        }\r\n        \r\n        fillQueue.insert(newNode, calculateNodePriority(newNode));\r\n    }\r\n    else {\r\n        fillQueue.pop();\r\n        if (node.isChainNode) invalidateChainNode(node);\r\n        fillSectionWord();\r\n    }\r\n\r\n    Globals.selectedWordNode = undefined;\r\n    return true;\r\n}\r\n\r\nfunction invalidateChainNode(node: FillNode, newSecCandidateFound?: boolean) {\r\n    if (newSecCandidateFound === undefined) newSecCandidateFound = false;\r\n\r\n    let parent = node.parent!;\r\n    if (!parent) return;\r\n\r\n    let prevCandidate = parent.chosenEntry!;\r\n    if (parent.isChainNode) {\r\n        if (prevCandidate)\r\n            prevCandidate.wasChainFailure = true;\r\n        parent.backtracks++;\r\n    }\r\n    else {\r\n        if (prevCandidate)\r\n            prevCandidate.hasBeenChained = true;\r\n    }\r\n\r\n    parent.chosenEntry = undefined;\r\n    parent.iffyWordKey = parent.parent ? parent.parent.iffyWordKey : undefined;\r\n    parent.endGrid = deepClone(parent.startGrid);\r\n\r\n    if (parent.backtracks >= 3) {\r\n        if (parent.parent && !parent.parent.isChainNode) {\r\n            parent.isChainNode = false;\r\n            parent.needsNewPriority = true;\r\n            Globals.curChainId!++;\r\n        }\r\n            \r\n        invalidateChainNode(parent);\r\n    }\r\n\r\n    if (newSecCandidateFound) {\r\n        if (node.iffyWordKey && node.chainBaseNode!.chainIffyCandidates < 24) {\r\n            node.chainBaseNode!.chainIffyCandidates++;\r\n            return;\r\n        }\r\n        else if (!node.iffyWordKey && node.chainBaseNode!.chainGoodCandidates < 4) {\r\n            node.chainBaseNode!.chainGoodCandidates++;\r\n            return;\r\n        }\r\n\r\n        let curNode = parent;\r\n        while (curNode.parent && (curNode.parent.isChainNode || curNode.parent.isSectionBase)) {\r\n            if (curNode.isSectionBase) curNode.shouldBeDeleted = true;\r\n            curNode = curNode.parent!;\r\n        }\r\n        curNode.isChainNode = false;\r\n        curNode.needsNewPriority = true;\r\n        Globals.curChainId!++;\r\n    }\r\n}\r\n\r\nfunction calculateNodePriority(node: FillNode): number {\r\n    let grid = node.startGrid;\r\n    let wordScore = 0;\r\n    grid.usedWords.forEach((_, word) => {\r\n        wordScore += getWordScore(word);\r\n    });\r\n\r\n    let situationScore: number;\r\n    if (node.isChainNode)\r\n        situationScore = 1e8 + 10000*(node.depth+1);\r\n    else if (node.isSectionBase)\r\n        situationScore = (10000 + node.depth) * 10000;\r\n    else\r\n        situationScore = (10000 - node.depth) * 10000;\r\n\r\n    return wordScore + situationScore;\r\n}\r\n\r\nfunction populateSeedNodes(fillQueue: PriorityQueue<FillNode>) {\r\n    let grid = getGrid();\r\n    let selectedSectionIds = Globals.selectedSectionIds!.size > 0 ? mapKeys(Globals.selectedSectionIds!) : [0];\r\n    let activeSection = getSection();\r\n    let connectionIds = mapKeys(activeSection.connections)\r\n        .filter(id => selectedSectionIds.includes(id) && Globals.sections!.get(id)!.selectedCandidate === undefined\r\n            && Globals.sections!.get(id)!.candidates.size > 0)\r\n        .sort();\r\n    let candidateCounts = connectionIds.map(i => Globals.sections!.get(i)!.candidates.size);\r\n    \r\n    getNewPermutations(candidateCounts, activeSection);\r\n    activeSection.comboPermsQueue.forEach(perm => {\r\n        let node = makeNewNode(grid, 0, false, undefined);\r\n        if (perm[0] === -1) {\r\n            fillQueue.insert(node, calculateNodePriority(node));\r\n            return;\r\n        }\r\n        let wasSuccess = true;\r\n        for (let i = 0; i < perm.length; i++) {\r\n            let sortedCandidates = mapValues(Globals.sections!.get(connectionIds[i])!.candidates)\r\n                .sort((a, b) => b.score - a.score);\r\n            let candidate = sortedCandidates[perm[i]];\r\n            if (!insertSectionCandidateIntoGrid(node.startGrid, candidate, ContentType.Autofill))\r\n                wasSuccess = false;\r\n        }\r\n        if (wasSuccess)\r\n            fillQueue.insert(node, calculateNodePriority(node));\r\n    });\r\n}\r\n\r\nfunction getNewPermutations(candidateCounts: number[], section: Section) {\r\n    function comboKey(perm: number[]): string {\r\n        return \"[\" + perm.map(n => n.toString()).join(\",\") + \"]\";\r\n    }\r\n\r\n    if (section.comboPermsUsed.size > 0 && section.comboPermsQueue.length > 0 && section.comboPermsQueue[0][0] === -1)\r\n        section.comboPermsQueue.shift();\r\n    if (section.comboPermsUsed.size > 0 && section.comboPermsQueue.length === 0) return;\r\n\r\n    if (candidateCounts.length === 0) {\r\n        let defaultCombo = [-1];\r\n        section.comboPermsQueue = [defaultCombo];\r\n        section.comboPermsUsed.set(comboKey(defaultCombo), true);\r\n        return;\r\n    }\r\n\r\n    if (section.comboPermsUsed.size === 0) {\r\n        let allOnes = [] as number[];\r\n        for(let i = 0; i < candidateCounts.length; i++) allOnes.push(1);\r\n        section.comboPermsQueue = [allOnes];\r\n        section.comboPermsUsed.set(comboKey(allOnes), true);\r\n        return;\r\n    }\r\n\r\n    while(true) {\r\n        let perm = section.comboPermsQueue.shift()!;\r\n        if (!perm) break;\r\n        let foundNew = false;\r\n\r\n        for(let i = 0; i < perm.length; i++) {\r\n            if (perm[i] === candidateCounts[i] - 1) continue;\r\n    \r\n            let newPerm = deepClone(perm);\r\n            newPerm[i]++;\r\n            let newPermKey = comboKey(newPerm);\r\n            if (section.comboPermsUsed.has(newPermKey)) continue;\r\n\r\n            section.comboPermsUsed.set(newPermKey, true);\r\n            foundNew = true;\r\n            section.comboPermsQueue.push(newPerm);\r\n        }\r\n\r\n        if (foundNew) break;\r\n    }\r\n}\r\n\r\nexport function processSectionNode(node: FillNode, section: Section): boolean {\r\n    if (!node.fillWord)\r\n        node.fillWord = selectWordToFill(node, section);\r\n\r\n    if (node.anchorSquareKeys.length === 0 || node.anchorCombosLeft.length > 0) {\r\n        let areEligibleCandidates = populateAndScoreEntryCandidates(node, false);\r\n        if (!areEligibleCandidates) return false;\r\n    }\r\n\r\n    let eligibleCandidates = getEligibleCandidates(node);\r\n    if (eligibleCandidates.length > 0) {\r\n        node.chosenEntry = chooseEntryFromCandidates(eligibleCandidates);\r\n        processAndInsertChosenEntry(node);\r\n        return true;\r\n    }\r\n    \r\n    return false;\r\n}\r\n\r\nexport function makeNewNode(grid: GridState, depth: number, isChainNode: boolean, parent: FillNode | undefined, \r\n    isSectionBase?: boolean): FillNode {\r\n    return {\r\n        startGrid: deepClone(grid),\r\n        endGrid: deepClone(grid),\r\n        entryCandidates: [],\r\n        depth: depth,\r\n        isChainNode: isChainNode,\r\n        isSectionBase: !!isSectionBase,\r\n        backtracks: 0,\r\n        parent: parent,\r\n        chainBaseNode: isChainNode ? (parent!.isChainNode ? parent!.chainBaseNode : parent!) : undefined,\r\n        needsNewPriority: false,\r\n        shouldBeDeleted: false,\r\n        anchorSquareKeys: [],\r\n        anchorCombosLeft: [],\r\n        viableLetterCounts: new Map<string, Map<string, number>>(),\r\n        iffyWordKey: parent ? parent.iffyWordKey : undefined,\r\n        chainGoodCandidates: parent ? parent.chainGoodCandidates : 0,\r\n        chainIffyCandidates: parent ? parent.chainIffyCandidates : 0,\r\n        chainId: Globals.curChainId!,\r\n        topCrossScore: 0,\r\n        topMinCrossScore: 0,\r\n    } as FillNode;\r\n}\r\n\r\nfunction selectWordToFill(node: FillNode, section: Section): GridWord | undefined {\r\n    let grid = node.startGrid;\r\n\r\n    for (let key of section.wordOrder) {\r\n        let word = grid.words.get(key)!;\r\n        let squares = getSquaresForWord(grid, word);\r\n        if (wordKey(word) !== node.iffyWordKey && !isWordFull(squares))\r\n            return word;\r\n    }\r\n\r\n    return undefined;\r\n}\r\n\r\nexport function getPositionOfCross(wordSquares: GridSquare[], crossSquares: GridSquare[], dir: WordDirection): number {\r\n    return dir === WordDirection.Across ? \r\n            wordSquares[0].row - crossSquares[0].row : \r\n            wordSquares[0].col - crossSquares[0].col;\r\n}\r\n\r\nexport function getAllCrosses(grid: GridState, word: GridWord): GridWord[] {\r\n    let squares = getSquaresForWord(grid, word);\r\n    let crosses = squares\r\n        .map(sq => getWordAtSquare(grid, sq.row, sq.col, otherDir(word.direction)))\r\n        .filter(w => w).map(w => w!);\r\n    return crosses.length > 0 ? crosses : [];\r\n}\r\n\r\nexport function getUnfilledCrosses(grid: GridState, word: GridWord): GridWord[] {\r\n    let squares = getSquaresForWord(grid, word);\r\n    let crosses = squares\r\n        .map(sq => getWordAtSquare(grid, sq.row, sq.col, otherDir(word.direction)))\r\n        .filter(w => w && !isWordFull(getSquaresForWord(grid, w)))\r\n        .map(w => w!);\r\n    return crosses.length > 0 ? crosses : [];\r\n}\r\n\r\nexport function getEligibleCandidates(node: FillNode): EntryCandidate[] {\r\n    if (node.isChainNode) {\r\n        return node.entryCandidates.filter(ec => ec.isViable && !ec.wasChainFailure);\r\n    }\r\n    else {\r\n        return node.entryCandidates.filter(ec => ec.isViable && !ec.hasBeenChained);\r\n    }\r\n}\r\n\r\nfunction chooseEntryFromCandidates(candidates: EntryCandidate[]): EntryCandidate {\r\n    let topScore = candidates[0].score!;\r\n    let total = 0;\r\n    candidates.forEach(c => {\r\n        total += Math.pow(c.score / topScore, 4);\r\n    });\r\n\r\n    let roll = Math.random() * total;\r\n    let runningTotal = 0;\r\n    for (let can of candidates) {\r\n        runningTotal += Math.pow(can.score / topScore, 4);\r\n        if (runningTotal >= roll)\r\n            return can;\r\n    }\r\n\r\n    return candidates[0];\r\n}\r\n\r\nexport function getWordScore(word: string): number {\r\n    let qualityClass = Globals.qualityClasses!.get(word);\r\n    if (!qualityClass) return 0;\r\n\r\n    switch(qualityClass) {\r\n        case QualityClass.Lively: return 12;\r\n        case QualityClass.Normal: return 9;\r\n        case QualityClass.Crosswordese: return 3;\r\n        case QualityClass.Iffy: return 1;\r\n    }\r\n}\r\n","import { FillNode } from \"../models/FillNode\";\r\nimport { GridSquare } from \"../models/GridSquare\";\r\nimport { GridState } from \"../models/GridState\";\r\nimport { GridWord } from \"../models/GridWord\";\r\nimport { SquareType } from \"../models/SquareType\";\r\nimport { WordDirection } from \"../models/WordDirection\";\r\nimport Globals from './windowService';\r\nimport { getSquaresForWord, isBlackSquare, newWord, forAllGridSquares, isWordFull, isWordEmpty, getGrid, \r\n    isUserFilled, deepClone, wordKey, getWordAtSquare, getSquareAtKey, otherDir, squareKey, getSection, mapKeys, \r\n    fullAlphabet, letterListToLetterMatrix, letterMatrixToLetterList } from \"./util\";\r\nimport { SymmetryType } from \"../models/SymmetryType\";\r\nimport { makeNewNode } from \"./fill\";\r\nimport { ContentType } from \"../models/ContentType\";\r\nimport { processAndInsertChosenEntry } from \"./insertEntry\";\r\nimport { queryIndexedWordList } from \"./wordList\";\r\nimport { populateAndScoreEntryCandidates, populateNoHeuristicEntryCandidates } from \"./entryCandidates\";\r\nimport { getSectionsWithSelectedCandidate, getSectionWithCandidate, \r\n    getSelectedSectionCandidatesWithSquare } from \"./section\";\r\nimport { FillStatus } from \"../models/FillStatus\";\r\nimport { SectionCandidate } from \"../models/SectionCandidate\";\r\n\r\nexport function populateWords(grid: GridState) {\r\n    function processSquare(grid: GridState, row: number, col: number, dir: WordDirection) {\r\n        let sq = grid.squares[row][col];\r\n\r\n        if (isBlackSquare(sq)) return;\r\n        if (!currentWord.number && !sq.number) return; // unchecked square\r\n\r\n        if (!currentWord.number) {\r\n            currentWord.number = sq.number;\r\n            currentWord.direction = dir;\r\n            currentWord.start = [row, col]; \r\n        }\r\n\r\n        currentWord.end = [row, col];\r\n\r\n        let nextSq = dir === WordDirection.Across ? [row, col+1] : [row+1, col];\r\n        if (nextSq[0] === grid.height || nextSq[1] === grid.width || isBlackSquare(grid.squares[nextSq[0]][nextSq[1]])) {\r\n            if ((dir === WordDirection.Across && currentWord.end[1] - currentWord.start[1] > 0) ||\r\n                (dir === WordDirection.Down && currentWord.end[0] - currentWord.start[0] > 0))\r\n                grid.words.set(wordKey(currentWord), currentWord);\r\n            currentWord = newWord();\r\n        }\r\n    }\r\n\r\n    grid.words = new Map<string, GridWord>();\r\n\r\n    numberizeGrid(grid);\r\n\r\n    let currentWord: GridWord = newWord();\r\n    for (let row = 0; row < grid.height; row++) {\r\n        for (let col = 0; col < grid.width; col++) {\r\n            processSquare(grid, row, col, WordDirection.Across);\r\n        }\r\n    }\r\n\r\n    for (let col = 0; col < grid.width; col++) {\r\n        for (let row = 0; row < grid.height; row++) {\r\n            processSquare(grid, row, col, WordDirection.Down);\r\n        }\r\n    }\r\n}\r\n\r\nexport function updateGridConstraintInfo(grid: GridState) {\r\n    grid.usedWords = new Map<string, boolean>();\r\n    forAllGridSquares(grid, sq => { sq.viableLetters = undefined; });\r\n\r\n    if (!Globals.wordList) return;\r\n\r\n    let wordKeys = mapKeys(grid.words);\r\n    let sortedWordKeys = wordKeys.filter(k => k.includes(\"A\")).concat(wordKeys.filter(k => k.includes(\"D\")));\r\n    sortedWordKeys.forEach(wordKey => {\r\n        let word = grid.words.get(wordKey)!;\r\n        let newSquares = deepClone(getSquaresForWord(grid, word)) as GridSquare[];\r\n        let letters = getLettersFromSquares(newSquares);\r\n        if (!letters.includes(\"-\")) grid.usedWords.set(letters, true);\r\n        generateConstraintInfoForSquares(newSquares);\r\n        if (newSquares !== undefined && newSquares.length > 0) {\r\n            newSquares.forEach(ns => {\r\n                grid.squares[ns.row][ns.col] = ns;\r\n            });\r\n        }\r\n    });\r\n}\r\n\r\nfunction numberizeGrid(grid: GridState) {\r\n    var currentNumber = 1;\r\n\r\n    for(var row = 0; row < grid.height; row++) {\r\n        for (var col = 0; col < grid.width; col++) {\r\n            var sq = grid.squares[row][col];  \r\n            sq.number = undefined;\r\n\r\n            if (!isBlackSquare(sq)) {\r\n                let isAboveBlocked = (row === 0 || isBlackSquare(grid.squares![row-1][col]));\r\n                let isBelowBlocked = (row === grid.height-1 || isBlackSquare(grid.squares[row+1][col]));\r\n                let isLeftBlocked = (col === 0 || isBlackSquare(grid.squares[row][col-1]));\r\n                let isRightBlocked = (col === grid.width-1 || isBlackSquare(grid.squares[row][col+1]));\r\n\r\n                let isUnchecked = (isAboveBlocked && isBelowBlocked) || (isLeftBlocked && isRightBlocked);\r\n                let isUncheckedStart = (isAboveBlocked && isBelowBlocked && isLeftBlocked && !isRightBlocked) || \r\n                                       (isLeftBlocked && isRightBlocked && isAboveBlocked && !isBelowBlocked);\r\n                let isCheckedStart = isAboveBlocked || isLeftBlocked;\r\n\r\n                if ((isUnchecked && isUncheckedStart) || (!isUnchecked && isCheckedStart)) {\r\n                    sq.number = currentNumber++;\r\n                }\r\n            } \r\n        }\r\n    }\r\n}\r\n\r\nexport function generateConstraintInfoForSquares(squares: GridSquare[]) {\r\n    squares.forEach(sq => {\r\n        if (sq.content) {\r\n            sq.viableLetters = [sq.content];\r\n        }\r\n        else if (!sq.viableLetters) {\r\n            sq.viableLetters = deepClone(fullAlphabet);\r\n        }\r\n    });\r\n    if (isWordEmpty(squares) || isWordFull(squares)) return;\r\n\r\n    let pattern = getLettersFromSquares(squares);\r\n    let entryOptions = queryIndexedWordList(pattern);\r\n    if (entryOptions.length > 500) return;\r\n\r\n    for (let i = 0; i < squares.length; i++) {\r\n        let sq = squares[i];\r\n        if (sq.content) continue;\r\n        let curViableMatrix = sq.viableLetters ? letterListToLetterMatrix(sq.viableLetters) : Array<boolean>(26).fill(true);\r\n        let newViableMatrix = Array<boolean>(26).fill(false);\r\n\r\n        let letters = entryOptions.map(entry => entry[i]);\r\n        letters.forEach(ltr => {\r\n            if (sq.viableLetters && curViableMatrix[ltr.charCodeAt(0) - 65]) return;\r\n            setLettersArrayVal(newViableMatrix, ltr, true);\r\n        });\r\n        sq.viableLetters = letterMatrixToLetterList(newViableMatrix);\r\n    }\r\n}\r\n\r\nexport function getLettersArrayVal(arr: boolean[], ltr: string) {\r\n    return arr[ltr.charCodeAt(0) - 65];\r\n}\r\n\r\nexport function setLettersArrayVal(arr: boolean[], ltr: string, newVal: boolean) {\r\n    arr[ltr.charCodeAt(0) - 65] = newVal;\r\n}\r\n\r\nexport function getConstraintSquareSum(squares: GridSquare[]): number {\r\n    let total = 0;\r\n    squares.forEach(sq => {\r\n        total += sq.viableLetters ? sq.viableLetters.length : 0;\r\n    });\r\n    return total;\r\n}\r\n\r\nexport function getLettersFromSquares(squares: GridSquare[]): string {\r\n    return squares.map(sq => sq.content ? sq.content! : \"-\").join(\"\");\r\n}\r\n\r\nexport function gridToString(grid: GridState): string {\r\n    let chs: string[] = [];\r\n    forAllGridSquares(grid, sq => {\r\n        chs.push(isBlackSquare(sq) ? \".\" : sq.content ? sq.content : \"-\");\r\n    });\r\n    return chs.join(\"\");\r\n}\r\n\r\nexport function createNewGrid(width: number, height: number): GridState {\r\n    let squares: GridSquare[][] = [];\r\n\r\n    for (let row = 0; row < height; row++) {\r\n        squares.push([]);\r\n        for (let col = 0; col < width; col++) {\r\n            squares[row][col] = {\r\n                row: row,\r\n                col: col,\r\n                type: SquareType.White,\r\n                isCircled: false,\r\n                contentType: ContentType.Autofill,\r\n            } as GridSquare;\r\n        }\r\n    }\r\n\r\n    let grid: GridState = {\r\n        height: height,\r\n        width: width,\r\n        squares: squares,\r\n        words: new Map<string, GridWord>(),\r\n        usedWords: new Map<string, boolean>(),\r\n        userFilledSectionCandidates: new Map<string, boolean>(),\r\n    };\r\n\r\n    populateWords(grid);\r\n\r\n    return grid;\r\n}\r\n\r\nexport function getUncheckedSquareDir(grid: GridState, row: number, col: number): WordDirection | undefined {\r\n    if (grid.squares[row][col].type === SquareType.Black) return undefined;\r\n    if ((col === 0 || grid.squares[row][col-1].type === SquareType.Black) &&\r\n        (col === grid.width-1 || grid.squares[row][col+1].type === SquareType.Black))\r\n        return WordDirection.Down;\r\n    if ((row === 0 || grid.squares[row-1][col].type === SquareType.Black) &&\r\n        (row === grid.height-1 || grid.squares[row+1][col].type === SquareType.Black))\r\n        return WordDirection.Across;\r\n\r\n    return undefined;\r\n}\r\n\r\nexport function getSymmetrySquares(initSquare: [number, number]): [number, number][] {\r\n    let grid = getGrid();\r\n    let w = grid.width - 1;\r\n    let h = grid.height - 1;\r\n    let r = initSquare[0];\r\n    let c = initSquare[1];\r\n    let ret = [initSquare];\r\n\r\n    switch (Globals.gridSymmetry!) {\r\n        case SymmetryType.Rotate180:\r\n            ret.push([h - r, w - c]);\r\n            break;\r\n        case SymmetryType.Rotate90:\r\n            ret.push([c, h - r]);\r\n            ret.push([h - r, w - c]);\r\n            ret.push([w - c, r]);\r\n            break;\r\n        case SymmetryType.MirrorHorizontal:\r\n            ret.push([r, w - c]);\r\n            break;\r\n        case SymmetryType.MirrorVertical:\r\n            ret.push([h - r, c]);\r\n            break;\r\n        case SymmetryType.MirrorNWSE:\r\n            ret.push([w - c, h - r]);\r\n            break;\r\n        case SymmetryType.MirrorNESW:\r\n            ret.push([c, r]);\r\n            break;\r\n    }\r\n\r\n    return ret;\r\n}\r\n\r\nexport function insertEntryIntoGrid(node: FillNode, wordKey: string, entry: string, iffyWordKey?: string, contentType?: ContentType) {\r\n    let grid = node.startGrid;\r\n    node.fillWord = grid.words.get(wordKey)!;\r\n    node.chosenEntry = node.entryCandidates.find(ec => ec.word === entry && ec.iffyWordKey === iffyWordKey);\r\n    processAndInsertChosenEntry(node, contentType);\r\n}\r\n\r\nexport function eraseGridSquare(grid: GridState, sq: GridSquare, dir: WordDirection) {\r\n    if (sq.content === undefined) return;\r\n\r\n    let word = getWordAtSquare(grid, sq.row, sq.col, dir)!;\r\n    let squares = word ? getSquaresForWord(grid, word) : [sq];\r\n\r\n    let otherDirWord = getWordAtSquare(grid, sq.row, sq.col, dir)!;\r\n    let otherDirSquares = otherDirWord ? getSquaresForWord(grid, otherDirWord) : [sq];\r\n    if (squares.length > 1 && isWordFull(squares)) grid.usedWords.delete(getLettersFromSquares(squares));\r\n    if (otherDirSquares.length > 1 && isWordFull(otherDirSquares)) grid.usedWords.delete(getLettersFromSquares(otherDirSquares));\r\n\r\n    if (squares.find(sq => sq.contentType === ContentType.Autofill)) {\r\n        ; // autofill is ephemeral, no need to explicitly delete\r\n    }\r\n    else if (squares.find(sq => [ContentType.User, ContentType.ChosenWord].includes(sq.contentType))) {\r\n        let isInSection = getSectionsWithSelectedCandidate().find(sec => sec.squares.has(squareKey(sq)));\r\n\r\n        squares.forEach(wsq => {\r\n            if (wsq.contentType === ContentType.User) return;\r\n            let cross = getWordAtSquare(grid, wsq.row, wsq.col, otherDir(dir))!;\r\n            let crossSquares = getSquaresForWord(grid, cross);\r\n            if (crossSquares.find(csq => [ContentType.Autofill, ContentType.ChosenSection].includes(csq.contentType))) {\r\n                if (isInSection)\r\n                    wsq.contentType = ContentType.ChosenSection;\r\n                else\r\n                    wsq.contentType = ContentType.Autofill;\r\n            }\r\n        });\r\n    }\r\n        \r\n    sq.content = undefined;\r\n    sq.contentType = ContentType.Autofill;\r\n    clearFill(grid);\r\n}\r\n\r\nexport function eraseSectionCandidateFromGrid(grid: GridState, sc: SectionCandidate) {\r\n    let section = getSectionWithCandidate(sc);\r\n    Globals.selectedSectionCandidateKeys?.delete(section.id);\r\n    section.squares.forEach((_, sqKey) => {\r\n        let sq = getSquareAtKey(grid, sqKey);\r\n        let scs = getSelectedSectionCandidatesWithSquare(sqKey);\r\n        if (scs.length > 1) return;\r\n        if (sq.contentType === ContentType.ChosenSection)\r\n            sq.contentType = ContentType.Autofill;\r\n    });\r\n}\r\n\r\nexport function clearFill(grid: GridState) {\r\n    Globals.selectedWordNode = undefined;\r\n    let section = getSection();\r\n    section.fillQueue = undefined;\r\n    section.comboPermsQueue = [];\r\n    section.comboPermsUsed = new Map<string, boolean>();\r\n    Globals.fillStatus = Globals.wordList !== undefined ? FillStatus.Ready : FillStatus.NoWordList;\r\n\r\n    forAllGridSquares(grid, sq => {\r\n        if (!isUserFilled(sq)) {\r\n            sq.content = undefined;\r\n        }\r\n    });\r\n\r\n    updateGridConstraintInfo(grid);\r\n}\r\n\r\nexport function updateManualEntryCandidates(grid: GridState) {\r\n    if (!Globals.selectedWordKey || !Globals.wordList) {\r\n        Globals.selectedWordNode = undefined;\r\n        return;\r\n    }\r\n\r\n    let node = makeNewNode(grid, 0, false, undefined);\r\n    node.fillWord = grid.words.get(Globals.selectedWordKey!);\r\n    if (Globals.useManualHeuristics!) {\r\n        populateAndScoreEntryCandidates(node, true);\r\n    }\r\n    else {\r\n        populateNoHeuristicEntryCandidates(node);\r\n    }\r\n    Globals.selectedWordNode = node;\r\n}\r\n","import { CluesViewProp } from \"./CluesViewProp\";\r\nimport React, { createRef, useEffect, useRef, useState } from 'react';\r\nimport \"./CluesView.scss\";\r\nimport { wordKey, deepClone, getSquaresForWord, getGrid, mapValues } from \"../../lib/util\";\r\nimport Globals from '../../lib/windowService';\r\nimport { getLettersFromSquares } from \"../../lib/grid\";\r\nimport { WordDirection } from \"../../models/WordDirection\";\r\n\r\nfunction CluesView(props: any) {\r\n    const [clueProps, setClueProps] = useState(initClueProps());\r\n    const [selectedKey, setSelectedKey] = useState(\"\");\r\n    const textareasRef = useRef([] as any[]);\r\n\r\n    useEffect(() => {\r\n        setClueProps(initClueProps());\r\n        setSelectedKey(Globals.selectedWordKey!);\r\n    }, [props.updateSemaphore])\r\n\r\n    function initClueProps(): CluesViewProp[] {\r\n        let props = [] as CluesViewProp[];\r\n        if (!Globals.puzzle) return props;\r\n\r\n        let grid = getGrid();\r\n        let words = grid.words;\r\n        let clues = Globals.puzzle.clues;\r\n        mapValues(words).sort((a, b) => (a.number || 0) - (b.number || 0)).forEach(word => {\r\n            let key = wordKey(word);\r\n            let squares = getSquaresForWord(grid, word);\r\n            let prop = {\r\n                number: word.number!,\r\n                key: key,\r\n                direction: word.direction,\r\n                clue: clues.get(key)! || \"\",\r\n                entry: getLettersFromSquares(squares),\r\n                isOpenForEditing: false,\r\n            } as CluesViewProp;\r\n            props.push(prop);\r\n        });\r\n        return props;\r\n    }\r\n\r\n    function handleClueClick(event: any) {\r\n        let target = event.target;\r\n        while (![\"clue\"].includes(target.classList[0])) {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n        let targetKey = target.attributes[\"data-key\"].value;\r\n        let refIndex = +target.attributes[\"data-ref-index\"].value;\r\n        let textareaEl = textareasRef.current[refIndex].current;\r\n        \r\n        let newClueProps = deepClone(clueProps) as CluesViewProp[];\r\n        let propToToggle = newClueProps.find(p => p.key === targetKey)!;\r\n        propToToggle.isOpenForEditing = !propToToggle.isOpenForEditing;\r\n        setClueProps(newClueProps);\r\n\r\n        if (propToToggle.isOpenForEditing) {\r\n            textareaEl.value = propToToggle.clue;\r\n            textareaEl.style.display = \"inherit\"; // have to do this before we can autofocus\r\n            textareaEl.focus();\r\n        }\r\n    }\r\n\r\n    function handleKeyDown(event: any) {\r\n        let target = event.target;\r\n        let targetKey: string = target.attributes[\"data-key\"].value;\r\n        let keyPressed: string = event.key.toUpperCase();\r\n\r\n        if (keyPressed === \"ENTER\") {\r\n            applyClueChange(targetKey, target.value);\r\n        }\r\n    }\r\n\r\n    function handleFocus(event: any) {\r\n        event.target.select();\r\n    }\r\n\r\n    function applyClueChange(targetKey: string, newValue: string) {\r\n        let newClueProps = deepClone(clueProps) as CluesViewProp[];\r\n        let targetProp = newClueProps.find(p => p.key === targetKey)!;\r\n        targetProp.clue = newValue === \"(blank clue)\" ? \"\" : newValue;\r\n        targetProp.isOpenForEditing = false;\r\n        Globals.puzzle!.clues.set(targetKey, newValue);\r\n        setClueProps(newClueProps);\r\n    }\r\n\r\n    function renderCluesContainer(isAcross: boolean, clueList: CluesViewProp[], refIndex: number) {\r\n        return (\r\n            <div className=\"clues-container\">\r\n                <div className=\"clues-header\">{isAcross ? \"ACROSS\" : \"DOWN\"}</div>\r\n                <div className=\"clues-clues\">\r\n                    {clueList.map(clue => {\r\n                        textareasRef.current.push(createRef());\r\n                        let ret = (\r\n                            <div key={clue.key}>\r\n                                <div className={\"clue\" + (clue.key === selectedKey ? \" clue-selected\" : \"\")}\r\n                                    data-key={clue.key} onClick={handleClueClick} data-ref-index={refIndex}>\r\n                                    <div className=\"clue-number\">{clue.number}</div>\r\n                                    <div className=\"clue-entry\">{clue.entry}</div>\r\n                                    {clue.entry.length > 15 && <br />}\r\n                                    {clue.clue.length > 0 ? clue.clue : \"(blank clue)\"}\r\n                                </div>\r\n                                <textarea className=\"clue-editor\" defaultValue={clue.clue} data-key={clue.key} \r\n                                    style={{display: clue.isOpenForEditing ? \"inherit\" : \"none\"}}\r\n                                    onKeyDown={handleKeyDown} onFocus={handleFocus}\r\n                                    ref={textareasRef.current[refIndex]}>\r\n                                </textarea>\r\n                            </div>\r\n                        );\r\n                        refIndex++;\r\n                        return ret;\r\n                    })}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    textareasRef.current = [] as any[];\r\n    let acrossClues = clueProps.filter(p => p.direction === WordDirection.Across);\r\n    let downClues = clueProps.filter(p => p.direction === WordDirection.Down);\r\n\r\n    return (\r\n        <div className=\"clues-view\">\r\n            {renderCluesContainer(true, acrossClues, 0)}\r\n            {renderCluesContainer(false, downClues, acrossClues.length)}\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default CluesView;\r\n","import React, { useContext, useState } from 'react';\r\nimport { SymmetryType } from '../../models/SymmetryType';\r\nimport \"./FillView.scss\";\r\nimport Globals from '../../lib/windowService';\r\nimport { FillStatus } from '../../models/FillStatus';\r\nimport { getEntryAtWordKey, getGrid, getSection, getSquaresForWord, mapKeys, mapValues } from '../../lib/util';\r\nimport { calculateSectionOrder, getLongestStackWord, getPhoneticName, insertSectionCandidateIntoGrid, \r\n    makeNewSection, sectionCandidateKey, updateSectionFilters } from '../../lib/section';\r\nimport { clearFill, eraseSectionCandidateFromGrid, getLettersFromSquares, insertEntryIntoGrid, updateGridConstraintInfo, updateManualEntryCandidates } from '../../lib/grid';\r\nimport { fillSectionWord, makeNewNode } from '../../lib/fill';\r\nimport { FillNode } from '../../models/FillNode';\r\nimport { AppContext } from '../../AppContext';\r\nimport { ContentType } from '../../models/ContentType';\r\nimport { Section } from '../../models/Section';\r\nimport { processWordListData } from '../../lib/wordList';\r\nimport { useInterval } from '../../lib/useInterval';\r\nimport { SectionCandidate } from '../../models/SectionCandidate';\r\n\r\nfunction FillView() {\r\n    const appContext = useContext(AppContext);\r\n    const [showSectionCandidates, setShowSectionCandidates] = useState(true);\r\n    const [isWordListLoading, setIsWordListLoading] = useState(false);\r\n    const [isFillRunning, setIsFillRunning] = useState(false);\r\n\r\n    function triggerUpdate() {\r\n        appContext.triggerUpdate();\r\n    }\r\n\r\n    function setFillStatus(newStatus: FillStatus) {\r\n        Globals.fillStatus = newStatus;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleToggleFill() {\r\n        if (Globals.fillStatus === FillStatus.Complete) return;\r\n\r\n        if (isFillRunning) {\r\n            clearFill(getGrid());\r\n            setFillStatus(FillStatus.Ready);\r\n            setIsFillRunning(false);\r\n            triggerUpdate();\r\n        }\r\n        else {\r\n            setFillStatus(FillStatus.Running);\r\n            setIsFillRunning(true);\r\n        }\r\n    }\r\n    \r\n    function doFillWord() {\r\n        if (Globals.fillStatus === FillStatus.Complete) return;\r\n        if (!fillSectionWord()) {\r\n            clearFill(getGrid());\r\n            setFillStatus(FillStatus.Complete);\r\n            setIsFillRunning(false);\r\n        }\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleFillWordClick(event: any) {\r\n        if (!Globals.wordList) return;\r\n\r\n        if (!fillSectionWord()) {\r\n            clearFill(getGrid());\r\n            setFillStatus(FillStatus.Complete);\r\n        }\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleSymmetryChange(event: any) {\r\n        Globals.gridSymmetry = +SymmetryType[event.target[event.target.selectedIndex].value] as SymmetryType;\r\n    }\r\n\r\n    function handleIffyLengthChange(event: any) {\r\n        Globals.maxIffyLength = +event.target[event.target.selectedIndex].value;\r\n    }\r\n\r\n    function getSymmetryTypeString(type: string): string {\r\n        switch(type) {\r\n            case \"None\": return \"None\";\r\n            case \"Rotate180\": return \"180° Rotational\";\r\n            case \"Rotate90\": return \"90° Rotational\";\r\n            case \"MirrorHorizontal\": return \"Mirror Horizontally\";\r\n            case \"MirrorVertical\": return \"Mirror Vertically\";\r\n            case \"MirrorNWSE\": return \"Mirror NW to SE\";\r\n            case \"MirrorNESW\": return \"Mirror NE to SW\";\r\n        }\r\n        return \"\";\r\n    }\r\n\r\n    function getSymmetryTypesForRectGrids(): string[] {\r\n        return [\"None\", \"Rotate180\", \"MirrorHorizontal\", \"MirrorVertical\"];\r\n    }\r\n\r\n    function getFillStatusString(status: FillStatus): string {\r\n        switch(status) {\r\n            case FillStatus.NoWordList: return \"No Word List Loaded\";\r\n            case FillStatus.Ready: return \"Ready to Fill\";\r\n            case FillStatus.Running: return \"Fill Running...\";\r\n            case FillStatus.Complete: return \"Fill Complete\";\r\n            default: return \"\";\r\n        }\r\n    }\r\n\r\n    function getManualEntryNode(entry: string, iffyWordKey?: string, isHover?: boolean): FillNode {\r\n        let node = Globals.selectedWordNode!;\r\n        let wordKey = Globals.selectedWordKey!;\r\n        insertEntryIntoGrid(node, wordKey, entry, iffyWordKey, isHover ? ContentType.HoverChosenWord : ContentType.ChosenWord);\r\n        return node;\r\n    }\r\n\r\n    function getManualSectionNode(sectionCandidateKey: string, isHover: boolean): FillNode {\r\n        let grid = getGrid();\r\n\r\n        let node = makeNewNode(grid, 0, false, undefined);\r\n        let section = getSection();\r\n        let candidate = section.candidates.get(sectionCandidateKey)!;\r\n        insertSectionCandidateIntoGrid(node.endGrid, candidate, \r\n            isHover ? ContentType.HoverChosenSection : ContentType.ChosenSection);\r\n        return node;\r\n    }\r\n\r\n    function handleEntryCandidateClick(event: any) {\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        if (!Globals.selectedWordKey) return;\r\n\r\n        let entry = target.attributes[\"data-word\"].value as string;\r\n        let iffyWordKey = target.attributes[\"data-iffykey\"].value as string | undefined;\r\n        if (iffyWordKey === \"na\") iffyWordKey = undefined;\r\n        let node = getManualEntryNode(entry, iffyWordKey, false);\r\n\r\n        Globals.manualIffyKey = iffyWordKey;\r\n\r\n        updateManualEntryCandidates(node.endGrid);\r\n\r\n        Globals.activeGrid = node.endGrid;\r\n        updateSectionFilters();\r\n        Globals.hoverGrid = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleEntryCandidateHover(event: any) {\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        if (!Globals.selectedWordKey) return;\r\n\r\n        let entry = target.attributes[\"data-word\"].value as string;\r\n        let iffyWordKey = target.attributes[\"data-iffykey\"].value as string | undefined;\r\n        if (iffyWordKey === \"na\") iffyWordKey = undefined;\r\n        let node = getManualEntryNode(entry, iffyWordKey, true);\r\n\r\n        Globals.hoverGrid = node.endGrid;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleEntryCandidateBlur() {\r\n        Globals.hoverGrid = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleSectionClick(event: any) {\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n            if (target.classList[0] === \"section-checkbox\") return;\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        let sectionId = +target.attributes[\"data-id\"].value;\r\n        clearFill(getGrid());\r\n\r\n        if (sectionId === Globals.activeSectionId!)\r\n            Globals.activeSectionId = 0;\r\n        else {\r\n            Globals.activeSectionId = sectionId;\r\n            Globals.selectedSectionIds!.set(sectionId, true);\r\n        }\r\n\r\n        Globals.hoverGrid = undefined;\r\n        Globals.hoverSectionId = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleSectionCheckClick(event: any) {\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        let sectionId = +target.attributes[\"data-id\"].value;\r\n        if (Globals.selectedSectionIds!.get(sectionId))\r\n            Globals.selectedSectionIds!.delete(sectionId);\r\n        else\r\n            Globals.selectedSectionIds!.set(sectionId, true);\r\n    }\r\n\r\n    function handleSectionHover(event: any) {\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        let sectionId = +target.attributes[\"data-id\"].value;\r\n        Globals.hoverSectionId = sectionId;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleSectionBlur() {\r\n        Globals.hoverSectionId = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleSectionCandidateClick(event: any) {\r\n        function eraseSc() {\r\n            section.selectedCandidate = undefined;\r\n            section.comboPermsQueue = [];\r\n            section.comboPermsUsed = new Map<string, boolean>();\r\n            let sc = section.candidates.get(candidateKey)!;\r\n            eraseSectionCandidateFromGrid(grid, sc);\r\n            clearFill(grid);\r\n        }\r\n\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        let section = getSection();\r\n        let grid = getGrid();\r\n        let candidateKey = target.attributes[\"data-candidate-key\"].value as string;\r\n\r\n        if (section.selectedCandidate === candidateKey) {\r\n            eraseSc();\r\n        }\r\n        else {\r\n            if (section.selectedCandidate) eraseSc();\r\n\r\n            let node = getManualSectionNode(candidateKey, false);\r\n            Globals.selectedSectionCandidateKeys!.set(section.id, candidateKey);\r\n            section.selectedCandidate = candidateKey;\r\n\r\n            updateManualEntryCandidates(node.endGrid);\r\n\r\n            Globals.activeGrid = node.endGrid;\r\n        }\r\n        \r\n        updateSectionFilters();\r\n        Globals.hoverGrid = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleSectionCandidateHover(event: any) {\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        let candidateKey = target.attributes[\"data-candidate-key\"].value as string;\r\n        let node = getManualSectionNode(candidateKey, true);\r\n\r\n        Globals.hoverGrid = node.endGrid;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleShowSectionCandidatesToggle() {\r\n        setShowSectionCandidates(!showSectionCandidates);\r\n    }\r\n\r\n    function clearSectionCandidates() {\r\n        if (!window.confirm(\"Are you sure you want to clear the fills?\")) return;\r\n\r\n        let section = getSection();\r\n        section.candidates = new Map<string, SectionCandidate>();\r\n        section.selectedCandidate = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleUseHeuristicsToggle() {\r\n        let newValue = Globals.useManualHeuristics !== undefined ? !Globals.useManualHeuristics! : false;\r\n        Globals.useManualHeuristics = newValue;\r\n\r\n        triggerUpdate();\r\n        let node = Globals.selectedWordNode;\r\n        if (!node) return;\r\n\r\n        updateManualEntryCandidates(grid);\r\n    }\r\n\r\n    function handleSectionCandidateBlur() {\r\n        Globals.hoverGrid = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function loadWordList() {\r\n        document.getElementById(\"open-wordlist-input\")!.click();\r\n    }\r\n\r\n    function clearWordLists() {\r\n        if (!window.confirm(\"Are you sure you want to clear the word lists?\")) return;\r\n\r\n        Globals.wordList = undefined;\r\n        Globals.wordLists = [];\r\n        setFillStatus(FillStatus.NoWordList);\r\n        Globals.selectedWordNode = undefined;\r\n    }\r\n\r\n    function onWordListUpload(event: any) {\r\n        let file = event.target.files[0];\r\n        event.target.value = null;\r\n        setIsWordListLoading(true);\r\n\r\n        setTimeout(() => {\r\n            processWordListData(file.name, file).then(wordList => {\r\n                if (wordList) {\r\n                    Globals.wordLists!.push(wordList);\r\n                    setFillStatus(FillStatus.Ready);\r\n                    let grid = getGrid();\r\n                    updateGridConstraintInfo(grid);\r\n                    updateManualEntryCandidates(grid);\r\n                    setIsWordListLoading(false);\r\n                    triggerUpdate();\r\n                }\r\n            });\r\n        }, 5);\r\n    }\r\n\r\n    useInterval(() => {\r\n        doFillWord();\r\n    }, isFillRunning ? 5 : null);\r\n\r\n    let grid = getGrid();\r\n    let selectedSymmetry = SymmetryType[Globals.gridSymmetry!];\r\n    let symmetryOptions = (!grid || grid.width === grid.height) ?\r\n        Object.values(SymmetryType).filter(t => isNaN(Number(t))) :\r\n        getSymmetryTypesForRectGrids();\r\n\r\n    let fillStatusStr = getFillStatusString(Globals.fillStatus!);\r\n    \r\n    let wordLists = Globals.wordLists || [];\r\n\r\n    let entryCandidates = Globals.selectedWordNode ? Globals.selectedWordNode.entryCandidates : [];\r\n    let isNoEntryCandidates = Globals.selectedWordNode && entryCandidates.length === 0;\r\n\r\n    let sections = [] as Section[];\r\n    if (Globals.sections!) {\r\n        let sectionsOrder = calculateSectionOrder(mapValues(Globals.sections!));\r\n        sections = sectionsOrder.map(id => Globals.sections!.get(id)!);\r\n    }\r\n    let activeSection = Globals.sections ? Globals.sections!.get(Globals.activeSectionId!)! : makeNewSection(-1);\r\n    let selectedScKey = activeSection.selectedCandidate;\r\n    let selectedSectionIds = mapKeys(Globals.selectedSectionIds!) || [0];\r\n    let sectionCandidates = mapValues(activeSection.candidates)\r\n        .filter(sc => !sc.isFilteredOut).sort((a, b) => b.score - a.score);\r\n    let selectedEntry = Globals.selectedWordKey ? getEntryAtWordKey(grid, Globals.selectedWordKey!) : \"\";\r\n    let selectedMaxIffyLength = Globals.maxIffyLength || 0;\r\n    let useManualHeuristics = Globals.useManualHeuristics !== undefined ? Globals.useManualHeuristics : true;\r\n\r\n    let wordListsStyle = {\r\n        gridTemplateColumns: `4fr 1fr`\r\n    } as React.CSSProperties;\r\n\r\n    let entryCandidatesStyle = {\r\n        gridTemplateColumns: `4fr 1fr 2fr`\r\n    } as React.CSSProperties;\r\n\r\n    let sectionsStyle = {\r\n        gridTemplateColumns: `1fr 2fr 1fr 1fr 1fr`\r\n    } as React.CSSProperties;\r\n\r\n    let fillsStyle = {\r\n        gridTemplateColumns: `4fr 1fr 2fr`\r\n    } as React.CSSProperties;\r\n\r\n    return (\r\n        <div id=\"FillView\" className=\"fill-container\">\r\n            <input id=\"open-wordlist-input\" hidden type=\"file\" accept=\".dict,.txt\" onChange={onWordListUpload} />\r\n            <div id=\"loader\" style={{display: isWordListLoading ? \"block\" : \"none\"}}></div>\r\n\r\n            <div className={\"fill-status\" +\r\n                (Globals.fillStatus! === FillStatus.NoWordList ? \" fill-status-red\" :\r\n                Globals.fillStatus! === FillStatus.Running ? \" fill-status-green\" : \"\")}>{fillStatusStr}</div>\r\n            {wordLists.length > 0 &&\r\n            <>\r\n                <div className=\"custom-control custom-switch fill-switch\">\r\n                    <input type=\"checkbox\" className=\"custom-control-input\" id=\"fillSwitch\" \r\n                        checked={isFillRunning} onChange={handleToggleFill} />\r\n                    <label className=\"custom-control-label\" htmlFor=\"fillSwitch\">Fill</label>\r\n                </div>\r\n                <br />\r\n                Max Iffy Length: <br />\r\n                <select className=\"custom-select iffy-select\" defaultValue={selectedMaxIffyLength} onChange={handleIffyLengthChange}>\r\n                    <option value={0} key={0}>Off</option>\r\n                    {[2, 3, 4, 5, 6, 7].map(length => (\r\n                        <option value={length} key={length}>{length}</option>\r\n                    ))}\r\n                </select>\r\n            </>\r\n            }\r\n            \r\n            <br /><br />\r\n            Grid Symmetry: <br />\r\n            <select className=\"custom-select symmetry-select\" defaultValue={selectedSymmetry} onChange={handleSymmetryChange}>\r\n                {symmetryOptions.map(type => (\r\n                    <option value={type} key={type}>{getSymmetryTypeString(type.toString())}</option>\r\n                ))}\r\n            </select>\r\n            <br /><br />\r\n            <button className=\"btn btn-primary\" onClick={handleFillWordClick} style={{display: \"none\"}}>Fill Word</button>\r\n\r\n            <div className=\"fill-lists\">\r\n                <div className=\"fill-list-box\">\r\n                    <div className=\"fill-list-title\">Word Lists</div>\r\n                    <div className=\"fill-list-button\" onClick={clearWordLists}>Clear</div>\r\n                    <div className=\"fill-list-button\" onClick={loadWordList}>Load</div>\r\n                    <div className=\"fill-list\" style={wordListsStyle}>\r\n                        <div className=\"fill-list-header\">Filename</div>\r\n                        <div className=\"fill-list-header\">Count</div>\r\n                        { wordLists.length === 0 && (\r\n                            <div className=\"fill-list-row-wrapper\" style={{cursor: \"auto\"}}>\r\n                                <div><i>No word lists loaded</i></div><div></div>\r\n                            </div>\r\n                        )}\r\n                        { wordLists.map(wl => (\r\n                            <div className=\"fill-list-row-wrapper\" style={{cursor: \"auto\"}} key={wl.filename}>\r\n                                <div>{wl.filename}</div>\r\n                                <div>{wl.wordCount}</div>\r\n                            </div>\r\n                        ))}\r\n                    </div>\r\n                </div>\r\n                <div className=\"fill-list-box\" onMouseOut={handleEntryCandidateBlur}>\r\n                    <div className=\"fill-list-title entry-color\">Entry Candidates</div>\r\n                    <div className=\"fill-sec-checkbox\">\r\n                        <input type=\"checkbox\" className=\"section-checkbox\" id=\"use-heuristics-box\"\r\n                                    checked={useManualHeuristics} onChange={handleUseHeuristicsToggle} />\r\n                        <label htmlFor=\"use-heuristics-box\">Use heuristics</label>\r\n                    </div>\r\n                    <div className=\"fill-list\" style={entryCandidatesStyle}>\r\n                        <div className=\"fill-list-header\">Entry</div>\r\n                        <div className=\"fill-list-header\">Score</div>\r\n                        <div className=\"fill-list-header\">Iffy</div>\r\n                        { isNoEntryCandidates && useManualHeuristics && (\r\n                            <div className=\"fill-list-row-wrapper\">\r\n                                <div><i>No viable entries</i></div><div></div><div></div>\r\n                            </div>\r\n                        )}\r\n                        { entryCandidates.map(ec => (\r\n                            <div className={\"fill-list-row-wrapper\" + (selectedEntry === ec.word ? \" fill-list-row-selected\" : \"\")} \r\n                                key={ec.word + (ec.iffyEntry || \"\")} data-word={ec.word} data-iffykey={ec.iffyWordKey || \"na\"}\r\n                                onClick={handleEntryCandidateClick} onMouseOver={handleEntryCandidateHover}>\r\n                                <div>{ec.word}</div>\r\n                                <div>{ec.score.toFixed(0)}</div>\r\n                                <div>{ec.iffyEntry || \"\"}</div>\r\n                            </div>\r\n                        ))}\r\n                    </div>\r\n                </div>\r\n                <div className=\"fill-list-box\" onMouseOut={handleSectionBlur}>\r\n                    <div className=\"fill-list-title section-color\">Sections</div>\r\n                    <div className=\"fill-list\" style={sectionsStyle}>\r\n                        <div className=\"fill-list-header\">Active</div>\r\n                        <div className=\"fill-list-header\">ID</div>\r\n                        <div className=\"fill-list-header\">Size</div>\r\n                        <div className=\"fill-list-header\">Conn</div>\r\n                        <div className=\"fill-list-header\">Fills</div>\r\n                        { sections.map(sec => (\r\n                            <div className={\"fill-list-row-wrapper\" + (sec.id === activeSection.id ? \" fill-list-row-selected\" : \"\")} \r\n                                key={sec.id} data-id={sec.id} onClick={handleSectionClick} onMouseOver={handleSectionHover}>\r\n                                <div><input type=\"checkbox\" className=\"section-checkbox\"\r\n                                    checked={selectedSectionIds.includes(sec.id)} onChange={handleSectionCheckClick} /></div>\r\n                                <div>{getPhoneticName(sec.id)}</div>\r\n                                <div>{sec.squares.size}</div>\r\n                                <div>{sec.connections.size}</div>\r\n                                <div>{sec.candidates.size}</div>\r\n                            </div>\r\n                        ))}\r\n                    </div>\r\n                </div>\r\n                <div className=\"fill-list-box\" onMouseOut={handleSectionCandidateBlur}>\r\n                    <div className=\"fill-list-title\">Fills {sectionCandidates.length > 0 ? `(${sectionCandidates.length})` : \"\"}</div>\r\n                    <div className=\"fill-list-button\" onClick={clearSectionCandidates}>Clear</div>\r\n                    <div className=\"fill-sec-checkbox\">\r\n                        <input type=\"checkbox\" className=\"section-checkbox\" id=\"show-fills-box\"\r\n                                    checked={showSectionCandidates} onChange={handleShowSectionCandidatesToggle} />\r\n                        <label htmlFor=\"show-fills-box\">Show</label>\r\n                    </div>\r\n                    <div className=\"fill-list\" style={fillsStyle}>\r\n                        <div className=\"fill-list-header\">Longest</div>\r\n                        <div className=\"fill-list-header\">Score</div>\r\n                        <div className=\"fill-list-header\">Iffy</div>\r\n                        {!showSectionCandidates && (\r\n                            <div className=\"fill-list-row-wrapper\">\r\n                                <div><i>Hidden</i></div><div></div><div></div>\r\n                            </div>\r\n                        )}\r\n                        {showSectionCandidates && Globals.fillStatus === FillStatus.Complete && sectionCandidates.length === 0 && (\r\n                            <div className=\"fill-list-row-wrapper\">\r\n                                <div><i>No fills found</i></div><div></div><div></div>\r\n                            </div>\r\n                        )}\r\n                        {showSectionCandidates && sectionCandidates.map(sc => {\r\n                            let entry = getLettersFromSquares(getSquaresForWord(sc.grid, getLongestStackWord(activeSection)));\r\n                            let candidateKey = sectionCandidateKey(activeSection, sc.grid);\r\n\r\n                            return (\r\n                            <div className={\"fill-list-row-wrapper\" + (selectedScKey === candidateKey ? \" fill-list-row-selected\" : \"\")}\r\n                                key={candidateKey} data-candidate-key={candidateKey}\r\n                                onClick={handleSectionCandidateClick} onMouseOver={handleSectionCandidateHover}>\r\n                                <div>{entry}</div>\r\n                                <div>{sc.score.toFixed(2)}</div>\r\n                                <div>{sc.iffyEntry || \"\"}</div>\r\n                            </div>\r\n                        )})}\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default FillView;\r\n","import { useEffect, useRef } from 'react';\r\n\r\nexport function useInterval(callback: () => void, delay: number | null) {\r\n  const savedCallback = useRef<() => void>();\r\n\r\n  // Remember the latest callback.\r\n  useEffect(() => {\r\n    savedCallback.current = callback;\r\n  }, [callback]);\r\n\r\n  // Set up the interval.\r\n  useEffect(() => {\r\n    function tick() {\r\n      if (savedCallback.current) savedCallback.current();\r\n    }\r\n    if (delay !== null) {\r\n      let id = setInterval(tick, delay);\r\n      return () => clearInterval(id);\r\n    }\r\n  }, [delay]);\r\n}\r\n","import React from 'react';\r\nimport { ContentType } from '../../models/ContentType';\r\nimport { QualityClass } from '../../models/QualityClass';\r\nimport { SquareType } from '../../models/SquareType';\r\nimport { SquareProps } from './SquareProps';\r\n\r\nfunction Square(props: SquareProps) {\r\n    return getSquareElement(props);\r\n}\r\n\r\nfunction getSquareElement(props: SquareProps) {\r\n    let content = props.content || \"\";\r\n    if (props.type === SquareType.White) {\r\n        return <div \r\n                    className={\"grid-square\" + \r\n                        (props.isSelected ? \" grid-square-selected\" : \r\n                        props.isInSelectedWord ? \" grid-square-selected-word\" : \r\n                        props.isInSelectedSection ? \" grid-square-selected-section\" : \"\") +\r\n                        (props.content ? \"\" :\r\n                        props.constraintSum === 0 ? \" grid-square-error-word\" :\r\n                        between(props.constraintSum, 1, 1) ? \" grid-square-constrained-5\" : \r\n                        between(props.constraintSum, 1, 3) ? \" grid-square-constrained-4\" : \r\n                        between(props.constraintSum, 1, 5) ? \" grid-square-constrained-3\" : \r\n                        between(props.constraintSum, 1, 10) ? \" grid-square-constrained-2\" : \r\n                        between(props.constraintSum, 1, 15) ? \" grid-square-constrained-1\" : \"\"\r\n                        )} \r\n                    data-row={props.row} data-col={props.col}>\r\n            {props.isCircled && \r\n                <div className=\"grid-square-circled\"></div>\r\n            }\r\n            <div className=\"grid-number\">{props.number ?? \"\"}</div>\r\n            <div className={\"grid-content\" + \r\n                        (content.length > 1 ? \" grid-content-rebus\" : \"\") +\r\n                        (props.content && props.contentType === ContentType.User ? \"\" :\r\n                         props.content && props.contentType === ContentType.ChosenWord ? \" grid-content-chosen-word\" :\r\n                         props.content && props.contentType === ContentType.HoverChosenWord ? \" grid-content-chosen-word-hover\" :\r\n                         props.content && props.contentType === ContentType.ChosenSection ? \" grid-content-chosen-section\" :\r\n                         props.content && props.contentType === ContentType.HoverChosenSection ? \" grid-content-chosen-section-hover\" :\r\n                         props.qualityClass === QualityClass.Lively ? \" grid-content-lively\" :\r\n                         props.qualityClass === QualityClass.Normal ? \" grid-content-normal\" :\r\n                         props.qualityClass === QualityClass.Crosswordese ? \" grid-content-crosswordese\" :\r\n                         props.qualityClass === QualityClass.Iffy ? \" grid-content-iffy\" :\r\n                         props.qualityClass === QualityClass.NotAThing ? \" grid-content-notathing\" : \"\"\r\n                        )}>\r\n                    {content}\r\n            </div>\r\n        </div>\r\n    }\r\n    else {\r\n        return <div className={\"grid-square-black\" + (props.isSelected ? \" grid-square-black-selected\" : \"\")} \r\n            data-row={props.row} data-col={props.col}>\r\n        </div>\r\n    }\r\n}\r\n\r\nfunction between(input: number, min: number, max: number): boolean {\r\n    return input >= min && input <= max;\r\n}\r\n\r\nexport default Square;\r\n","import React, { useContext, useState } from 'react';\r\nimport { SquareType } from '../../models/SquareType';\r\nimport { SquareProps } from '../Square/SquareProps';\r\nimport \"./Grid.scss\";\r\nimport Square from '../Square/Square';\r\nimport { GridState } from '../../models/GridState';\r\nimport { WordDirection } from '../../models/WordDirection';\r\nimport Globals from '../../lib/windowService';\r\nimport { compareTuples, doesWordContainSquare, getGrid, getSection, getSelectedWord, getSquaresForWord, \r\n    getWordAtSquare, initializeSessionGlobals, isWordFull, mapValues, otherDir, \r\n    squareKey, wordKey } from '../../lib/util';\r\nimport { clearFill, eraseGridSquare, getLettersFromSquares, getSymmetrySquares, getUncheckedSquareDir, populateWords, \r\n    updateGridConstraintInfo, updateManualEntryCandidates } from '../../lib/grid';\r\nimport { GridWord } from '../../models/GridWord';\r\nimport { AppContext } from '../../AppContext';\r\nimport { ContentType } from '../../models/ContentType';\r\nimport { updateSectionFilters } from '../../lib/section';\r\nimport { QualityClass } from '../../models/QualityClass';\r\nimport { GridSquare } from '../../models/GridSquare';\r\nimport { Section } from '../../models/Section';\r\n\r\nfunction Grid() {\r\n    const [selectedSquare, setSelectedSquare] = useState([-1, -1] as [number, number]);\r\n    const appContext = useContext(AppContext);\r\n\r\n    function handleClick(event: any) {\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || ![\"grid-square\", \"grid-square-black\"].includes(target.classList[0])) {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        let row = +target.attributes[\"data-row\"].value;\r\n        let col = +target.attributes[\"data-col\"].value;\r\n        let grid = getGrid();\r\n        \r\n        let newDirection = Globals.selectedWordDir || WordDirection.Across;\r\n\r\n        let uncheckedSquareDir = getUncheckedSquareDir(grid, row, col);\r\n        if (uncheckedSquareDir !== undefined) {\r\n            newDirection = uncheckedSquareDir;\r\n            setSelectedSquare([row, col]);\r\n        }\r\n        else if (compareTuples([row, col], selectedSquare)) {\r\n            newDirection = otherDir(newDirection);\r\n        }\r\n        else {\r\n            setSelectedSquare([row, col]);\r\n        }\r\n\r\n        Globals.selectedWordDir = newDirection;\r\n        setSelWordAtSelSquare([row, col]);\r\n\r\n        updateManualEntryCandidates(grid);\r\n\r\n        appContext.triggerUpdate();\r\n    }\r\n    \r\n    function handleKeyDown(event: any) {\r\n        if (!isSquareSelected()) return;\r\n\r\n        let grid = getGrid();\r\n        let row = selectedSquare[0];\r\n        let col = selectedSquare[1];\r\n\r\n        let key: string = event.key.toUpperCase();\r\n        let letterChanged = false;\r\n        let blackSquareChanged = false;\r\n        let sq = grid.squares[row][col];\r\n        let newSelSq = [-1,-1] as [number, number];\r\n\r\n        if (key.match(/^[A-Z]$/)) {\r\n            newSelSq = advanceCursor();\r\n\r\n            if (sq.type === SquareType.Black) return;\r\n            if (sq.content === key && sq.contentType === ContentType.User) return;\r\n\r\n            letterChanged = true;\r\n            if (sq.content !== key && sq.contentType !== ContentType.User)\r\n                eraseGridSquare(grid, sq, Globals.selectedWordDir!);\r\n\r\n            sq = grid.squares[row][col];\r\n            sq.content = key;\r\n            sq.contentType = ContentType.User;\r\n        }\r\n        if (key === \"BACKSPACE\") {\r\n            newSelSq = backupCursor();\r\n\r\n            if (sq.content !== undefined) {\r\n                eraseGridSquare(grid, sq, Globals.selectedWordDir!);\r\n                letterChanged = true;\r\n            }\r\n                \r\n            if (sq.type === SquareType.Black) {\r\n                getSymmetrySquares([row, col]).forEach(res => {\r\n                    let resSq = grid.squares[res[0]][res[1]];\r\n                    resSq.type = SquareType.White;\r\n                });\r\n\r\n                blackSquareChanged = true;\r\n            }\r\n        }\r\n        // toggle black square\r\n        if (key === \".\") {\r\n            newSelSq = advanceCursor();\r\n\r\n            eraseGridSquare(grid, sq, Globals.selectedWordDir!);\r\n\r\n            let newSquareType = sq.type === SquareType.White ? SquareType.Black : SquareType.White;\r\n            getSymmetrySquares([row, col]).forEach(res => {\r\n                let resSq = grid.squares[res[0]][res[1]];\r\n                resSq.type = newSquareType;\r\n            });\r\n\r\n            blackSquareChanged = true;\r\n        }\r\n        // toggle circled square\r\n        if (key === \",\") {\r\n            if (sq.type === SquareType.Black) return;\r\n            sq.isCircled = !sq.isCircled;\r\n            newSelSq = advanceCursor();\r\n            setSelWordAtSelSquare(newSelSq);\r\n        }\r\n\r\n        if (blackSquareChanged) {\r\n            populateWords(grid);\r\n            initializeSessionGlobals();\r\n            clearFill(grid);\r\n            setSelWordAtSelSquare(newSelSq);\r\n            updateGridConstraintInfo(grid);\r\n        }\r\n        else if (letterChanged)  {\r\n            updateSectionFilters();\r\n            updateGridConstraintInfo(grid);\r\n        }\r\n\r\n        updateManualEntryCandidates(grid);\r\n\r\n        appContext.triggerUpdate();\r\n    }\r\n\r\n    function advanceCursor(): [number, number] {\r\n        let selSq = selectedSquare;\r\n        if (!isSquareSelected()) return selSq;\r\n    \r\n        let grid = getGrid();\r\n        let dir = Globals.selectedWordDir!;\r\n        if ((dir === WordDirection.Across && selSq[1] === grid.width-1) || (dir === WordDirection.Down && selSq[0] === grid.height-1))\r\n            return selSq;\r\n\r\n        let newSelSq = (dir === WordDirection.Across ? [selSq[0], selSq[1] + 1] : [selSq[0] + 1, selSq[1]]) as [number, number];\r\n        setSelectedSquare(newSelSq);\r\n        setSelWordAtSelSquare(newSelSq);\r\n        return newSelSq;\r\n    }\r\n    \r\n    function backupCursor(): [number, number] {\r\n        let selSq = selectedSquare;\r\n        if (!isSquareSelected()) return selSq;\r\n    \r\n        let dir = Globals.selectedWordDir!;\r\n        if ((dir === WordDirection.Across && selSq[1] === 0) || (dir === WordDirection.Down && selSq[0] === 0))\r\n            return selSq;\r\n\r\n        let newSelSq = (dir === WordDirection.Across ? [selSq[0], selSq[1] - 1] : [selSq[0] - 1, selSq[1]]) as [number, number];\r\n        setSelectedSquare(newSelSq);\r\n        setSelWordAtSelSquare(newSelSq);\r\n        return newSelSq;\r\n    }\r\n\r\n    function isSquareSelected(): boolean {\r\n        return selectedSquare[0] > -1;\r\n    }\r\n    \r\n    function isWordSelected(): boolean {\r\n        return !!getSelectedWord();\r\n    }\r\n\r\n    function isSquareInSection(section: Section, sq: GridSquare): boolean {\r\n        return section.squares.has(squareKey(sq));\r\n    }\r\n\r\n    function setSelWordAtSelSquare(newSelSquare: [number, number]) {\r\n        let grid = getGrid();\r\n        let word = getWordAtSquare(grid, newSelSquare[0], newSelSquare[1], Globals.selectedWordDir!);\r\n        Globals.selectedWordKey = word ? wordKey(word) : undefined;\r\n    }\r\n\r\n    function getSquareProps(grid: GridState, row: number, col: number, \r\n        selectedSquare: [number, number], selectedWord: GridWord | undefined): SquareProps {\r\n        let square = grid.squares[row][col];\r\n    \r\n        return {\r\n            key: `${row},${col}`,\r\n            row: row,\r\n            col: col,\r\n            number: square.number,\r\n            type: square.type,\r\n            content: square.content,\r\n            contentType: square.contentType,\r\n            qualityClass: qualityClassMap.get(squareKey(square)) || QualityClass.Normal,\r\n            isSelected: isSquareSelected() && compareTuples(selectedSquare, [row, col]),\r\n            isInSelectedWord: isWordSelected() && doesWordContainSquare(selectedWord!, row, col),\r\n            isInSelectedSection: (Globals.activeSectionId !== 0 && isSquareInSection(getSection(), square)) ||\r\n                (Globals.hoverSectionId !== undefined && isSquareInSection(Globals.sections!.get(Globals.hoverSectionId)!, square)),\r\n            constraintSum: square.viableLetters ? square.viableLetters.length : 26,\r\n            isCircled: square.isCircled,\r\n        };\r\n    }\r\n\r\n    function getSquareElement(props: SquareProps) {\r\n        return <Square {...props}></Square>\r\n    }\r\n\r\n    function suppressEnterKey(event: any) {\r\n        let keyPressed: string = event.key.toUpperCase();\r\n\r\n        if (keyPressed === \"ENTER\") {\r\n            event.preventDefault();\r\n        }\r\n    }\r\n\r\n    function handleFocus(event: any) {\r\n        selectElementContents(event.target);\r\n    }\r\n\r\n    // https://stackoverflow.com/questions/6139107/programmatically-select-text-in-a-contenteditable-html-element/6150060#6150060\r\n    function selectElementContents(el: any) {\r\n        var range = document.createRange();\r\n        range.selectNodeContents(el);\r\n        var sel = window.getSelection();\r\n        sel!.removeAllRanges();\r\n        sel!.addRange(range);\r\n    }\r\n\r\n    function setTitle() {\r\n        let newTitle = document.getElementById(\"puzzleTitle\")!.innerText;\r\n        Globals.puzzle!.title = newTitle === \"(title)\" ? \"Untitled\" : newTitle;\r\n    }\r\n\r\n    function setAuthor() {\r\n        let newAuthor = document.getElementById(\"puzzleAuthor\")!.innerText;\r\n        Globals.puzzle!.author = newAuthor === \"(author)\" ? \"\" : newAuthor;\r\n    }\r\n\r\n    function setCopyright() {\r\n        let newCopyright = document.getElementById(\"puzzleCopyright\")!.innerText;\r\n        Globals.puzzle!.copyright = newCopyright === \"© copyright\" ? \"\" : newCopyright;\r\n    }\r\n\r\n    function setNotes() {\r\n        let newNotes = document.getElementById(\"puzzleNotes\")!.innerText;\r\n        Globals.puzzle!.notes = newNotes === \"(notes)\" ? \"\" : newNotes;\r\n    }\r\n\r\n    function generateQualityClassMap(grid: GridState): Map<string, QualityClass> {\r\n        let ret = new Map<string, QualityClass>();\r\n\r\n        let acrossWords = mapValues(grid.words).filter(w => w.direction === WordDirection.Across);\r\n        acrossWords.forEach(w => {\r\n            let squares = getSquaresForWord(grid, w);\r\n            if (isWordFull(squares)) {\r\n                let letters = getLettersFromSquares(squares);\r\n                let qc = Globals.qualityClasses ? Globals.qualityClasses!.get(letters) : QualityClass.Normal;\r\n                squares.forEach(sq => {\r\n                    if (sq.contentType === ContentType.Autofill)\r\n                        ret.set(squareKey(sq), qc || QualityClass.Iffy);\r\n                });\r\n            }\r\n        });\r\n\r\n        let downWords = mapValues(grid.words).filter(w => w.direction === WordDirection.Down);\r\n        downWords.forEach(w => {\r\n            let squares = getSquaresForWord(grid, w);\r\n            if (isWordFull(squares)) {\r\n                let letters = getLettersFromSquares(squares);\r\n                let qc = Globals.qualityClasses ? Globals.qualityClasses!.get(letters) : QualityClass.Normal;\r\n                squares.forEach(sq => {\r\n                    if (sq.contentType === ContentType.Autofill) {\r\n                        let curQc = ret.get(squareKey(sq)) || QualityClass.Normal;\r\n                        if (!qc || qc < curQc)\r\n                            ret.set(squareKey(sq), qc || QualityClass.Iffy);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n\r\n        return ret;\r\n    }\r\n\r\n    let puzzle = Globals.puzzle!;\r\n    let grid = Globals.hoverGrid ? Globals.hoverGrid! : getGrid();\r\n    let qualityClassMap = generateQualityClassMap(grid);\r\n\r\n    let squareElements = [];\r\n    for (let row = 0; row < grid.height; row++) {\r\n        for (let col = 0; col < grid.width; col++) {\r\n            let sqProps = getSquareProps(grid, row, col, selectedSquare, getSelectedWord());\r\n            squareElements.push(getSquareElement(sqProps));\r\n        }\r\n    }\r\n\r\n    let columnTemplateStyle = {\r\n        gridTemplateColumns: `repeat(${grid.width}, 1fr)`\r\n    } as React.CSSProperties;\r\n\r\n    return (\r\n        <>\r\n            <div className=\"puzzle-author-by\">&nbsp;</div>\r\n            <div id=\"puzzleTitle\" className=\"puzzle-title editable\" contentEditable={true} suppressContentEditableWarning={true}\r\n                onKeyDown={suppressEnterKey} onBlur={setTitle} onFocusCapture={handleFocus}>{puzzle.title || \"(title)\"}</div>\r\n            <div className=\"puzzle-author-by\">by&nbsp;</div>\r\n            <div id=\"puzzleAuthor\" className=\"puzzle-author editable\" contentEditable={true} suppressContentEditableWarning={true}\r\n                onKeyDown={suppressEnterKey} onBlur={setAuthor} onFocusCapture={handleFocus}>{puzzle.author || \"(author)\"}</div>\r\n            <div className=\"puzzle-author-by\">&nbsp;</div>\r\n            <div id=\"puzzleCopyright\" className=\"puzzle-copyright editable\" contentEditable={true} suppressContentEditableWarning={true}\r\n                onKeyDown={suppressEnterKey} onBlur={setCopyright} onFocusCapture={handleFocus}>{puzzle.copyright || \"© copyright\"}</div>\r\n            \r\n            <div id=\"Grid\" className=\"grid-container\" style={columnTemplateStyle}\r\n                onClick={handleClick} onKeyDown={handleKeyDown} tabIndex={0}>\r\n                {squareElements}\r\n            </div>\r\n\r\n            <div className=\"puzzle-notes-label\">Notes:</div>\r\n            <div id=\"puzzleNotes\" className=\"puzzle-notes editable\" contentEditable={true} suppressContentEditableWarning={true}\r\n                onKeyDown={suppressEnterKey} onBlur={setNotes} onFocusCapture={handleFocus}>{puzzle.notes || \"(notes)\"}</div>\r\n        </>\r\n    );\r\n}\r\n\r\nexport default Grid;\r\n","import { ContentType } from \"../models/ContentType\";\r\nimport { GridWord } from \"../models/GridWord\";\r\nimport { Puzzle } from \"../models/Puzzle\";\r\nimport { SquareType } from \"../models/SquareType\";\r\nimport { WordDirection } from \"../models/WordDirection\";\r\nimport { createNewGrid, populateWords } from \"./grid\";\r\nimport { deepClone, getGrid, mapValues, newPuzzle, wordKey } from \"./util\";\r\nimport Globals from '../lib/windowService';\r\n\r\n// https://code.google.com/archive/p/puz/wikis/FileFormat.wiki\r\n\r\nexport async function loadPuzFile(url: string): Promise<Puzzle | undefined> {\r\n    let response = await fetch(url);\r\n    let data: Blob = await response.blob();\r\n\r\n    return processPuzData(data);\r\n}\r\n\r\nexport async function processPuzData(data: Blob): Promise<Puzzle | undefined> {\r\n    let magicString = await data.slice(0x02, 0x0e).text();\r\n    if (magicString !== \"ACROSS&DOWN\\0\") return undefined;\r\n\r\n    let width = new Uint8Array(await data.slice(0x2c, 0x2d).arrayBuffer())[0];\r\n    let height = new Uint8Array(await data.slice(0x2d, 0x2e).arrayBuffer())[0];\r\n\r\n    let puzzle = newPuzzle();\r\n    let restOfFile = await blobToText(await data.slice(0x34, data.size));\r\n    let grid = createNewGrid(width, height);\r\n\r\n    let i = 0;\r\n    for (let row = 0; row < height; row++) {\r\n        for (let col = 0; col < width; col++) {\r\n            let curChar = restOfFile[i];\r\n            let square = grid.squares[row][col];\r\n            if (curChar === \".\")\r\n                square.type = SquareType.Black;\r\n            if (curChar === \"-\") {} // no data entered\r\n            if (curChar.match(/[A-Z]/)) {\r\n                square.content = curChar;\r\n                square.contentType = ContentType.User;\r\n            }\r\n            i++;\r\n        }\r\n    }\r\n    i *= 2; // skip over user progress\r\n\r\n    populateWords(grid);\r\n    \r\n    [puzzle.title, i] = getNextString(restOfFile, i);\r\n    [puzzle.author, i] = getNextString(restOfFile, i);\r\n    [puzzle.copyright, i] = getNextString(restOfFile, i);\r\n\r\n    let sortedWords = sortWordsForPuz(mapValues(grid.words));\r\n    sortedWords.forEach(word => {\r\n        let clue = \"\";\r\n        [clue, i] = getNextString(restOfFile, i);\r\n        let key = wordKey(word);\r\n        puzzle.clues.set(key, clue);\r\n    });\r\n\r\n    [puzzle.notes, i] = getNextString(restOfFile, i);\r\n\r\n    let rebusSquareMappings = new Map<string, number>();\r\n    let rebusValues = new Map<number, string>();\r\n\r\n    while (i < restOfFile.length) {\r\n        let sectionType = restOfFile.slice(i, i+4);\r\n        i += 4;\r\n        let dlI = 0x34 + i;\r\n        let dataLength = new Uint16Array(await data.slice(dlI, dlI+2).arrayBuffer())[0];\r\n        i += 2;\r\n        i += 2; // skip checksum\r\n\r\n        if (sectionType === \"GRBS\") { // rebus grid\r\n            let secI = 0x34 + i;\r\n            for (let row = 0; row < height; row++) {\r\n                for (let col = 0; col < width; col++) {\r\n                    let n = new Uint8Array(await data.slice(secI, secI + 1).arrayBuffer())[0];\r\n                    secI++;\r\n                    if (n > 0) {\r\n                        rebusSquareMappings.set(`${row},${col}`, n-1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (sectionType === \"RTBL\") { // rebus values\r\n            let valuesStr = restOfFile.slice(i, i + dataLength);\r\n            let valueStrs = valuesStr.split(\";\");\r\n            valueStrs.forEach(str => {\r\n                let tokens = str.split(\":\");\r\n                let n = +tokens[0].trim();\r\n                let val = tokens[1];\r\n                if (n > 0) rebusValues.set(n, val);\r\n            });\r\n        }\r\n        if (sectionType === \"GEXT\") { // extra flags\r\n            let secI = 0x34 + i;\r\n            for (let row = 0; row < height; row++) {\r\n                for (let col = 0; col < width; col++) {\r\n                    let n = new Uint8Array(await data.slice(secI, secI + 1).arrayBuffer())[0];\r\n                    secI++;\r\n                    if (n & 0x80) {\r\n                        grid.squares[row][col].isCircled = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        i += dataLength + 1;\r\n    }\r\n\r\n    if (rebusSquareMappings.size > 0) {\r\n        rebusSquareMappings.forEach((v, k) => {\r\n            let tokens = k.split(\",\");\r\n            let square = grid.squares[+tokens[0]][+tokens[1]];\r\n            square.content = rebusValues.get(v)![0]; // TODO: Use full value when we have rebus support\r\n            square.contentType = ContentType.User;\r\n        });\r\n    }\r\n\r\n    Globals.activeGrid = grid;\r\n    return puzzle;\r\n}\r\n\r\nasync function blobToText(blob: Blob): Promise<string> {\r\n    let arr = Array.from(new Uint8Array(await blob.arrayBuffer()));\r\n    return arr.map(x => String.fromCharCode(x)).join(\"\");\r\n}\r\n\r\nfunction getNextString(data: string, i: number): [string, number] {\r\n    let ret = \"\";\r\n    while(data[i] !== \"\\0\") {\r\n        ret += data[i];\r\n        i++;\r\n    }\r\n    i++;\r\n    return [ret.trim(), i];\r\n}\r\n\r\nexport function generatePuzFile(puzzle: Puzzle): Blob {\r\n    let grid = getGrid();\r\n    let bytes = new Uint8Array(128_000);\r\n    insertString(bytes, \"ACROSS&DOWN\\0\", 0x02);\r\n    insertString(bytes, \"1.3\\0\", 0x18);\r\n\r\n    insertNumber(bytes, grid.width, 0x2c, 1);\r\n    insertNumber(bytes, grid.height, 0x2d, 1);\r\n    insertNumber(bytes, grid.words.size, 0x2e, 2);\r\n    insertNumber(bytes, 1, 0x30, 2);\r\n    insertNumber(bytes, 0, 0x32, 2);\r\n\r\n    let pos = 0x34;\r\n    let solutionPos = pos;\r\n    let areCircledSquares = false;\r\n    for (let row = 0; row < grid.height; row++) {\r\n        for (let col = 0; col < grid.width; col++) {\r\n            let sq = grid.squares[row][col];\r\n            let char = sq.type === SquareType.Black ? \".\" : sq.content ? sq.content : \" \";\r\n            insertString(bytes, char, pos);\r\n            pos++;\r\n\r\n            if (sq.isCircled) areCircledSquares = true;\r\n        }\r\n    }\r\n    let gridPos = pos;\r\n    for (let row = 0; row < grid.height; row++) {\r\n        for (let col = 0; col < grid.width; col++) {\r\n            let sq = grid.squares[row][col];\r\n            let char = sq.type === SquareType.Black ? \".\" : \"-\";\r\n            insertString(bytes, char, pos);\r\n            pos++;\r\n        }\r\n    }\r\n\r\n    let titlePos = pos;\r\n    insertString(bytes, puzzle.title + \"\\0\", pos);\r\n    pos += puzzle.title.length + 1;\r\n    let authorPos = pos;\r\n    insertString(bytes, puzzle.author + \"\\0\", pos);\r\n    pos += puzzle.author.length + 1;\r\n    let copyrightPos = pos;\r\n    insertString(bytes, puzzle.copyright + \"\\0\", pos);\r\n    pos += puzzle.copyright.length + 1;\r\n\r\n    let orderedClues = [] as string[];\r\n    let sortedWords = sortWordsForPuz(mapValues(grid.words));\r\n    sortedWords.forEach(word => {\r\n        let key = wordKey(word);\r\n        orderedClues.push(puzzle.clues.get(key)! || \"\");\r\n    });\r\n\r\n    let cluesPos = pos;\r\n    orderedClues.forEach(oc => {\r\n        insertString(bytes, oc + \"\\0\", pos);\r\n        pos += oc.length + 1;\r\n    });\r\n\r\n    insertString(bytes, puzzle.notes + \"\\0\", pos);\r\n    pos++;\r\n\r\n    if (areCircledSquares) {\r\n        let sectionSize = grid.width * grid.height;\r\n        insertString(bytes, \"GEXT\", pos);\r\n        pos += 4;\r\n        insertNumber(bytes, sectionSize, pos, 2);\r\n        pos += 2;\r\n        let checksumPos = pos;\r\n        pos += 2;\r\n        for (let row = 0; row < grid.height; row++) {\r\n            for (let col = 0; col < grid.width; col++) {\r\n                let sq = grid.squares[row][col];\r\n                insertNumber(bytes, sq.isCircled ? 0x80 : 0, pos, 1);\r\n                pos++;\r\n            }\r\n        }\r\n        insertString(bytes, \"\\0\", pos);\r\n        pos++;\r\n\r\n        let cksum = cksum_region(bytes, checksumPos + 2, sectionSize, 0);\r\n        insertNumber(bytes, cksum, checksumPos, 2);\r\n    }\r\n\r\n    let c_cib = cksum_region(bytes, 0x2c, 8, 0);\r\n    let cksum = c_cib;\r\n    let squaresTotal = grid.width*grid.height;\r\n    cksum = cksum_region(bytes, solutionPos, squaresTotal, cksum);\r\n    cksum = cksum_region(bytes, gridPos, squaresTotal, cksum);\r\n    if (puzzle.title.length > 0) cksum = cksum_region(bytes, titlePos, puzzle.title.length+1, cksum);\r\n    if (puzzle.author.length > 0) cksum = cksum_region(bytes, authorPos, puzzle.author.length+1, cksum);\r\n    if (puzzle.copyright.length > 0) cksum = cksum_region(bytes, copyrightPos, puzzle.copyright.length+1, cksum);\r\n    let cluePos = cluesPos;\r\n    for(let i = 0; i < orderedClues.length; i++) {\r\n        let clue = orderedClues[i];\r\n        cksum = cksum_region(bytes, cluePos, clue.length, cksum);\r\n        cluePos += clue.length+1;\r\n    }\r\n    insertNumber(bytes, c_cib, 0x0e, 2);\r\n    insertNumber(bytes, cksum, 0x00, 2);\r\n\r\n    let c_sol = cksum_region(bytes, solutionPos, squaresTotal, 0);\r\n    let c_grid = cksum_region(bytes, gridPos, squaresTotal, 0);\r\n    let c_part = 0;\r\n    if (puzzle.title.length > 0) c_part = cksum_region(bytes, titlePos, puzzle.title.length+1, c_part);\r\n    if (puzzle.author.length > 0) c_part= cksum_region(bytes, authorPos, puzzle.author.length+1, c_part);\r\n    if (puzzle.copyright.length > 0) c_part = cksum_region(bytes, copyrightPos, puzzle.copyright.length+1, c_part);\r\n    cluePos = cluesPos;\r\n    for(let i = 0; i < orderedClues.length; i++) {\r\n        let clue = orderedClues[i];\r\n        c_part = cksum_region(bytes, cluePos, clue.length, c_part);\r\n        cluePos += clue.length+1;\r\n    }\r\n    insertNumber(bytes, 0x49 ^ (c_cib & 0xFF), 0x10, 1);\r\n    insertNumber(bytes, 0x43 ^ (c_sol & 0xFF), 0x11, 1);\r\n    insertNumber(bytes, 0x48 ^ (c_grid & 0xFF), 0x12, 1);\r\n    insertNumber(bytes, 0x45 ^ (c_part & 0xFF), 0x13, 1);\r\n    insertNumber(bytes, 0x41 ^ ((c_cib & 0xFF00) >> 8), 0x14, 1);\r\n    insertNumber(bytes, 0x54 ^ ((c_sol & 0xFF00) >> 8), 0x15, 1);\r\n    insertNumber(bytes, 0x45 ^ ((c_grid & 0xFF00) >> 8), 0x16, 1);\r\n    insertNumber(bytes, 0x44 ^ ((c_part & 0xFF00) >> 8), 0x17, 1);\r\n\r\n    let finalArray = bytes.slice(0, pos);\r\n    return new Blob([finalArray], {type: \"application/octet-stream; charset=ISO-8859-1\"});\r\n}\r\n\r\n// http://www.keiranking.com/phil/\r\nfunction cksum_region(bytes: Uint8Array, startPos: number, len: number, cksum: number) {\r\n    for (let i = 0; i < len; i++) {\r\n        cksum = (cksum >> 1) | ((cksum & 1) << 15);\r\n        cksum = (cksum + bytes[startPos + i]) & 0xffff;\r\n    }\r\n    \r\n    return cksum; \r\n}\r\n\r\nfunction insertString(bytes: Uint8Array, str: string, pos: number) {\r\n    for (let i = 0; i < str.length; i++) {\r\n        bytes[pos] = str[i].charCodeAt(0);\r\n        pos++;\r\n    }\r\n}\r\n\r\nfunction insertNumber(bytes: Uint8Array, n: number, pos: number, size: number) {\r\n    for (var index = size-1; index >= 0; --index) {\r\n      bytes[pos] = n % 256;\r\n      n = n >> 8;\r\n      pos++;\r\n    }\r\n}\r\n\r\nfunction sortWordsForPuz(words: GridWord[]): GridWord[] {\r\n    let sortedWords = (deepClone(words) as GridWord[]).sort((a, b) => {\r\n        if (a.start[0] !== b.start[0]) return a.start[0] - b.start[0];\r\n        if (a.start[1] !== b.start[1]) return a.start[1] - b.start[1];\r\n        return a.direction === WordDirection.Across ? -1 : 1;\r\n    });\r\n    return sortedWords;\r\n}\r\n","import React, { createRef, useContext, useRef } from 'react';\r\nimport \"./Menu.scss\";\r\nimport { MenuProps } from './MenuProps';\r\nimport { AppContext } from '../../AppContext';\r\nimport { processPuzData } from '../../lib/puzFiles';\r\n\r\nfunction Menu(props: MenuProps) {\r\n    const appContext = useContext(AppContext);\r\n    const sizeRefs = useRef([createRef(), createRef()] as any[]);\r\n\r\n    function handleViewChange(event: any) {\r\n        let target = event.target;\r\n        let newView = target.attributes[\"data-view-id\"].value;\r\n        \r\n        appContext.switchActiveView(newView);\r\n    }\r\n\r\n    function handleNewPuzzle() {\r\n        if (!window.confirm(\"Are you sure you want to start a new puzzle?\")) return;\r\n\r\n        let newWidth = +sizeRefs.current[0].current.value;\r\n        let newHeight = +sizeRefs.current[1].current.value;\r\n\r\n        appContext.createNewPuzzle(newWidth, newHeight);\r\n    }\r\n\r\n    function handleLoadPuz() {\r\n        document.getElementById(\"open-puzzle-input\")!.click();\r\n    }\r\n\r\n    function handleExportPuz() {\r\n        appContext.exportPuz();\r\n    }\r\n\r\n    function handleFocus(event: any) {\r\n        event.target.select();\r\n    }\r\n\r\n    function onFileUpload(event: any) {\r\n        let file = event.target.files[0];\r\n        event.target.value = null;\r\n\r\n        processPuzData(file).then(puzzle => {\r\n            if (puzzle) {\r\n                appContext.setPuzzle(puzzle);\r\n            }\r\n        });\r\n    }\r\n\r\n    return (\r\n        <div id=\"Menu\">\r\n            <input id=\"open-puzzle-input\" hidden type=\"file\" accept=\".puz\" onChange={onFileUpload} />\r\n\r\n            <div className=\"site-title\">CrossHatch</div>\r\n\r\n            <div className=\"menu-label\">View: </div>\r\n            <div className=\"btn-group\" role=\"group\" id=\"view-change-group\">\r\n                <button type=\"button\" data-view-id=\"Clues\"\r\n                    className={\"btn\" + (props.openView === \"Clues\" ? \" btn-primary\" : \" btn-secondary\")}\r\n                    onClick={handleViewChange}>\r\n                    Clues\r\n                </button>\r\n                <button type=\"button\" data-view-id=\"Fill\"\r\n                    className={\"btn\" + (props.openView === \"Fill\" ? \" btn-primary\" : \" btn-secondary\")}\r\n                    onClick={handleViewChange}>\r\n                    Fill\r\n                </button>\r\n            </div>\r\n            \r\n            <div className=\"new-grid-group\">\r\n                <div className=\"btn btn-primary\" onClick={handleNewPuzzle}>New Puzzle</div>\r\n                <input type=\"text\" className=\"form-control\" defaultValue={props.gridWidth} onFocus={handleFocus}\r\n                    ref={sizeRefs.current[0]}></input>\r\n                <div className=\"menu-gridsize-sep\"><div style={{height:\"6px\", float:\"none\"}}></div>x</div>\r\n                <input type=\"text\" className=\"form-control\" defaultValue={props.gridHeight} onFocus={handleFocus}\r\n                    ref={sizeRefs.current[1]}></input>\r\n            </div>\r\n            \r\n            <div id=\"loadPuz\" className=\"btn btn-primary menu-button\" onClick={handleLoadPuz}>Load .puz</div>\r\n            <div id=\"exportPuz\" className=\"btn btn-primary menu-button\" onClick={handleExportPuz}>Export .puz</div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Menu;\r\n","import React, { useEffect, useState } from 'react';\r\nimport { AppContext } from './AppContext';\r\nimport { AppProps } from './AppProps';\r\nimport CluesView from './components/CluesView/CluesView';\r\nimport FillView from './components/FillView/FillView';\r\nimport Grid from './components/Grid/Grid';\r\nimport Menu from './components/Menu/Menu';\r\nimport Globals from './lib/windowService';\r\nimport \"./App.scss\";\r\nimport { Puzzle } from './models/Puzzle';\r\nimport { getGrid, initializeSessionGlobals, newPuzzle } from './lib/util';\r\nimport { generatePuzFile } from './lib/puzFiles';\r\nimport { SymmetryType } from './models/SymmetryType';\r\nimport { clearFill, createNewGrid } from './lib/grid';\r\nimport { WordDirection } from './models/WordDirection';\r\nimport { FillStatus } from './models/FillStatus';\r\n\r\nfunction App(props: AppProps) {\r\n  const [activeView, setActiveView] = useState(props.activeView);\r\n  const [gridWidth, setGridWidth] = useState(15);\r\n  const [gridHeight, setGridHeight] = useState(15);\r\n  const [updateSemaphore, setUpdateSemaphore] = useState(0);\r\n  const [appState, setAppState] = useState(getAppContext());\r\n\r\n  useEffect(() => {\r\n    setAppState(getAppContext());\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [updateSemaphore]);\r\n\r\n  function getAppContext() {\r\n    return { \r\n      triggerUpdate: triggerUpdate,\r\n      switchActiveView: switchActiveView,\r\n      setPuzzle: setPuzzle,\r\n      createNewPuzzle: createNewPuzzle,\r\n      exportPuz: exportPuz,\r\n    }\r\n  }\r\n\r\n  function triggerUpdate() {\r\n    setUpdateSemaphore(updateSemaphore + 1);\r\n  }\r\n\r\n  function switchActiveView(newView: string) {\r\n    setActiveView(newView);\r\n  }\r\n\r\n  function createNewPuzzle(width: number, height: number) {\r\n    initializeGlobals(undefined, width, height);\r\n    triggerUpdate();\r\n  }\r\n\r\n  function setPuzzle(puzzle: Puzzle) {\r\n    let grid = getGrid();\r\n    initializeGlobals(puzzle, grid.width, grid.height);\r\n    triggerUpdate();\r\n  }\r\n\r\n  function exportPuz() {\r\n    let puzzle = Globals.puzzle!;\r\n    let blob = generatePuzFile(puzzle);\r\n    let filename = (puzzle.title || \"Untitled\")+\".puz\";\r\n    let file = new File([blob], filename);\r\n    const url= window.URL.createObjectURL(file);\r\n    let puzzleLink = document.getElementById(\"download-puzzle-link\");\r\n    puzzleLink!.setAttribute(\"href\", url);\r\n    puzzleLink!.setAttribute(\"download\", filename);\r\n    puzzleLink!.click();\r\n  }\r\n\r\n  function initializeGlobals(puzzle?: Puzzle, width?: number, height?: number) {\r\n    let isNewPuzzle = !!puzzle;\r\n    Globals.puzzle = puzzle || newPuzzle();\r\n    if (width === undefined) width = gridWidth;\r\n    if (height === undefined) height = gridHeight;\r\n    if (!Globals.activeGrid || !isNewPuzzle)\r\n      Globals.activeGrid = createNewGrid(width, height);\r\n    Globals.hoverGrid = undefined;\r\n    Globals.selectedWordKey = undefined;\r\n    Globals.selectedWordDir = WordDirection.Across;\r\n    if (!Globals.gridSymmetry) Globals.gridSymmetry = SymmetryType.Rotate180;\r\n    if (Globals.useManualHeuristics === undefined) Globals.useManualHeuristics = true;\r\n    if (Globals.maxIffyLength === undefined) Globals.maxIffyLength = 0;\r\n    Globals.selectedWordNode = undefined;\r\n    Globals.curChainId = 1;\r\n    if (Globals.wordLists === undefined) Globals.wordLists = [];\r\n    Globals.fillStatus = Globals.wordList !== undefined ? FillStatus.Ready : FillStatus.NoWordList;\r\n\r\n    initializeSessionGlobals();\r\n    clearFill(Globals.activeGrid!);\r\n\r\n    setGridWidth(width);\r\n    setGridHeight(height);\r\n  }\r\n\r\n  if (!Globals.puzzle) {\r\n    initializeGlobals();\r\n    triggerUpdate();\r\n  }\r\n\r\n  return (\r\n    <AppContext.Provider value={appState}>\r\n      <a id=\"download-puzzle-link\" href=\"http://www.example.com\" style={{display: \"none\"}}>stuff</a>\r\n\r\n      <Menu gridHeight={gridHeight} gridWidth={gridWidth} openView={activeView}></Menu>\r\n\r\n      <div className=\"main-panel\">\r\n        {activeView === \"Clues\" && \r\n            <CluesView updateSemaphore={updateSemaphore}></CluesView>\r\n        }\r\n        {activeView === \"Fill\" && \r\n            <FillView></FillView>\r\n        }\r\n      </div>\r\n      \r\n      <div className=\"main-panel\">\r\n        <Grid></Grid>\r\n      </div>\r\n    </AppContext.Provider>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\nimport 'bootstrap/dist/css/bootstrap.css';\r\n\r\n// import { loadWordListFromLocalhost } from './lib/wordList';\r\n// import Globals from './lib/windowService';\r\n// import { FillStatus } from './models/FillStatus';\r\n// loadWordListFromLocalhost(\"http://localhost/classifier/mainBrodaEntries.txt\").then(() => {\r\n//   Globals.fillStatus = FillStatus.Ready;\r\n// });\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App activeView=\"Fill\" />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n"],"sourceRoot":""}