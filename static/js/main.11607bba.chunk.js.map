{"version":3,"sources":["models/SquareType.ts","models/WordDirection.ts","AppContext.ts","lib/windowService.tsx","models/SymmetryType.ts","models/ContentType.ts","models/QualityClass.ts","lib/wordList.ts","lib/entryCandidates.ts","lib/util.ts","lib/section.ts","lib/insertEntry.ts","lib/priorityQueue.ts","models/FillStatus.ts","lib/fill.ts","lib/grid.ts","components/CluesView/CluesView.tsx","components/FillView/FillView.tsx","lib/useInterval.ts","components/Square/Square.tsx","components/Grid/Grid.tsx","lib/puzFiles.ts","components/Menu/Menu.tsx","App.tsx","index.tsx"],"names":["SquareType","WordDirection","AppContext","React","createContext","triggerUpdate","switchActiveView","_","setPuzzle","createNewPuzzle","w","h","exportPuz","window","Globals","SymmetryType","ContentType","QualityClass","filename","data","a","text","lines","split","indexWordList","words","parseWordList","wordList","wordCount","length","qcMap","qualityClasses","Map","forEach","line","tokens","trim","match","score","qualityClass","Lively","Normal","Crosswordese","word","has","push","set","queryIndexedWordList","pattern","wl","letters","i","buckets","oneVal","charCodeAt","pos1","pos2","val1","val2","twoVal","filter","entries","existingList","ch1","ch2","populateAndScoreEntryCandidates","node","isForManualFill","wordKey","fillWord","iffyWordKey","populateNoHeuristicEntryCandidates","anchorSquareKeys","anchorInfo","populateFillWordAnchors","getSquaresForWord","startGrid","anchorCombosLeft","eligibleCandidates","processAnchorCombo","getEligibleCandidates","ec","entryCandidates","sort","b","dontRecalc","undefined","getLettersFromSquares","deepClone","get","entry","getWordScore","isViable","hasBeenChained","wasChainFailure","crossScore","minCrossScore","squares","calculatedSquares","anchorKeyCounts","sq","count","squareKey","viableLetters","constraintLetterCount","combos","constraintLetters","map","sqKey","find","content","fullAlphabet","comboScores","letter1","letter2","letterFrequencies","Math","random","generateAnchorCombos","setIffySquares","iffyWord","grid","combo","pop","fillWordKey","wordSquares","patternWithAnchor","insertLetterIntoPattern","isWordFull","getFilteredEntries","usedWords","maxIffyLength","crossKeys","getUnfilledCrosses","ck","wordLength","maxFilteredEntryCount","processEntry","maxCount","distillIndex","batchKeys","filledCrosses","filteredEntriesCount","foundCountReduction","nextBatchKeys","wKey","getAllCrosses","cross","crossKey","crossSquares","crossPattern","filteredEntries","newPattern","includes","fe","reduce","newMatrix","Array","fill","letterMatrixToLetterList","existingCounts","topCrossScore","topMinCrossScore","iffyEntry","iffySquares","isq","idx","calSq","substring","crossCrossKeys","cc","cck","wordScore","calculateEntryCandidateScore","anchorPattern","constraintCounts","x","curPatterns","lowestCount","index","newCurPatterns","ltr","broadenAnchorPatterns","newLetter","findIndex","updateSectionFilters","sections","getGrid","sec","candidates","can","sqKeys","mapKeys","isFilteredOut","gridSq","getSquareAtKey","canSq","isUserOrWordFilled","insertSectionCandidateIntoGrid","candidate","contentType","ChosenSection","newGrid","section","sectionId","foundDiscrepancy","candidateSq","HoverChosenSection","Autofill","forAllGridSquares","newSq","row","col","key","neighboringCrosses","generateConstraintInfoForSquares","userFilledSectionCandidates","sectionCandidateKey","generateGridSections","usedSquares","nextSectionId","fullSection","makeNewSection","isBlackSquare","isOpenSquare","newSection","iterateSection","openSquareCount","getNeighboringSquares","neighbor","Across","Down","dir","getWordAtSquare","wsq","id","size","delete","stackWords","stackedNeighbors","otherKey","otherWord","isAcross","abs","start","min","end","max","sk","wordOrder","calculateSectionOrder","mapValues","secOrder","calculateWordOrder","wk","connections","wordsSort","direction","iterateWordGroup","group","centerIndex","floor","rowOrCol","slice","acrossSortedStackWords","downSortedStackWords","longestStack","stack","curGroup","prevRowOrCol","j","newWord","newRowOrCol","neighbors","n","ret","nClear","sClear","height","wClear","eClear","width","calculateSectionCandidateScore","total","natoAlphabet","k","join","comboPermsQueue","comboPermsUsed","getSelectedSectionCandidates","selectedSectionCandidateKeys","scKey","getSectionWithCandidate","sc","getSectionsWithWord","processAndInsertChosenEntry","chosenEntry","crosses","HoverChosenWord","ChosenWord","newSquares","getSectionCandidatesFromKeys","removeNonmatchingSectionCandidates","endGrid","FillStatus","fillSectionWord","getSection","fillQueue","newFillQueue","heap","left","right","hasRight","swap","temp","isEmpty","peek","value","insert","item","prio","p","tmp","current","largerChild","priorityQueue","populateSeedNodes","needsNewPriority","shouldBeDeleted","calculateNodePriority","isChainNode","chainId","curChainId","activeGrid","selectWordToFill","topScore","c","pow","roll","runningTotal","chooseEntryFromCandidates","processSectionNode","sectionString","getSectionString","newSecCandidateFound","newCandidate","getEntryAtWordKey","newSectionCandidate","invalidateChainNode","newNode","makeNewNode","depth","nextFillWord","curSections","nextSections","cs","ns","selectedWordNode","parent","prevCandidate","backtracks","chainBaseNode","chainIffyCandidates","chainGoodCandidates","curNode","isSectionBase","situationScore","selectedSectionIds","activeSectionId","activeSection","connectionIds","selectedCandidate","candidateCounts","comboKey","perm","toString","shift","defaultCombo","allOnes","foundNew","newPerm","newPermKey","getNewPermutations","wasSuccess","viableLetterCounts","otherDir","Iffy","populateWords","processSquare","currentWord","number","nextSq","currentNumber","isAboveBlocked","isBelowBlocked","isLeftBlocked","isRightBlocked","isUnchecked","isUncheckedStart","isCheckedStart","numberizeGrid","updateGridConstraintInfo","wordKeys","concat","isWordEmpty","entryOptions","curViableMatrix","list","matrix","letterListToLetterMatrix","newViableMatrix","arr","newVal","setLettersArrayVal","createNewGrid","type","White","isCircled","getSymmetrySquares","initSquare","r","gridSymmetry","Rotate180","Rotate90","MirrorHorizontal","MirrorVertical","MirrorNWSE","MirrorNESW","eraseGridSquare","otherDirWord","otherDirSquares","User","isInSection","csq","clearFill","eraseSectionCandidateFromGrid","getSelectedSectionCandidatesWithSquare","fillStatus","Ready","NoWordList","isUserFilled","updateManualEntryCandidates","selectedWordKey","useManualHeuristics","obj","Date","getTime","from","Object","keys","newObj","compareTuples","first","second","Black","doesWordContainSquare","func","newPuzzle","title","author","copyright","clues","notes","getSelectedWord","values","sck","initializeSessionGlobals","hoverSectionId","String","fromCharCode","CluesView","props","useState","initClueProps","clueProps","setClueProps","selectedKey","setSelectedKey","textareasRef","useRef","puzzle","prop","clue","isOpenForEditing","handleClueClick","event","target","classList","parentElement","targetKey","attributes","refIndex","textareaEl","newClueProps","propToToggle","style","display","focus","handleKeyDown","toUpperCase","newValue","targetProp","applyClueChange","handleFocus","select","renderCluesContainer","clueList","className","createRef","data-key","onClick","data-ref-index","defaultValue","onKeyDown","onFocus","ref","useEffect","updateSemaphore","acrossClues","downClues","FillView","appContext","useContext","showSectionCandidates","setShowSectionCandidates","isWordListLoading","setIsWordListLoading","isFillRunning","setIsFillRunning","setFillStatus","newStatus","getManualEntryNode","isHover","insertEntryIntoGrid","getManualSectionNode","handleEntryCandidateClick","hoverGrid","handleEntryCandidateHover","handleSectionClick","handleSectionCheckClick","handleSectionHover","handleSectionCandidateClick","eraseSc","candidateKey","handleSectionCandidateHover","callback","delay","savedCallback","setInterval","clearInterval","useInterval","Complete","selectedSymmetry","symmetryOptions","t","isNaN","Number","fillStatusStr","status","Running","getFillStatusString","wordLists","isNoEntryCandidates","selectedScKey","sectionCandidates","selectedEntry","selectedMaxIffyLength","hidden","accept","onChange","file","files","setTimeout","processWordListData","name","then","checked","htmlFor","selectedIndex","getSymmetryTypeString","confirm","document","getElementById","click","gridTemplateColumns","cursor","onMouseOut","data-word","data-iffykey","onMouseOver","toFixed","data-id","getLongest","getLongestStackWord","data-candidate-key","between","input","Square","isSelected","isInSelectedWord","isInSelectedSection","constraintSum","data-row","data-col","NotAThing","getSquareElement","Grid","selectedSquare","setSelectedSquare","advanceCursor","selSq","isSquareSelected","selectedWordDir","newSelSq","setSelWordAtSelSquare","isSquareInSection","newSelSquare","getSquareProps","selectedWord","square","qualityClassMap","suppressEnterKey","preventDefault","el","range","createRange","selectNodeContents","sel","getSelection","removeAllRanges","addRange","selectElementContents","qc","curQc","generateQualityClassMap","squareElements","sqProps","columnTemplateStyle","contentEditable","suppressContentEditableWarning","onBlur","newTitle","innerText","onFocusCapture","newAuthor","newCopyright","newDirection","uncheckedSquareDir","getUncheckedSquareDir","letterChanged","blackSquareChanged","backupCursor","res","newSquareType","tabIndex","newNotes","processPuzData","Uint8Array","arrayBuffer","blobToText","restOfFile","curChar","getNextString","sortWordsForPuz","rebusSquareMappings","rebusValues","sectionType","dlI","Uint16Array","dataLength","secI","valuesStr","str","val","v","blob","cksum_region","bytes","startPos","len","cksum","insertString","pos","insertNumber","Menu","sizeRefs","handleViewChange","newView","role","data-view-id","openView","newWidth","newHeight","gridWidth","float","gridHeight","App","activeView","setActiveView","setGridWidth","setGridHeight","setUpdateSemaphore","getAppContext","appState","setAppState","initializeGlobals","solutionPos","areCircledSquares","char","gridPos","titlePos","authorPos","copyrightPos","orderedClues","cluesPos","oc","sectionSize","checksumPos","c_cib","squaresTotal","cluePos","c_sol","c_grid","c_part","finalArray","Blob","generatePuzFile","File","url","URL","createObjectURL","puzzleLink","setAttribute","isNewPuzzle","Provider","href","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.11607bba.chunk.js","sourcesContent":["export enum SquareType {\r\n    White,\r\n    Black,\r\n    //Blank,\r\n}\r\n","export enum WordDirection {\r\n    Across,\r\n    Down,\r\n}\r\n","import React from \"react\";\r\nimport { Puzzle } from \"./models/Puzzle\";\r\n\r\nexport const AppContext = React.createContext({\r\n    triggerUpdate: () => {},\r\n    switchActiveView: (_: string) => {},\r\n    setPuzzle: (_: Puzzle) => {},\r\n    createNewPuzzle: (w: number, h: number) => {},\r\n    exportPuz: () => {},\r\n  });\r\n  ","import { GlobalsObj } from \"../models/GlobalsObj\";\r\n\r\ndeclare const window: any;\r\nwindow.Globals = {} as GlobalsObj;\r\nexport default window.Globals as GlobalsObj;\r\n","export enum SymmetryType {\r\n    None,\r\n    Rotate180,\r\n    Rotate90,\r\n    MirrorHorizontal,\r\n    MirrorVertical,\r\n    MirrorNWSE,\r\n    MirrorNESW,\r\n}\r\n","export enum ContentType {\r\n    User,\r\n    ChosenWord,\r\n    HoverChosenWord,\r\n    ChosenSection,\r\n    HoverChosenSection,\r\n    Autofill,\r\n}\r\n","export enum QualityClass {\r\n    NotAThing,\r\n    Iffy,\r\n    Crosswordese,\r\n    Normal,\r\n    Lively,\r\n}\r\n","import { IndexedWordList } from \"../models/IndexedWordList\";\r\nimport { QualityClass } from \"../models/QualityClass\";\r\nimport { WordList } from \"../models/WordList\";\r\nimport Globals from './windowService';\r\n\r\nexport async function processWordListData(filename: string, data: Blob): Promise<WordList | undefined> {\r\n    let lines = (await data.text()).split(\"\\n\");\r\n    let words = parseWordList(lines);\r\n    indexWordList(words, Globals.wordList);\r\n\r\n    return {\r\n        filename: filename,\r\n        wordCount: words.length,\r\n    } as WordList;\r\n}\r\n\r\nexport async function loadWordListFromLocalhost(url: string) {\r\n    var response = await fetch(url);\r\n    const lines = (await response.text()).split('\\n');\r\n    let words = parseWordList(lines);\r\n    indexWordList(words, Globals.wordList);\r\n    let filenameTokens = url.split(\"/\");\r\n    let filename = filenameTokens[filenameTokens.length - 1];\r\n\r\n    Globals.wordLists = [];\r\n    Globals.wordLists!.push({\r\n        filename: filename,\r\n        wordCount: words.length,\r\n    });\r\n\r\n    console.log(\"Word List loaded\");\r\n}\r\n\r\nfunction parseWordList(lines: string[]): string[] {\r\n    let qcMap = Globals.qualityClasses || new Map<string, QualityClass>();\r\n    let words = [] as string[];\r\n\r\n    lines.forEach(line => {\r\n        let tokens = line.trim().split(\";\");\r\n        if (tokens.length > 2) return;\r\n        if (!tokens[0].match(/^[A-Z]+$/)) return;\r\n\r\n        let score = tokens.length === 2 ? +tokens[1] : 50;\r\n        let qualityClass = score >= 100 ? QualityClass.Lively :\r\n                           score >= 50 ? QualityClass.Normal :\r\n                           QualityClass.Crosswordese;\r\n        let word = tokens[0];\r\n        if (word.length >= 2 && word.length <= 15) {\r\n            if (!qcMap.has(word)) words.push(word);\r\n            qcMap.set(word, qualityClass);\r\n        }\r\n    });\r\n\r\n    Globals.qualityClasses = qcMap;\r\n\r\n    return words;\r\n}\r\n\r\nexport function queryIndexedWordList(pattern: string): string[] {\r\n    let wl = Globals.wordList!;\r\n    let words = [] as string[];\r\n    if (pattern.length > 15) return words;\r\n    let letters = [] as [number, string][];\r\n    let length = pattern.length;\r\n    for (let i = 0; i < pattern.length; i++) {\r\n        if (pattern[i] !== \"-\") {\r\n            letters.push([i+1, pattern[i]]);\r\n        }\r\n    }\r\n\r\n    if (letters.length === 1) {\r\n        words = wl.buckets.oneVal[length-2][letters[0][0]-1][letters[0][1].charCodeAt(0)-65];\r\n    }\r\n    else if (letters.length === pattern.length) {\r\n        words = Globals.qualityClasses?.has(pattern) ? [pattern] : [];\r\n    }\r\n    else if (letters.length > 1) {\r\n        let pos1 = letters[0][0];\r\n        let pos2 = letters[1][0];\r\n        let val1 = letters[0][1];\r\n        let val2 = letters[1][1];\r\n        words = wl.buckets.twoVal[length-2][pos1-1][pos2-(pos1+1)][val1.charCodeAt(0)-65][val2.charCodeAt(0)-65];\r\n\r\n        for (let i = 2; i < letters.length; i++) {\r\n            words = words.filter(w => w[letters[i][0]-1] === letters[i][1]);\r\n        }\r\n    }\r\n\r\n    return words;\r\n}\r\n\r\nfunction indexWordList(entries: string[], existingList?: IndexedWordList) {\r\n    let buckets = existingList ? existingList.buckets : {\r\n        oneVal: [] as any[],\r\n        twoVal: [] as any[],\r\n    };\r\n\r\n    for (let length = 2; length <= 15; length++) {\r\n        buckets.oneVal.push([] as any[]);\r\n        for (let pos1 = 1; pos1 <= length; pos1++) {\r\n            buckets.oneVal[length-2].push([] as any[]);\r\n            for (let ch1 = 65; ch1 <= 90; ch1++) {\r\n                buckets.oneVal[length-2][pos1-1].push([] as string[]);\r\n            }\r\n        }\r\n    }\r\n\r\n    for (let length = 2; length <= 15; length++) {\r\n        buckets.twoVal.push([] as any[]);\r\n        for (let pos1 = 1; pos1 <= length-1; pos1++) {\r\n            buckets.twoVal[length-2].push([] as any[]);\r\n            for (let pos2 = pos1+1; pos2 <= length; pos2++) {\r\n                buckets.twoVal[length-2][pos1-1].push([] as any[]);\r\n                for (let ch1 = 65; ch1 <= 90; ch1++) {\r\n                    buckets.twoVal[length-2][pos1-1][pos2-(pos1+1)].push([] as any[]);\r\n                    for (let ch2 = 65; ch2 <= 90; ch2++) {\r\n                        buckets.twoVal[length-2][pos1-1][pos2-(pos1+1)][ch1-65].push([] as string[]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    entries.forEach(word => {\r\n        // 1-position entries\r\n        for (let pos1 = 1; pos1 <= word.length; pos1++) {\r\n            buckets.oneVal[word.length-2][pos1-1][word[pos1-1].charCodeAt(0)-65].push(word);\r\n        }\r\n\r\n        // 2-position entries\r\n        for (let pos1 = 1; pos1 < word.length; pos1++) {\r\n            for (let pos2 = pos1 + 1; pos2 <= word.length; pos2++) {\r\n                buckets.twoVal[word.length-2][pos1-1][pos2-(pos1+1)][word[pos1-1].charCodeAt(0)-65][word[pos2-1].charCodeAt(0)-65].push(word);\r\n            }\r\n        }\r\n    });\r\n\r\n    Globals.wordList = { buckets: buckets } as IndexedWordList;\r\n}\r\n","import { EntryCandidate } from \"../models/EntryCandidate\";\r\nimport { FillNode } from \"../models/FillNode\";\r\nimport { GridSquare } from \"../models/GridSquare\";\r\nimport { getAllCrosses, getEligibleCandidates, getUnfilledCrosses, getWordScore } from \"./fill\";\r\nimport { getLettersFromSquares } from \"./grid\";\r\nimport { constraintLetterCount, deepClone, fullAlphabet, getSquaresForWord, \r\n    isWordFull, letterMatrixToLetterList, squareKey, sum, wordKey, wordLength } from \"./util\";\r\nimport { queryIndexedWordList } from \"./wordList\";\r\nimport Globals from './windowService';\r\nimport { GridState } from \"../models/GridState\";\r\n\r\n// returns false if no viable candidates were found or iffy was set\r\nexport function populateAndScoreEntryCandidates(node: FillNode, isForManualFill: boolean): boolean {\r\n    if (isForManualFill && wordKey(node.fillWord!) === node.iffyWordKey) {\r\n        populateNoHeuristicEntryCandidates(node);\r\n        return true;\r\n    }\r\n\r\n    if (node.anchorSquareKeys.length === 0) {\r\n        let word = node.fillWord!;\r\n        let squares = getSquaresForWord(node.startGrid, word);\r\n        let anchorInfo = populateFillWordAnchors(squares);\r\n        node.anchorCombosLeft = anchorInfo.anchorCombosLeft;\r\n        node.anchorSquareKeys = anchorInfo.anchorSquareKeys;\r\n    }\r\n\r\n    let eligibleCandidates = [] as EntryCandidate[];\r\n    while(true) {\r\n        processAnchorCombo(node, isForManualFill);\r\n        eligibleCandidates = getEligibleCandidates(node);\r\n        if (node.anchorCombosLeft.length === 0) break;\r\n        if (eligibleCandidates.filter(ec => !ec.iffyWordKey).length > (isForManualFill ? 100 : 0)) break;\r\n    }\r\n\r\n    node.entryCandidates.sort((a, b) => b.score! - a.score!);\r\n    return true;\r\n}\r\n\r\nexport function populateNoHeuristicEntryCandidates(node: FillNode, dontRecalc?: boolean) {\r\n    if (dontRecalc === undefined) dontRecalc = false;\r\n    if (node.entryCandidates.length > 0 && dontRecalc) return;\r\n\r\n    let word = node.fillWord!;\r\n    let squares = deepClone(getSquaresForWord(node.startGrid, word)) as GridSquare[];\r\n    let pattern = getLettersFromSquares(squares);\r\n    let entries = queryIndexedWordList(pattern).sort((a, b) => Globals.qualityClasses!.get(b)! - Globals.qualityClasses!.get(a)!);\r\n\r\n    node.entryCandidates = [];\r\n    entries.forEach(entry => {\r\n        node.entryCandidates.push({\r\n            word: entry,\r\n            score: getWordScore(entry),\r\n            isViable: true,\r\n            hasBeenChained: false,\r\n            wasChainFailure: false,\r\n            crossScore: 0,\r\n            minCrossScore: 0,\r\n        } as EntryCandidate);\r\n    });\r\n}\r\n\r\nfunction populateFillWordAnchors(squares: GridSquare[], calculatedSquares?: Map<string, string[]>):\r\n    { anchorSquareKeys: string[], anchorCombosLeft: [string, string][] } {\r\n    let anchorKeyCounts = [] as [string, number][];\r\n\r\n    squares.forEach(sq => {\r\n        let count = (calculatedSquares && calculatedSquares.has(squareKey(sq))) ? \r\n            calculatedSquares!.get(squareKey(sq))!.length : constraintLetterCount(sq);\r\n        if (count === 0) return; // don't anchor iffy\r\n\r\n        if (anchorKeyCounts.length < 2) {\r\n            anchorKeyCounts.push([squareKey(sq), count]);\r\n            anchorKeyCounts.sort((a, b) => a[1] - b[1]);\r\n            return;\r\n        }\r\n\r\n        if (count < anchorKeyCounts[1][1]) {\r\n            anchorKeyCounts[1] = [squareKey(sq), count];\r\n            anchorKeyCounts.sort((a, b) => a[1] - b[1]);\r\n        }\r\n    });\r\n\r\n    if (anchorKeyCounts.length < 2) {\r\n        return {\r\n            anchorSquareKeys: [],\r\n            anchorCombosLeft: [],\r\n        };\r\n    }\r\n\r\n    let anchorSquareKeys = [anchorKeyCounts[0][0], anchorKeyCounts[1][0]];\r\n    let combos = generateAnchorCombos(squares, anchorSquareKeys, calculatedSquares);\r\n\r\n    return {\r\n        anchorSquareKeys: anchorSquareKeys,\r\n        anchorCombosLeft: combos,\r\n    };\r\n}\r\n\r\nconst letterFrequencies = {\r\n    \"A\": 8.2, \"B\": 1.5, \"C\": 2.8, \"D\": 4.3,\r\n    \"E\": 13, \"F\": 2.2, \"G\": 2, \"H\": 6.1,\r\n    \"I\": 7, \"J\": 0.15, \"K\": 0.77, \"L\": 4,\r\n    \"M\": 2.4, \"N\": 6.7, \"O\": 7.5, \"P\": 1.9,\r\n    \"Q\": 0.095, \"R\": 6, \"S\": 6.3, \"T\": 9.1,\r\n    \"U\": 2.8, \"V\": 0.98, \"W\": 2.4, \"X\": 0.15,\r\n    \"Y\": 2, \"Z\": 0.074,\r\n} as any;\r\n\r\nfunction generateAnchorCombos(squares: GridSquare[], anchorSquareKeys: string[], \r\n    calculatedSquares?: Map<string, string[]>): [string, string][] {\r\n    let constraintLetters = anchorSquareKeys\r\n        .map(sqKey => squares.find(sq => squareKey(sq) === sqKey)!)\r\n        .map(sq => sq.content ? [sq.content!] : (calculatedSquares && calculatedSquares.has(squareKey(sq))) ? \r\n        calculatedSquares!.get(squareKey(sq))! : sq.viableLetters || fullAlphabet);\r\n\r\n    let combos = [] as [string, string][];\r\n    let comboScores = new Map<string, number>();\r\n    for (var letter1 of constraintLetters[0]) {\r\n        for (var letter2 of constraintLetters[1]) {\r\n            combos.push([letter1, letter2]);\r\n            comboScores.set(`[${letter1},${letter2}]`, (letterFrequencies[letter1] + letterFrequencies[letter2]) * Math.random());\r\n        }\r\n    }\r\n\r\n    combos.sort((a, b) => {\r\n        return comboScores.get(`[${a[0]},${a[1]}]`)! - comboScores.get(`[${b[0]},${b[1]}]`)!;\r\n    });\r\n\r\n    return combos;\r\n}\r\n\r\nfunction processAnchorCombo(node: FillNode, isForManualFill: boolean) {\r\n    function setIffySquares(iffyWordKey: string) {\r\n        grid = deepClone(node.startGrid) as GridState;\r\n        let iffyWord = grid.words.get(iffyWordKey)!;\r\n        let iffySquares = getSquaresForWord(grid, iffyWord);\r\n        iffySquares.forEach(sq => {\r\n            if (!sq.content)\r\n                sq.viableLetters = fullAlphabet;\r\n        });\r\n    }\r\n\r\n    let grid = node.startGrid;\r\n    let combo = node.anchorCombosLeft.pop()!;\r\n    let iffyWordKey = node.iffyWordKey;\r\n    if (iffyWordKey) setIffySquares(iffyWordKey);\r\n\r\n    let fillWordKey = wordKey(node.fillWord!);\r\n    let wordSquares = getSquaresForWord(grid, node.fillWord!);\r\n    let patternWithAnchor = getLettersFromSquares(wordSquares);\r\n    node.anchorSquareKeys.forEach((sqKey, i) => {\r\n        patternWithAnchor = insertLetterIntoPattern(patternWithAnchor, combo[i], wordSquares, sqKey);\r\n    });\r\n    if (isForManualFill && isWordFull(wordSquares)) {\r\n        node.entryCandidates = [];\r\n        node.entryCandidates.push({\r\n            word: patternWithAnchor,\r\n            score: 1,\r\n            isViable: true,\r\n            hasBeenChained: false,\r\n            wasChainFailure: false,\r\n            crossScore: 0,\r\n            minCrossScore: 0,\r\n        } as EntryCandidate);\r\n        return;\r\n    }\r\n\r\n    let entries = getFilteredEntries(wordSquares, patternWithAnchor, undefined, grid.usedWords);\r\n    if (entries.length === 0 && !isForManualFill && !iffyWordKey && Globals.maxIffyLength! >= wordSquares.length) {\r\n        node.iffyWordKey = fillWordKey;\r\n        node.anchorCombosLeft.push(combo);\r\n        return;\r\n    }\r\n    if (entries.length === 0 && isForManualFill && !iffyWordKey && Globals.maxIffyLength! > 0) {\r\n        let crossKeys = getUnfilledCrosses(grid, node.fillWord!).map(wordKey);\r\n        for (let ck of crossKeys) {\r\n            let cross = grid.words.get(ck)!;\r\n            if (wordLength(cross) > Globals.maxIffyLength!) return;\r\n            node.iffyWordKey = ck;\r\n            node.anchorCombosLeft.push(combo);\r\n            return;\r\n        }\r\n    }\r\n\r\n    let maxFilteredEntryCount = entries.length > 0 ? 100_000 / entries.length : 1;\r\n    entries.forEach(entry => {\r\n        let success = processEntry(entry, maxFilteredEntryCount, iffyWordKey);\r\n\r\n        if (!success && !node.iffyWordKey && Globals.maxIffyLength! > 0) {\r\n            let crossKeys = getUnfilledCrosses(grid, node.fillWord!).map(wordKey);\r\n            let crossCrossKeys = new Map<string, boolean>();\r\n            crossKeys.forEach(ck => {\r\n                let cross = grid.words.get(ck)!;\r\n                getUnfilledCrosses(grid, cross).forEach(cc => {\r\n                    if (wordKey(cc) !== fillWordKey)\r\n                        crossCrossKeys.set(wordKey(cc), true);\r\n                });\r\n                if (wordLength(cross) > Globals.maxIffyLength!) return;\r\n                setIffySquares(ck);\r\n                processEntry(entry, maxFilteredEntryCount, ck);\r\n            });\r\n            crossCrossKeys.forEach((_, cck) => {\r\n                let cc = grid.words.get(cck)!;\r\n                if (wordLength(cc) > Globals.maxIffyLength!) return;\r\n                setIffySquares(cck);\r\n                processEntry(entry, maxFilteredEntryCount, cck);\r\n            });\r\n        }\r\n    });\r\n\r\n    node.entryCandidates.forEach(ec => {\r\n        ec.score = calculateEntryCandidateScore(node, ec);\r\n    });\r\n\r\n    function processEntry(entry: string, maxCount: number, iffyWordKey?: string): boolean {\r\n        let isViable = true;\r\n        let distillIndex = 1;\r\n        let calculatedSquares = new Map<string, string[]>();\r\n        let crossScore = 0;\r\n        let minCrossScore = 1e8;\r\n        let usedWords = deepClone(grid.usedWords) as Map<string, boolean>;\r\n        usedWords.set(entry, true);\r\n        let batchKeys = new Map<string, boolean>();\r\n        batchKeys.set(fillWordKey, true);\r\n        let filledCrosses = new Map<string, boolean>();\r\n        let filteredEntriesCount = 0;\r\n        \r\n        while(true) {\r\n            let foundCountReduction = false;\r\n            let nextBatchKeys = new Map<string, boolean>();\r\n    \r\n            // eslint-disable-next-line\r\n            batchKeys.forEach((_, wKey) => {\r\n                if (!isViable) return;\r\n                if (distillIndex > 1 && filteredEntriesCount > maxCount) return;\r\n                if (wKey === iffyWordKey) return;\r\n\r\n                let word = grid.words.get(wKey)!;\r\n                let wordSquares = getSquaresForWord(grid, word);\r\n                if (distillIndex === 1) {\r\n                    wordSquares.forEach((sq, i) => {\r\n                        calculatedSquares.set(squareKey(sq), [entry[i]]);\r\n                    });\r\n                }\r\n\r\n                let crosses = getAllCrosses(grid, word);\r\n                crosses.forEach(cross => {\r\n                    if (!isViable) return;\r\n                    let crossKey = wordKey(cross);\r\n                    if (nextBatchKeys.has(crossKey)) return;\r\n                    if (crossKey === iffyWordKey) return;\r\n                    if (crossKey === fillWordKey || filledCrosses.has(crossKey)) return;\r\n\r\n                    let crossSquares = getSquaresForWord(grid, cross);\r\n                    if(isWordFull(crossSquares)) return;\r\n                    let crossPattern = getLettersFromSquares(crossSquares);\r\n                    let filteredEntries = [] as string[];\r\n                    let anchorInfo = populateFillWordAnchors(crossSquares, calculatedSquares);\r\n                    if (anchorInfo.anchorCombosLeft.length > 20) {\r\n                        filteredEntriesCount += 500;\r\n                        crossScore += 300;\r\n                        if (300 < minCrossScore) minCrossScore = 300;\r\n                        return;\r\n                    }\r\n\r\n                    anchorInfo.anchorCombosLeft.forEach(combo => {\r\n                        let newPattern = crossPattern;\r\n                        anchorInfo.anchorSquareKeys.forEach((sqKey, i) => {\r\n                            newPattern = insertLetterIntoPattern(newPattern, combo[i], crossSquares, sqKey);\r\n                        });\r\n                        filteredEntries.push(...getFilteredEntries(crossSquares, newPattern, calculatedSquares, usedWords));\r\n                        if (distillIndex === 1 && anchorInfo.anchorCombosLeft.length === 1 && !newPattern.includes(\"-\")) {\r\n                            usedWords.set(newPattern, true);\r\n                            filledCrosses.set(crossKey, true);\r\n                        }\r\n                    });\r\n        \r\n                    if (filteredEntries.length === 0) {\r\n                        isViable = false;\r\n                        return;\r\n                    }\r\n                    filteredEntriesCount += filteredEntries.length;\r\n\r\n                    if (distillIndex === 1) {\r\n                        let score = sum(filteredEntries.map(fe => getWordScore(fe)));\r\n                        crossScore += score;\r\n                        if (score < minCrossScore) minCrossScore = score;\r\n                    }\r\n        \r\n                    crossSquares.forEach((sq, i) => {\r\n                        let newMatrix = Array<boolean>(26).fill(false);\r\n                        filteredEntries.forEach(entry => {\r\n                            newMatrix[entry[i].charCodeAt(0) - 65] = true;\r\n                        });\r\n                        let letters = letterMatrixToLetterList(newMatrix);\r\n\r\n                        let existingCounts = calculatedSquares.get(squareKey(sq))!;\r\n                        if (!existingCounts || existingCounts.length > letters.length)\r\n                            foundCountReduction = true;\r\n\r\n                        calculatedSquares.set(squareKey(sq), letters);\r\n                    });\r\n\r\n                    nextBatchKeys.set(crossKey, true);\r\n                });\r\n            });\r\n\r\n            if (!foundCountReduction) break;\r\n            if (!isViable) break;\r\n\r\n            batchKeys = nextBatchKeys;\r\n            distillIndex++;\r\n        }\r\n\r\n        if (!isViable) return false;\r\n\r\n        if (crossScore > node.topCrossScore) node.topCrossScore = crossScore;\r\n        if (minCrossScore > node.topMinCrossScore) node.topMinCrossScore = minCrossScore;\r\n\r\n        let iffyEntry = undefined as string | undefined;\r\n        if (iffyWordKey) {\r\n            let iffyWord = grid.words.get(iffyWordKey)!;\r\n            let iffySquares = getSquaresForWord(grid, iffyWord);\r\n            let pattern = getLettersFromSquares(iffySquares);\r\n            iffySquares.forEach((isq, idx) => {\r\n                let calSq = calculatedSquares.get(squareKey(isq));\r\n                if (!isq.content && calSq && calSq.length === 1)\r\n                    pattern = pattern.substring(0, idx) + calSq[0] + pattern.substring(idx+1);\r\n            });\r\n            iffyEntry = pattern;\r\n        }\r\n\r\n        if (iffyEntry && usedWords.has(iffyEntry)) return false;\r\n\r\n        node.entryCandidates.push({\r\n            word: entry,\r\n            score: -1,\r\n            isViable: isViable,\r\n            hasBeenChained: false,\r\n            wasChainFailure: false,\r\n            iffyEntry: iffyEntry,\r\n            iffyWordKey: iffyWordKey,\r\n            crossScore: crossScore,\r\n            minCrossScore: minCrossScore,\r\n        } as EntryCandidate);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\nfunction getFilteredEntries(squares: GridSquare[], anchorPattern: string, calculatedSquares?: Map<string, string[]>,\r\n    usedWords?: Map<string, boolean>): string[] {\r\n    let entries = [] as string[];\r\n    broadenAnchorPatterns(squares, anchorPattern, calculatedSquares).forEach(pattern => {\r\n        entries.push(...queryIndexedWordList(pattern));\r\n    });\r\n\r\n    let filteredEntries = entries.filter(entry => {\r\n        if (usedWords && usedWords.has(entry)) return false;\r\n\r\n        for (let i = 0; i < squares.length; i++) {\r\n            let sq = squares[i];\r\n            let sqKey = squareKey(sq);\r\n            \r\n            if (calculatedSquares && calculatedSquares.has(sqKey) && !calculatedSquares.get(sqKey)!.includes(entry[i])) {\r\n                return false;\r\n            }\r\n            else if (sq.viableLetters && !sq.viableLetters.includes(entry[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        \r\n        return true;\r\n    });\r\n\r\n    return filteredEntries;\r\n}\r\n\r\nfunction broadenAnchorPatterns(squares: GridSquare[], anchorPattern: string, calculatedSquares?: Map<string, string[]>): string[] {\r\n    let constraintCounts = squares.map((sq, i) => {\r\n        if (anchorPattern[i] !== \"-\") return [i, [anchorPattern[i]]] as [number, string[]];\r\n        if (calculatedSquares && calculatedSquares.has(squareKey(sq))) {\r\n            return [i, calculatedSquares.get(squareKey(sq))!] as [number, string[]];\r\n        }\r\n        return [i, sq.viableLetters || fullAlphabet] as [number, string[]];\r\n    })\r\n    .filter(x => x[1].length > 0).sort((a, b) => b[1].length - a[1].length);\r\n\r\n    let curPatterns = [anchorPattern];\r\n    while(constraintCounts.length > 0 && curPatterns.length < 12) {\r\n        let lowestCount = constraintCounts.pop()!;\r\n        if (lowestCount[1].length >= 6) \r\n            return curPatterns;\r\n\r\n        let index = lowestCount[0];\r\n        let viableLetters = lowestCount[1];\r\n        let newCurPatterns = [] as string[];\r\n        // eslint-disable-next-line\r\n        viableLetters.forEach(ltr => {\r\n            curPatterns.forEach(pattern => {\r\n                newCurPatterns.push(pattern.substring(0, index) + ltr + pattern.substring(index+1));\r\n            });\r\n        });\r\n        curPatterns = newCurPatterns;\r\n    }\r\n\r\n    return curPatterns;\r\n}\r\n\r\nfunction calculateEntryCandidateScore(node: FillNode, ec: EntryCandidate): number {\r\n    let wordScore = getWordScore(ec.word);\r\n    let crossScore = node.topCrossScore > 0 ? ec.crossScore / node.topCrossScore : 1;\r\n    let minCrossScore = node.topMinCrossScore > 0 ? ec.minCrossScore / node.topMinCrossScore : 1;\r\n    let ret = (crossScore + minCrossScore) * wordScore * (ec.iffyWordKey ? 1 : 100);\r\n    return ret;\r\n}\r\n\r\nfunction insertLetterIntoPattern(pattern: string, newLetter: string, squares: GridSquare[], sqKey: string): string {\r\n    let i = squares.findIndex(sq => squareKey(sq) === sqKey);\r\n    return pattern.substring(0, i) + newLetter + pattern.substring(i+1);\r\n}\r\n","import { GridSquare } from \"../models/GridSquare\";\r\nimport { GridState } from \"../models/GridState\";\r\nimport { GridWord } from \"../models/GridWord\";\r\nimport { SquareType } from \"../models/SquareType\";\r\nimport { WordDirection } from \"../models/WordDirection\";\r\nimport Globals from './windowService';\r\nimport { Puzzle } from \"../models/Puzzle\";\r\nimport { getLettersFromSquares } from \"./grid\";\r\nimport { ContentType } from \"../models/ContentType\";\r\nimport { Section } from \"../models/Section\";\r\nimport { SectionCandidate } from \"../models/SectionCandidate\";\r\nimport { generateGridSections } from \"./section\";\r\n\r\nexport const fullAlphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".split(\"\");\r\n\r\nexport function average(arr: number[]): number {\r\n    return arr.reduce((a,b) => a + b, 0) / arr.length;\r\n}\r\n\r\nexport function sum(arr: number[]): number {\r\n    return arr.reduce((a,b) => a + b, 0);\r\n}\r\n\r\n// https://stackoverflow.com/questions/38416020/deep-copy-in-es6-using-the-spread-syntax\r\nexport function deepClone(obj: any): any {\r\n    if(typeof obj !== 'object' || obj === null) {\r\n        return obj;\r\n    }\r\n\r\n    if(obj instanceof Date) {\r\n        return new Date(obj.getTime());\r\n    }\r\n\r\n    if(obj instanceof Map) {\r\n        return new Map(Array.from(obj.entries()));\r\n    }\r\n\r\n    if(obj instanceof Array) {\r\n        return obj.reduce((arr, item, i) => {\r\n            arr[i] = deepClone(item);\r\n            return arr;\r\n        }, []);\r\n    }\r\n\r\n    if(obj instanceof Object) {\r\n        return Object.keys(obj).reduce((newObj: any, key) => {\r\n            newObj[key] = deepClone(obj[key]);\r\n            return newObj;\r\n        }, {})\r\n    }\r\n}\r\n\r\nexport function compareTuples(first: [number, number], second: [number, number]): boolean {\r\n    return first[0] === second[0] && first[1] === second[1];\r\n}\r\n\r\nexport function isBlackSquare(sq: GridSquare): boolean {\r\n    return sq.type === SquareType.Black;\r\n}\r\n\r\nexport function otherDir(dir: WordDirection): WordDirection {\r\n    return dir === WordDirection.Across ? WordDirection.Down : WordDirection.Across;\r\n}\r\n\r\nexport function getSquaresForWord(grid: GridState, word: GridWord): GridSquare[] {\r\n    let row = word.start[0];\r\n    let col = word.start[1];\r\n    let squares = [grid.squares[row][col]];\r\n    while (!compareTuples([row, col], word.end)) {\r\n        row = word.direction === WordDirection.Across ? row : row+1;\r\n        col = word.direction === WordDirection.Across ? col+1 : col;\r\n        squares.push(grid.squares[row][col]);\r\n    }\r\n\r\n    return squares;\r\n}\r\n\r\nexport function getWordAtSquare(grid: GridState, row: number, col: number, dir: WordDirection): GridWord | undefined {\r\n    let ret = undefined as GridWord | undefined;\r\n\r\n    grid.words.forEach((word, _) => {\r\n        if (dir === WordDirection.Across && word.direction === dir && word.start[0] === row &&\r\n            word.start[1] <= col && word.end[1] >= col)\r\n            ret = word;\r\n        if (dir === WordDirection.Down && word.direction === dir && word.start[1] === col &&\r\n            word.start[0] <= row && word.end[0] >= row)\r\n            ret = word;\r\n    });\r\n\r\n    return ret;\r\n}\r\n\r\nexport function newWord(): GridWord {\r\n    return {\r\n        number: undefined,\r\n        direction: WordDirection.Across,\r\n        start: [-1, -1],\r\n        end: [-1, -1],\r\n    }\r\n}\r\n\r\nexport function doesWordContainSquare(word: GridWord, row: number, col: number): boolean {\r\n    if (word.direction === WordDirection.Across) {\r\n        return word.start[0] === row && word.start[1] <= col && word.end[1] >= col;\r\n    }\r\n    else {\r\n        return word.start[1] === col && word.start[0] <= row && word.end[0] >= row;\r\n    }\r\n}\r\n\r\nexport function isWordEmpty(squares: GridSquare[]): boolean {\r\n    return !squares.find(x => !isBlackSquare(x) && x.content);\r\n}\r\n\r\nexport function isWordFull(squares: GridSquare[]): boolean {\r\n    return !squares.find(x => !isBlackSquare(x) && !x.content);\r\n}\r\n\r\nexport function shuffleArray(array: any[]) {\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1));\r\n        [array[i], array[j]] = [array[j], array[i]];\r\n    }\r\n}\r\n\r\nexport function forAllGridSquares(grid: GridState, func: (sq: GridSquare) => void) {\r\n    grid.squares.forEach(row => {\r\n        row.forEach(sq => {\r\n            func(sq);\r\n        });\r\n    });\r\n}\r\n\r\nexport function wordLength(word: GridWord): number {\r\n    if (word.direction === WordDirection.Across)\r\n        return word.end[1] - word.start[1] + 1;\r\n    else\r\n        return word.end[0] - word.start[0] + 1;\r\n}\r\n\r\nexport function newPuzzle(): Puzzle {\r\n    return {\r\n        title: \"\",\r\n        author: \"\",\r\n        copyright: \"\",\r\n        clues: new Map<string, string>(),\r\n        notes: \"\",\r\n    } as Puzzle;    \r\n}\r\n\r\nexport function wordKey(word: GridWord): string {\r\n    return `[${word.start[0]},${word.start[1]},${word.direction === WordDirection.Across ? \"A\" : \"D\"}]`;\r\n}\r\n\r\nexport function squareKey(sq: GridSquare | undefined): string {\r\n    return sq ? `[${sq.row},${sq.col}]` : \"\";\r\n}\r\n\r\nexport function getGrid(): GridState {\r\n    return Globals.activeGrid!;\r\n}\r\n\r\nexport function getSection(): Section {\r\n    return Globals.sections!.get(Globals.activeSectionId!)!;\r\n}\r\n\r\nexport function getSelectedWord(): GridWord | undefined {\r\n    let grid = getGrid();\r\n    if (!Globals.selectedWordKey) return undefined;\r\n    return grid.words.get(Globals.selectedWordKey);\r\n}\r\n\r\nexport function mapKeys<TKey, TVal>(map: Map<TKey, TVal>): TKey[] {\r\n    return Array.from(map.keys()) || [];\r\n}\r\n\r\nexport function mapValues<TKey, TVal>(map: Map<TKey, TVal>): TVal[] {\r\n    return Array.from(map.values()) || [];\r\n}\r\n\r\nexport function isUserFilled(sq: GridSquare): boolean {\r\n    return sq.contentType === ContentType.User || sq.contentType === ContentType.ChosenWord \r\n        || sq.contentType === ContentType.ChosenSection;\r\n}\r\n\r\nexport function isUserOrWordFilled(sq: GridSquare): boolean {\r\n    return sq.contentType === ContentType.User || sq.contentType === ContentType.ChosenWord;\r\n}\r\n\r\nexport function isAcross(word: GridWord): boolean {\r\n    return word.direction === WordDirection.Across;\r\n}\r\n\r\nexport function getSquareAtKey(grid: GridState, squareKey: string): GridSquare {\r\n    let tokens = squareKey.substring(1, squareKey.length - 1).split(\",\");\r\n    return grid.squares[+tokens[0]][+tokens[1]];\r\n}\r\n\r\nexport function isPartOfIffyWord(sq: GridSquare): boolean {\r\n    if (!sq.viableLetters) return false;\r\n    return sq.viableLetters.length === 0;\r\n}\r\n\r\n// https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\r\nexport function shuffle(array: any[]) {\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1));\r\n        [array[i], array[j]] = [array[j], array[i]];\r\n    }\r\n}\r\n\r\nexport function getEntryAtWordKey(grid: GridState, wordKey: string): string {\r\n    return getLettersFromSquares(getSquaresForWord(grid, grid.words.get(wordKey)!));\r\n}\r\n\r\nexport function getSectionCandidatesFromKeys(keys: string[]): SectionCandidate[] {\r\n    return keys\r\n        .map(sck => mapValues(Globals.sections!).find(sec => sec.candidates.has(sck))?.candidates.get(sck))\r\n        .filter(sck => sck !== undefined)\r\n        .map(sck => sck!);\r\n}\r\n\r\nexport function constraintLetterCount(sq: GridSquare): number {\r\n    if (!sq.viableLetters) return 26;\r\n\r\n    return sq.viableLetters.length;\r\n}\r\n\r\nexport function isPatternFull(pattern: string): boolean {\r\n    return !pattern.includes(\"-\");\r\n}\r\n\r\nexport function getUserFilledSections(grid: GridState): Section[] {\r\n    let sectionCandidates = getSectionCandidatesFromKeys(mapKeys(grid.userFilledSectionCandidates));\r\n    return sectionCandidates.map(sc => Globals.sections!.get(sc.sectionId)!);\r\n}\r\n\r\nexport function getUserFilledSectionCandidates(grid: GridState): SectionCandidate[] {\r\n    return getSectionCandidatesFromKeys(mapKeys(grid.userFilledSectionCandidates));\r\n}\r\n\r\nexport function initializeSessionGlobals() {\r\n    let grid = getGrid();\r\n    Globals.sections = generateGridSections(grid);\r\n    Globals.activeSectionId = 0;\r\n    Globals.hoverSectionId = undefined;\r\n    Globals.selectedSectionIds = new Map<number, boolean>();\r\n    Globals.selectedSectionIds.set(0, true);\r\n    Globals.selectedSectionCandidateKeys = new Map<number, string>();\r\n}\r\n\r\nexport function letterMatrixToLetterList(matrix: boolean[]): string[] {\r\n    return matrix.map((x, i) => x ? String.fromCharCode(i + 65) : \"\").filter(x => x);\r\n}\r\n\r\nexport function letterListToLetterMatrix(list: string[]): boolean[] {\r\n    let matrix = Array<boolean>(26).fill(false);\r\n    list.forEach(ltr => {\r\n        matrix[ltr.charCodeAt(0)] = true;\r\n    });\r\n    return matrix;\r\n}\r\n","import { ContentType } from \"../models/ContentType\";\r\nimport { FillNode } from \"../models/FillNode\";\r\nimport { GridSquare } from \"../models/GridSquare\";\r\nimport { GridState } from \"../models/GridState\";\r\nimport { GridWord } from \"../models/GridWord\";\r\nimport { Section } from \"../models/Section\";\r\nimport { SectionCandidate } from \"../models/SectionCandidate\";\r\nimport { WordDirection } from \"../models/WordDirection\";\r\nimport { getAllCrosses, getWordScore } from \"./fill\";\r\nimport { generateConstraintInfoForSquares, getLettersFromSquares } from \"./grid\";\r\nimport { forAllGridSquares, getEntryAtWordKey, getGrid, getSquaresForWord, getWordAtSquare, getSquareAtKey, isAcross, \r\n    isBlackSquare, mapKeys, squareKey, wordKey, wordLength, mapValues, isUserOrWordFilled, deepClone } from \"./util\";\r\nimport Globals from './windowService';\r\n\r\nexport function updateSectionFilters() {\r\n    let sections = Globals.sections!;\r\n    let grid = getGrid();\r\n    sections.forEach(sec => {\r\n        sec.candidates.forEach((can, _) => {\r\n            let sqKeys = mapKeys(sec.squares);\r\n            can.isFilteredOut = false;\r\n            for (let sqKey of sqKeys) {\r\n                let gridSq = getSquareAtKey(grid, sqKey);\r\n                let canSq = getSquareAtKey(can.grid, sqKey);\r\n                if (isUserOrWordFilled(gridSq) && canSq.content !== gridSq.content)\r\n                    can.isFilteredOut = true;\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\nexport function getSectionString(grid: GridState, section: Section): string {\r\n    let ret = [] as string[];\r\n    mapKeys(section.squares).sort().forEach(sqKey => {\r\n        let sq = getSquareAtKey(grid, sqKey);\r\n        let content = sq.content;\r\n        ret.push(content ? content! : \"-\");\r\n    });\r\n    return ret.join(\"\");\r\n}\r\n\r\n// returns whether it was a success\r\nexport function insertSectionCandidateIntoGrid(grid: GridState, candidate: SectionCandidate, contentType?: ContentType): boolean {\r\n    if (contentType === undefined) contentType = ContentType.ChosenSection;\r\n    let newGrid = deepClone(grid) as GridState;\r\n    let section = Globals.sections!.get(candidate.sectionId)!;\r\n    let foundDiscrepancy = false;\r\n    section.squares.forEach((_, sqKey) => {\r\n        let sq = getSquareAtKey(newGrid, sqKey);\r\n        let candidateSq = getSquareAtKey(candidate.grid, sqKey);\r\n        if (isUserOrWordFilled(sq) && sq.content! !== candidateSq.content!)\r\n            foundDiscrepancy = true;\r\n        sq.content = candidateSq.content;\r\n        sq.viableLetters = [sq.content!];\r\n        if (!isUserOrWordFilled(sq)) {\r\n            sq.contentType = [ContentType.HoverChosenSection, ContentType.Autofill].includes(contentType!) ? \r\n                ContentType.Autofill : ContentType.ChosenSection;\r\n        }\r\n    });\r\n    if (foundDiscrepancy) return false;\r\n    else {\r\n        forAllGridSquares(newGrid, newSq => {\r\n            grid.squares[newSq.row][newSq.col] = newSq;\r\n        });\r\n    }\r\n\r\n    section.words.forEach((_, key) => {\r\n        let word = grid.words.get(key)!;\r\n        let squares = getSquaresForWord(grid, word);\r\n        grid.usedWords.set(getLettersFromSquares(squares), true);\r\n    });\r\n\r\n    section.neighboringCrosses.forEach((_, key) => {\r\n        let word = grid.words.get(key)!;\r\n        let squares = getSquaresForWord(grid, word);\r\n        generateConstraintInfoForSquares(squares);\r\n    });\r\n\r\n    grid.userFilledSectionCandidates.set(sectionCandidateKey(section, grid), true);\r\n    return true;\r\n}\r\n\r\nexport function generateGridSections(grid: GridState): Map<number, Section> {\r\n    function iterateSection(section: Section, grid: GridState, sq: GridSquare, usedSquares: Map<string, boolean>) {\r\n        section.openSquareCount++;\r\n        usedSquares.set(squareKey(sq), true);\r\n\r\n        getNeighboringSquares(grid, sq).forEach(neighbor => {\r\n            if (!usedSquares.has(squareKey(neighbor)) && isOpenSquare(grid, neighbor)) {\r\n                iterateSection(section, grid, neighbor, usedSquares);\r\n            }\r\n\r\n            [WordDirection.Across, WordDirection.Down].forEach(dir => {\r\n                let word = getWordAtSquare(grid, neighbor.row, neighbor.col, dir)!;\r\n                if (word !== undefined && !section.words.has(wordKey(word))) {\r\n                    section.words.set(wordKey(word), true);\r\n                    let squares = getSquaresForWord(grid, word);\r\n                    squares.forEach(wsq => {\r\n                        section.squares.set(squareKey(wsq), true);\r\n                    });\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    let sections = new Map<number, Section>();\r\n    let usedSquares = new Map<string, boolean>();\r\n    let nextSectionId = 1;\r\n\r\n    // add full grid section\r\n    let fullSection = makeNewSection(0);\r\n    forAllGridSquares(grid, sq => {\r\n        if (!isBlackSquare(sq)) fullSection.squares.set(squareKey(sq), true);\r\n    });\r\n    grid.words.forEach(w => {\r\n        fullSection.words.set(wordKey(w), true);\r\n    });\r\n    sections.set(0, fullSection);\r\n\r\n    // populate sections\r\n    forAllGridSquares(grid, sq => {\r\n        if (!usedSquares.has(squareKey(sq)) && isOpenSquare(grid, sq)) {\r\n            let newSection = makeNewSection(nextSectionId);\r\n            iterateSection(newSection, grid, sq, usedSquares);\r\n            if (newSection.openSquareCount === 1) return;\r\n            sections.set(newSection.id, newSection);\r\n            nextSectionId++;\r\n        }\r\n    });\r\n    if (sections.size === 2) sections.delete(1);\r\n\r\n    // populate stackWords\r\n    sections.forEach(section => {\r\n        section.stackWords = new Map<string, boolean>();\r\n\r\n        section.words.forEach((_, key) => {\r\n            if (section.stackWords.has(key)) return;\r\n\r\n            let word = grid.words.get(key)!;\r\n            let stackedNeighbors = mapKeys(section.words).filter(otherKey => {\r\n                if (otherKey === key) return false;\r\n\r\n                let otherWord = grid.words.get(otherKey)!;\r\n                if (isAcross(word) && isAcross(otherWord) && Math.abs(word.start[0] - otherWord.start[0]) === 1) {\r\n                    let intersectionCount = Math.min(word.end[1], otherWord.end[1]) - Math.max(word.start[1], otherWord.start[1]) + 1;\r\n                    return intersectionCount >= 5;\r\n                }\r\n                if (!isAcross(word) && !isAcross(otherWord) && Math.abs(word.start[1] - otherWord.start[1]) === 1) {\r\n                    let intersectionCount = Math.min(word.end[0], otherWord.end[0]) - Math.max(word.start[0], otherWord.start[0]) + 1;\r\n                    return intersectionCount >= 5;\r\n                }\r\n                return false;\r\n            }); \r\n\r\n            if (stackedNeighbors.length > 0) {\r\n                section.stackWords.set(key, true);\r\n                stackedNeighbors.forEach(sk => {\r\n                    section.stackWords.set(sk, true);\r\n                });\r\n            }\r\n        });\r\n    });\r\n\r\n    // populate neighboringCrosses\r\n    sections.forEach(section => {\r\n        section.words.forEach((_, key) => {\r\n            let word = grid.words.get(key)!;\r\n            let crosses = getAllCrosses(grid, word);\r\n            crosses.forEach(cross => {\r\n                let crossKey = wordKey(cross);\r\n                if (!section.words.has(crossKey))\r\n                    section.neighboringCrosses.set(crossKey, true);\r\n            });\r\n        });\r\n    });\r\n\r\n    // calculate word order\r\n    sections.forEach(section => {\r\n        if (section.id === 0) {\r\n            let wordOrder = [] as string[];\r\n            let usedWords = new Map<string, boolean>();\r\n            let orderedSections = calculateSectionOrder(mapValues(sections));\r\n            orderedSections.forEach(id => {\r\n                if (id === 0 && sections.size > 1) return;\r\n                let secOrder = calculateWordOrder(grid, sections.get(id)!);\r\n                wordOrder.push(...secOrder.filter(wk => !usedWords.has(wk)));\r\n                secOrder.forEach(wk => {usedWords.set(wk, true);});\r\n            });\r\n            mapKeys(section.words).filter(wKey => !usedWords.has(wKey)).forEach(wk => {\r\n                wordOrder.push(wk);\r\n            });\r\n            section.wordOrder = wordOrder;\r\n            return;\r\n        }\r\n\r\n        section.wordOrder = calculateWordOrder(grid, section);\r\n    });\r\n\r\n    // calculate connections\r\n    sections.forEach(section => {\r\n        sections.forEach((sec, id) => {\r\n            if (id === section.id) return;\r\n            if (mapKeys(sec.words).find(wk => section.words.has(wk)))\r\n                section.connections.set(id, true);\r\n        });\r\n    });\r\n\r\n    return sections;\r\n}\r\n\r\nexport function calculateSectionOrder(sections: Section[]): number[] {\r\n    return sections.sort((a, b) => {\r\n        if (a.id === 0) return -1;\r\n        if (b.id === 0) return 1;\r\n        if (a.connections.size !== b.connections.size) return b.connections.size - a.connections.size;\r\n        return b.squares.size - a.squares.size;\r\n    }).map(sec => sec.id);\r\n}\r\n\r\nfunction calculateWordOrder(grid: GridState, section: Section): string[] {\r\n    function wordsSort(a: GridWord, b: GridWord): number {\r\n        if (wordLength(a) !== wordLength(b)) return wordLength(b) - wordLength(a);\r\n        return a.direction === WordDirection.Across ? a.start[0] - b.start[0] : a.start[1] - b.start[1];\r\n    }\r\n\r\n    function iterateWordGroup(group: GridWord[]) {\r\n        if (group.length === 0) return;\r\n        if (group.length === 1) {\r\n            wordOrder.push(wordKey(group[0]));\r\n            usedWords.set(wordKey(group[0]), true);\r\n            return;\r\n        }\r\n\r\n        let centerIndex = Math.floor((rowOrCol(group[group.length-1]) - rowOrCol(group[0])) / 2);\r\n        wordOrder.push(wordKey(group[centerIndex]));\r\n        usedWords.set(wordKey(group[centerIndex]), true);\r\n        iterateWordGroup(group.slice(0, centerIndex));\r\n        iterateWordGroup(group.slice(centerIndex + 1));\r\n    }\r\n\r\n    let wordOrder = [] as string[];\r\n    let usedWords = new Map<string, boolean>();\r\n\r\n    // stack words\r\n    if (section.stackWords.size > 0) {\r\n        let acrossSortedStackWords = mapKeys(section.stackWords).map(wKey => grid.words.get(wKey)!)\r\n            .filter(word => word.direction === WordDirection.Across).sort(wordsSort);\r\n        let downSortedStackWords = mapKeys(section.stackWords).map(wKey => grid.words.get(wKey)!)\r\n            .filter(word => word.direction === WordDirection.Down).sort(wordsSort);\r\n        let longestStack = downSortedStackWords.length === 0 ? acrossSortedStackWords :\r\n            acrossSortedStackWords.length === 0 ? downSortedStackWords :\r\n            wordLength(acrossSortedStackWords[0]) >= wordLength(downSortedStackWords[0]) ? acrossSortedStackWords :\r\n            downSortedStackWords;\r\n        let otherStack = longestStack === acrossSortedStackWords ? downSortedStackWords : acrossSortedStackWords;\r\n        [longestStack, otherStack].forEach(stack => {\r\n            for (let i = 0; i < stack.length; i++) {\r\n                let word = stack[i];\r\n                let length = wordLength(word);\r\n                let curGroup = [word];\r\n                let prevRowOrCol = rowOrCol(word);\r\n                for (let j = i+1; j < stack.length && wordLength(stack[j]) === length; j++) {\r\n                    let newWord = stack[j];\r\n                    let newRowOrCol = rowOrCol(newWord);\r\n                    if (newRowOrCol - prevRowOrCol === 1) {\r\n                        curGroup.push(newWord);\r\n                        prevRowOrCol = newRowOrCol;\r\n                        i++;\r\n                    }\r\n                    else break;\r\n                }\r\n    \r\n                iterateWordGroup(curGroup);\r\n            }\r\n        });\r\n    }\r\n\r\n    // restOfWords\r\n    let remainingWords = mapKeys(section.words).filter(wKey => !usedWords.has(wKey))\r\n        .map(wKey => grid.words.get(wKey)!).sort(wordsSort);\r\n    remainingWords.forEach(word => {\r\n        wordOrder.push(wordKey(word));\r\n    });\r\n\r\n    return wordOrder;\r\n}\r\n\r\nfunction rowOrCol(word: GridWord): number {\r\n    return word.direction === WordDirection.Across ? word.start[0] : word.start[1];\r\n}\r\n\r\nfunction isOpenSquare(grid: GridState, sq: GridSquare): boolean {\r\n    let neighbors = getNeighboringSquares(grid, sq);\r\n    return neighbors.length === 8 && !neighbors.find(n => isBlackSquare(n));\r\n}\r\n\r\nfunction getNeighboringSquares(grid: GridState, sq: GridSquare): GridSquare[] {\r\n    let ret = [] as GridSquare[];\r\n    let nClear = sq.row > 0;\r\n    let sClear = sq.row < grid.height-1;\r\n    let wClear = sq.col > 0;\r\n    let eClear = sq.col < grid.width-1;\r\n\r\n    if (nClear && wClear) ret.push(grid.squares[sq.row-1][sq.col-1]);\r\n    if (nClear) ret.push(grid.squares[sq.row-1][sq.col]);\r\n    if (nClear && eClear) ret.push(grid.squares[sq.row-1][sq.col+1]);\r\n    if (eClear) ret.push(grid.squares[sq.row][sq.col+1]);\r\n    if (sClear && eClear) ret.push(grid.squares[sq.row+1][sq.col+1]);\r\n    if (sClear) ret.push(grid.squares[sq.row+1][sq.col]);\r\n    if (sClear && wClear) ret.push(grid.squares[sq.row+1][sq.col-1]);\r\n    if (wClear) ret.push(grid.squares[sq.row][sq.col-1]);\r\n\r\n    return ret;\r\n}\r\n\r\nexport function newSectionCandidate(node: FillNode, section: Section): SectionCandidate {\r\n    let grid = deepClone(node.endGrid) as GridState;\r\n    return {\r\n        sectionId: section.id,\r\n        grid: grid,\r\n        score: calculateSectionCandidateScore(node, grid, section),\r\n        iffyEntry: node.iffyWordKey ? getEntryAtWordKey(grid, node.iffyWordKey) : undefined,\r\n        isFilteredOut: false,\r\n    } as SectionCandidate;\r\n}\r\n\r\nexport function calculateSectionCandidateScore(node: FillNode, grid: GridState, section: Section): number {\r\n    let total = 0;\r\n    section.words.forEach((_, wordKey) => {\r\n        let word = grid.words.get(wordKey)!;\r\n        let squares = getSquaresForWord(grid, word);\r\n        let str = getLettersFromSquares(squares);\r\n        let score = getWordScore(str);\r\n        total += score;\r\n    });\r\n\r\n    if (!node.iffyWordKey) total *= 10;\r\n    return total / section.words.size;\r\n}\r\n\r\nconst natoAlphabet = {\r\n    \"A\": \"Alfa\",   \"B\": \"Bravo\",   \"C\": \"Charlie\",\r\n    \"D\": \"Delta\",  \"E\": \"Echo\",    \"F\": \"Foxtrot\",\r\n    \"G\": \"Golf\",   \"H\": \"Hotel\",   \"I\": \"India\",\r\n    \"J\": \"Juliett\",\"K\": \"Kilo\",    \"L\": \"Lima\",\r\n    \"M\": \"Mike\",   \"N\": \"November\",\"O\": \"Oscar\",\r\n    \"P\": \"Papa\",   \"Q\": \"Quebec\",  \"R\": \"Romeo\",\r\n    \"S\": \"Sierra\", \"T\": \"Tango\",   \"U\": \"Uniform\",\r\n    \"V\": \"Victor\", \"W\": \"Whiskey\", \"X\": \"X-ray\",\r\n    \"Y\": \"Yankee\", \"Z\": \"Zulu\"\r\n} as any;\r\n\r\nexport function getPhoneticName(n: number): string {\r\n    if (n === 0) return \"Full Grid\";\r\n    return n <= 26 ? natoAlphabet[String.fromCharCode(n+64)] : \"Section \" + n.toString();\r\n}\r\n\r\nexport function sectionCandidateKey(section: Section, grid: GridState): string {\r\n    let keys = mapKeys(section.squares).sort();\r\n    return keys.map(k => getSquareAtKey(grid, k).content!).join(\"\");\r\n}\r\n\r\nexport function makeNewSection(id: number): Section {\r\n    return {\r\n        id: id,\r\n        openSquareCount: 0,\r\n        squares: new Map<string, boolean>(),\r\n        words: new Map<string, boolean>(),\r\n        stackWords: new Map<string, boolean>(),\r\n        wordOrder: [],\r\n        neighboringCrosses: new Map<string, boolean>(),\r\n        candidates: new Map<string, SectionCandidate>(),\r\n        connections: new Map<number, boolean>(),\r\n        comboPermsQueue: [],\r\n        comboPermsUsed: new Map<string, boolean>(),\r\n    } as Section;\r\n}\r\n\r\nexport function getLongestStackWord(section: Section): GridWord {\r\n    function getLongest(wordKeys: string[]): GridWord {\r\n        return wordKeys.map(w => grid.words.get(w)!).sort((a, b) => wordLength(b) - wordLength(a))[0];\r\n    }\r\n\r\n    let grid = getGrid();\r\n    if (section.stackWords.size > 0)\r\n        return getLongest(mapKeys(section.stackWords))\r\n    else\r\n        return getLongest(mapKeys(section.words));\r\n}\r\n\r\nexport function getSelectedSections(): Section[] {\r\n    if (Globals.selectedSectionIds!.size === 0) return [Globals.sections!.get(0)!];\r\n    return mapKeys(Globals.selectedSectionIds!).sort().map(id => Globals.sections!.get(id)!);\r\n}\r\n\r\nexport function getSelectedSectionCandidates(): SectionCandidate[] {\r\n    let ret = [] as SectionCandidate[];\r\n    Globals.sections!.forEach((section, _) => {\r\n        Globals.selectedSectionCandidateKeys!.forEach((scKey, _) => {\r\n            if (section.candidates.has(scKey))\r\n                ret.push(section.candidates.get(scKey)!);\r\n        });\r\n    });\r\n    return ret;\r\n}\r\n\r\nexport function getSelectedSectionCandidatesWithWord(wordKey: string): SectionCandidate[] {\r\n    let ret = [] as SectionCandidate[];\r\n    getSelectedSectionCandidates().forEach(sc => {\r\n        let section = Globals.sections!.get(sc.sectionId)!;\r\n        if (section.words.has(wordKey))\r\n            ret.push(sc);\r\n    });\r\n    return ret;\r\n}\r\n\r\nexport function getSelectedSectionCandidatesWithSquare(squareKey: string): SectionCandidate[] {\r\n    let ret = [] as SectionCandidate[];\r\n    getSelectedSectionCandidates().forEach(sc => {\r\n        let section = Globals.sections!.get(sc.sectionId)!;\r\n        if (section.squares.has(squareKey))\r\n            ret.push(sc);\r\n    });\r\n    return ret;\r\n}\r\n\r\nexport function getSectionsWithSelectedCandidate(): Section[] {\r\n    return getSelectedSectionCandidates().map(sc => getSectionWithCandidate(sc));\r\n}\r\n\r\nexport function getSectionWithCandidate(sc: SectionCandidate): Section {\r\n    return Globals.sections!.get(sc.sectionId)!;\r\n}\r\n\r\nexport function getUnfilteredSectionCandidates(section: Section): SectionCandidate[] {\r\n    return mapValues(section.candidates).filter(sc => !sc.isFilteredOut);\r\n}\r\n\r\nexport function getSectionsWithWord(word: GridWord): Section[] {\r\n    return mapValues(Globals.sections!).filter(sec => sec.id > 0 && sec.words.has(wordKey(word)));\r\n}\r\n","import { ContentType } from \"../models/ContentType\";\r\nimport { FillNode } from \"../models/FillNode\";\r\nimport { GridSquare } from \"../models/GridSquare\";\r\nimport { GridState } from \"../models/GridState\";\r\nimport { getAllCrosses } from \"./fill\";\r\nimport { generateConstraintInfoForSquares, getLettersFromSquares } from \"./grid\";\r\nimport { sectionCandidateKey } from \"./section\";\r\nimport { deepClone, getSectionCandidatesFromKeys, getSquaresForWord, isWordFull, mapKeys } from \"./util\";\r\nimport Globals from './windowService';\r\n\r\nexport function processAndInsertChosenEntry(node: FillNode, contentType?: ContentType) {\r\n    if (contentType === undefined) contentType = ContentType.Autofill;\r\n    if (!node.chosenEntry) return false;\r\n\r\n    let grid = deepClone(node.startGrid) as GridState;\r\n    let word = node.fillWord!;\r\n    let wordSquares = getSquaresForWord(grid, word);\r\n    let crosses = getAllCrosses(grid, word);\r\n\r\n    wordSquares.forEach((sq, i) => {\r\n        sq.content = node.chosenEntry!.word[i];\r\n        if ([ContentType.Autofill, ContentType.ChosenSection, ContentType.HoverChosenWord].includes(sq.contentType))\r\n            sq.contentType = contentType!;\r\n    });\r\n    grid.usedWords.set(getLettersFromSquares(wordSquares), true);\r\n    node.iffyWordKey = node.chosenEntry!.iffyWordKey;\r\n\r\n    if (contentType === ContentType.ChosenWord) {\r\n        removeNonmatchingSectionCandidates(grid, wordSquares, node.chosenEntry!.word);\r\n    }  \r\n\r\n    crosses.forEach(cross => {\r\n        let newSquares = getSquaresForWord(grid, cross);\r\n        generateConstraintInfoForSquares(newSquares);\r\n\r\n        if (isWordFull(newSquares)) {\r\n            grid.usedWords.set(getLettersFromSquares(newSquares), true);\r\n        }\r\n    });\r\n    \r\n    node.endGrid = grid;\r\n}\r\n\r\nfunction removeNonmatchingSectionCandidates(grid: GridState, newSquares: GridSquare[], chosenEntry: string) {\r\n    let sectionCandidates = getSectionCandidatesFromKeys(mapKeys(grid.userFilledSectionCandidates));\r\n    sectionCandidates.forEach(sc => {\r\n        let section = Globals.sections!.get(sc.sectionId)!;\r\n        newSquares.forEach((sq, i) => {\r\n            if (sc.grid.squares[sq.row][sq.col].content !== chosenEntry[i])\r\n                grid.userFilledSectionCandidates.delete(sectionCandidateKey(section, grid));\r\n        });\r\n    });\r\n}\r\n","// https://itnext.io/priority-queue-in-typescript-6ef23116901\r\n\r\n  interface Node<T> {\r\n    key: number\r\n    value: T\r\n  }\r\n\r\n  export interface PriorityQueue<T> {\r\n      isEmpty: () => boolean,\r\n      peek: () => T | null,\r\n      size: () => number,\r\n      insert: (item: T, prio: number) => void,\r\n      pop: () => T | null,\r\n  }\r\n  \r\n  export const priorityQueue = <T>(): PriorityQueue<T> => {\r\n    let heap: Node<T>[] = []\r\n\r\n    const parent = (index: number) => Math.floor((index - 1) / 2)\r\n    const left = (index: number) => 2 * index + 1\r\n    const right = (index: number) =>  2 * index + 2\r\n    const hasLeft = (index: number) => left(index) < heap.length\r\n    const hasRight = (index: number) => right(index) < heap.length\r\n\r\n    const swap = (a: number, b: number) => {\r\n        let temp = heap[a];\r\n        heap[a] = heap[b];\r\n        heap[b] = temp;\r\n    }\r\n  \r\n    return {\r\n      \r\n      isEmpty: () => heap.length === 0,\r\n  \r\n      peek: () => heap.length === 0 ? null : heap[0].value,\r\n      \r\n      size: () => heap.length,\r\n\r\n      insert: (item, prio) => {\r\n        heap.push({key: prio, value: item})\r\n  \r\n        let i = heap.length -1\r\n        while(i > 0) {\r\n          const p = parent(i)\r\n          if(heap[p].key > heap[i].key) break\r\n          const tmp = heap[i]\r\n          heap[i] = heap[p]\r\n          heap[p] = tmp\r\n          i = p\r\n        }\r\n      },\r\n\r\n      pop: () => {\r\n        if(heap.length === 0) return null\r\n        \r\n        swap(0, heap.length - 1)\r\n        const item = heap.pop()\r\n  \r\n        let current = 0\r\n        while(hasLeft(current)) {\r\n          let largerChild = left(current)\r\n          if(hasRight(current) && heap[right(current)].key > heap[left(current)].key) \r\n            largerChild = right(current)\r\n  \r\n          if(heap[largerChild].key < heap[current].key) break\r\n  \r\n          swap(current, largerChild)\r\n          current = largerChild\r\n        }\r\n  \r\n        return item!.value\r\n      }\r\n    }\r\n  }\r\n  ","export enum FillStatus {\r\n    NoWordList,\r\n    Ready,\r\n    Running,\r\n    Complete,\r\n}\r\n","import { ContentType } from '../models/ContentType';\r\nimport { EntryCandidate } from '../models/EntryCandidate';\r\nimport { FillNode } from '../models/FillNode';\r\nimport { GridSquare } from '../models/GridSquare';\r\nimport { GridState } from '../models/GridState';\r\nimport { GridWord } from '../models/GridWord';\r\nimport { QualityClass } from '../models/QualityClass';\r\nimport { Section } from '../models/Section';\r\nimport { WordDirection } from '../models/WordDirection';\r\nimport { populateAndScoreEntryCandidates } from './entryCandidates';\r\nimport { processAndInsertChosenEntry } from './insertEntry';\r\nimport { PriorityQueue, priorityQueue } from './priorityQueue';\r\nimport { getSectionString, getSectionsWithWord, insertSectionCandidateIntoGrid, newSectionCandidate } from './section';\r\nimport { deepClone, getSquaresForWord, mapKeys, isWordFull, \r\n    getWordAtSquare, otherDir, mapValues, getSection, getGrid, wordKey } from './util';\r\nimport Globals from './windowService';\r\n\r\nexport function fillSectionWord(): boolean {\r\n    let section = getSection();\r\n    let fillQueue = section.fillQueue;\r\n    if (!fillQueue) {\r\n        let newFillQueue = priorityQueue<FillNode>();\r\n        populateSeedNodes(newFillQueue);\r\n        fillQueue = newFillQueue;\r\n        section.fillQueue = newFillQueue;\r\n    }\r\n\r\n    let node = fillQueue.peek()!;\r\n    if (!node) {\r\n        populateSeedNodes(fillQueue);\r\n        node = fillQueue.peek()!;\r\n        if (!node) {\r\n            return false;\r\n        }\r\n    }\r\n    while (node.needsNewPriority || node.shouldBeDeleted) {\r\n        node.needsNewPriority = false;\r\n        fillQueue.pop();\r\n        if (!node.shouldBeDeleted) fillQueue.insert(node, calculateNodePriority(node));\r\n        node = fillQueue.peek()!;\r\n        if (!node) return false;\r\n    }\r\n    while (node.isChainNode && node.chainId! !== Globals.curChainId!) {\r\n        fillQueue.pop();\r\n        node = fillQueue.peek()!;\r\n        if (!node) return false;\r\n    }\r\n\r\n    if (!node.isChainNode && Globals.activeGrid !== node.startGrid) {\r\n        Globals.activeGrid = node.startGrid;\r\n        return true;\r\n    }\r\n\r\n    let success = processSectionNode(node, section);\r\n    if (success) {\r\n        let sectionString = getSectionString(node.endGrid, section);\r\n        // is section filled?\r\n        if (!sectionString.includes(\"-\")) {\r\n            let newSecCandidateFound = false;\r\n            if (!section.candidates.has(sectionString)) {\r\n                let newCandidate = newSectionCandidate(node, section);\r\n                section.candidates.set(sectionString, newCandidate);\r\n                Globals.activeGrid = node.endGrid;\r\n                newSecCandidateFound = true;\r\n            }\r\n            \r\n            invalidateChainNode(node, newSecCandidateFound);\r\n            fillQueue.pop();\r\n            return true;\r\n        }\r\n\r\n        Globals.activeGrid = node.endGrid;\r\n        let newNode = makeNewNode(node.endGrid, node.depth + 1, true, node);\r\n        \r\n        if (section.id === 0) {\r\n            let nextFillWord = selectWordToFill(node, getSection());\r\n            let curSections = getSectionsWithWord(node.fillWord!);\r\n            let nextSections = getSectionsWithWord(nextFillWord!);\r\n            if (curSections.length > 0 && !curSections.find(cs => nextSections.find(ns => ns.id === cs.id))) {\r\n                newNode = makeNewNode(node.endGrid, node.depth + 1, false, node, true);\r\n                Globals.curChainId!++;\r\n            }\r\n        }\r\n        \r\n        fillQueue.insert(newNode, calculateNodePriority(newNode));\r\n    }\r\n    else {\r\n        fillQueue.pop();\r\n        if (node.isChainNode) invalidateChainNode(node);\r\n        fillSectionWord();\r\n    }\r\n\r\n    Globals.selectedWordNode = undefined;\r\n    return true;\r\n}\r\n\r\nfunction invalidateChainNode(node: FillNode, newSecCandidateFound?: boolean) {\r\n    if (newSecCandidateFound === undefined) newSecCandidateFound = false;\r\n\r\n    let parent = node.parent!;\r\n    if (!parent) return;\r\n\r\n    let prevCandidate = parent.chosenEntry!;\r\n    if (parent.isChainNode) {\r\n        if (prevCandidate)\r\n            prevCandidate.wasChainFailure = true;\r\n        parent.backtracks++;\r\n    }\r\n    else {\r\n        if (prevCandidate)\r\n            prevCandidate.hasBeenChained = true;\r\n    }\r\n\r\n    parent.chosenEntry = undefined;\r\n    parent.iffyWordKey = parent.parent ? parent.parent.iffyWordKey : undefined;\r\n    parent.endGrid = deepClone(parent.startGrid);\r\n\r\n    if (parent.backtracks >= 3) {\r\n        if (parent.parent && !parent.parent.isChainNode) {\r\n            parent.isChainNode = false;\r\n            parent.needsNewPriority = true;\r\n            Globals.curChainId!++;\r\n        }\r\n            \r\n        invalidateChainNode(parent);\r\n    }\r\n\r\n    if (newSecCandidateFound) {\r\n        if (node.iffyWordKey && node.chainBaseNode!.chainIffyCandidates < 24) {\r\n            node.chainBaseNode!.chainIffyCandidates++;\r\n            return;\r\n        }\r\n        else if (!node.iffyWordKey && node.chainBaseNode!.chainGoodCandidates < 4) {\r\n            node.chainBaseNode!.chainGoodCandidates++;\r\n            return;\r\n        }\r\n        \r\n        node.chainBaseNode!.chainGoodCandidates = 0;\r\n        node.chainBaseNode!.chainIffyCandidates = 0;\r\n\r\n        let curNode = parent;\r\n        while (curNode.parent && (curNode.parent.isChainNode || curNode.parent.isSectionBase)) {\r\n            if (curNode.isSectionBase) curNode.shouldBeDeleted = true;\r\n            curNode = curNode.parent!;\r\n        }\r\n        curNode.isChainNode = false;\r\n        curNode.needsNewPriority = true;\r\n        Globals.curChainId!++;\r\n    }\r\n}\r\n\r\nfunction calculateNodePriority(node: FillNode): number {\r\n    let grid = node.startGrid;\r\n    let wordScore = 0;\r\n    grid.usedWords.forEach((_, word) => {\r\n        wordScore += getWordScore(word);\r\n    });\r\n\r\n    let situationScore: number;\r\n    if (node.isChainNode)\r\n        situationScore = 1e8 + 10000*(node.depth+1);\r\n    else if (node.isSectionBase)\r\n        situationScore = (10000 + node.depth) * 10000;\r\n    else\r\n        situationScore = (10000 - node.depth) * 10000;\r\n\r\n    return wordScore + situationScore;\r\n}\r\n\r\nfunction populateSeedNodes(fillQueue: PriorityQueue<FillNode>) {\r\n    let grid = getGrid();\r\n    let selectedSectionIds = [Globals.activeSectionId!]; //Globals.selectedSectionIds!.size > 0 ? mapKeys(Globals.selectedSectionIds!) : [0];\r\n    let activeSection = getSection();\r\n    let connectionIds = mapKeys(activeSection.connections)\r\n        .filter(id => selectedSectionIds.includes(id) && Globals.sections!.get(id)!.selectedCandidate === undefined\r\n            && Globals.sections!.get(id)!.candidates.size > 0)\r\n        .sort();\r\n    let candidateCounts = connectionIds.map(i => Globals.sections!.get(i)!.candidates.size);\r\n    \r\n    getNewPermutations(candidateCounts, activeSection);\r\n    activeSection.comboPermsQueue.forEach(perm => {\r\n        let node = makeNewNode(grid, 0, false, undefined);\r\n        if (perm[0] === -1) {\r\n            fillQueue.insert(node, calculateNodePriority(node));\r\n            return;\r\n        }\r\n        let wasSuccess = true;\r\n        for (let i = 0; i < perm.length; i++) {\r\n            let sortedCandidates = mapValues(Globals.sections!.get(connectionIds[i])!.candidates)\r\n                .sort((a, b) => b.score - a.score);\r\n            let candidate = sortedCandidates[perm[i]];\r\n            if (!insertSectionCandidateIntoGrid(node.startGrid, candidate, ContentType.Autofill))\r\n                wasSuccess = false;\r\n        }\r\n        if (wasSuccess)\r\n            fillQueue.insert(node, calculateNodePriority(node));\r\n    });\r\n}\r\n\r\nfunction getNewPermutations(candidateCounts: number[], section: Section) {\r\n    function comboKey(perm: number[]): string {\r\n        return \"[\" + perm.map(n => n.toString()).join(\",\") + \"]\";\r\n    }\r\n\r\n    if (section.comboPermsUsed.size > 0 && section.comboPermsQueue.length > 0 && section.comboPermsQueue[0][0] === -1)\r\n        section.comboPermsQueue.shift();\r\n    if (section.comboPermsUsed.size > 0 && section.comboPermsQueue.length === 0) return;\r\n\r\n    if (candidateCounts.length === 0) {\r\n        let defaultCombo = [-1];\r\n        section.comboPermsQueue = [defaultCombo];\r\n        section.comboPermsUsed.set(comboKey(defaultCombo), true);\r\n        return;\r\n    }\r\n\r\n    if (section.comboPermsUsed.size === 0) {\r\n        let allOnes = [] as number[];\r\n        for(let i = 0; i < candidateCounts.length; i++) allOnes.push(1);\r\n        section.comboPermsQueue = [allOnes];\r\n        section.comboPermsUsed.set(comboKey(allOnes), true);\r\n        return;\r\n    }\r\n\r\n    while(true) {\r\n        let perm = section.comboPermsQueue.shift()!;\r\n        if (!perm) break;\r\n        let foundNew = false;\r\n\r\n        for(let i = 0; i < perm.length; i++) {\r\n            if (perm[i] === candidateCounts[i] - 1) continue;\r\n    \r\n            let newPerm = deepClone(perm);\r\n            newPerm[i]++;\r\n            let newPermKey = comboKey(newPerm);\r\n            if (section.comboPermsUsed.has(newPermKey)) continue;\r\n\r\n            section.comboPermsUsed.set(newPermKey, true);\r\n            foundNew = true;\r\n            section.comboPermsQueue.push(newPerm);\r\n        }\r\n\r\n        if (foundNew) break;\r\n    }\r\n}\r\n\r\nexport function processSectionNode(node: FillNode, section: Section): boolean {\r\n    if (!node.fillWord)\r\n        node.fillWord = selectWordToFill(node, section);\r\n\r\n    if (node.anchorSquareKeys.length === 0 || node.anchorCombosLeft.length > 0) {\r\n        let areEligibleCandidates = populateAndScoreEntryCandidates(node, false);\r\n        if (!areEligibleCandidates) return false;\r\n    }\r\n\r\n    let eligibleCandidates = getEligibleCandidates(node);\r\n    if (eligibleCandidates.length > 0) {\r\n        node.chosenEntry = chooseEntryFromCandidates(eligibleCandidates);\r\n        processAndInsertChosenEntry(node);\r\n        return true;\r\n    }\r\n    \r\n    return false;\r\n}\r\n\r\nexport function makeNewNode(grid: GridState, depth: number, isChainNode: boolean, parent: FillNode | undefined, \r\n    isSectionBase?: boolean): FillNode {\r\n    return {\r\n        startGrid: deepClone(grid),\r\n        endGrid: deepClone(grid),\r\n        entryCandidates: [],\r\n        depth: depth,\r\n        isChainNode: isChainNode,\r\n        isSectionBase: !!isSectionBase,\r\n        backtracks: 0,\r\n        parent: parent,\r\n        chainBaseNode: isChainNode ? (parent!.isChainNode ? parent!.chainBaseNode : parent!) : undefined,\r\n        needsNewPriority: false,\r\n        shouldBeDeleted: false,\r\n        anchorSquareKeys: [],\r\n        anchorCombosLeft: [],\r\n        viableLetterCounts: new Map<string, Map<string, number>>(),\r\n        iffyWordKey: parent ? parent.iffyWordKey : undefined,\r\n        chainGoodCandidates: parent ? parent.chainGoodCandidates : 0,\r\n        chainIffyCandidates: parent ? parent.chainIffyCandidates : 0,\r\n        chainId: Globals.curChainId!,\r\n        topCrossScore: 0,\r\n        topMinCrossScore: 0,\r\n    } as FillNode;\r\n}\r\n\r\nfunction selectWordToFill(node: FillNode, section: Section): GridWord | undefined {\r\n    let grid = node.startGrid;\r\n\r\n    for (let key of section.wordOrder) {\r\n        let word = grid.words.get(key)!;\r\n        if (key === section.wordOrder[section.wordOrder.length - 1]) return word;\r\n        let squares = getSquaresForWord(grid, word);\r\n        if (wordKey(word) !== node.iffyWordKey && !isWordFull(squares))\r\n            return word;\r\n    }\r\n\r\n    return undefined;\r\n}\r\n\r\nexport function getPositionOfCross(wordSquares: GridSquare[], crossSquares: GridSquare[], dir: WordDirection): number {\r\n    return dir === WordDirection.Across ? \r\n            wordSquares[0].row - crossSquares[0].row : \r\n            wordSquares[0].col - crossSquares[0].col;\r\n}\r\n\r\nexport function getAllCrosses(grid: GridState, word: GridWord): GridWord[] {\r\n    let squares = getSquaresForWord(grid, word);\r\n    let crosses = squares\r\n        .map(sq => getWordAtSquare(grid, sq.row, sq.col, otherDir(word.direction)))\r\n        .filter(w => w).map(w => w!);\r\n    return crosses.length > 0 ? crosses : [];\r\n}\r\n\r\nexport function getUnfilledCrosses(grid: GridState, word: GridWord): GridWord[] {\r\n    let squares = getSquaresForWord(grid, word);\r\n    let crosses = squares\r\n        .map(sq => getWordAtSquare(grid, sq.row, sq.col, otherDir(word.direction)))\r\n        .filter(w => w && !isWordFull(getSquaresForWord(grid, w)))\r\n        .map(w => w!);\r\n    return crosses.length > 0 ? crosses : [];\r\n}\r\n\r\nexport function getEligibleCandidates(node: FillNode): EntryCandidate[] {\r\n    if (node.isChainNode) {\r\n        return node.entryCandidates.filter(ec => ec.isViable && !ec.wasChainFailure);\r\n    }\r\n    else {\r\n        return node.entryCandidates.filter(ec => ec.isViable && !ec.hasBeenChained);\r\n    }\r\n}\r\n\r\nfunction chooseEntryFromCandidates(candidates: EntryCandidate[]): EntryCandidate {\r\n    let topScore = candidates[0].score!;\r\n    let total = 0;\r\n    candidates.forEach(c => {\r\n        total += Math.pow(c.score / topScore, 4);\r\n    });\r\n\r\n    let roll = Math.random() * total;\r\n    let runningTotal = 0;\r\n    for (let can of candidates) {\r\n        runningTotal += Math.pow(can.score / topScore, 4);\r\n        if (runningTotal >= roll)\r\n            return can;\r\n    }\r\n\r\n    return candidates[0];\r\n}\r\n\r\nexport function getWordScore(word: string): number {\r\n    let qualityClass = Globals.qualityClasses!.get(word);\r\n    if (!qualityClass) return 0;\r\n\r\n    switch(qualityClass) {\r\n        case QualityClass.Lively: return 12;\r\n        case QualityClass.Normal: return 9;\r\n        case QualityClass.Crosswordese: return 3;\r\n        case QualityClass.Iffy: return 1;\r\n    }\r\n}\r\n","import { FillNode } from \"../models/FillNode\";\r\nimport { GridSquare } from \"../models/GridSquare\";\r\nimport { GridState } from \"../models/GridState\";\r\nimport { GridWord } from \"../models/GridWord\";\r\nimport { SquareType } from \"../models/SquareType\";\r\nimport { WordDirection } from \"../models/WordDirection\";\r\nimport Globals from './windowService';\r\nimport { getSquaresForWord, isBlackSquare, newWord, forAllGridSquares, isWordFull, isWordEmpty, getGrid, \r\n    isUserFilled, deepClone, wordKey, getWordAtSquare, getSquareAtKey, otherDir, squareKey, getSection, mapKeys, \r\n    fullAlphabet, letterListToLetterMatrix, letterMatrixToLetterList } from \"./util\";\r\nimport { SymmetryType } from \"../models/SymmetryType\";\r\nimport { makeNewNode } from \"./fill\";\r\nimport { ContentType } from \"../models/ContentType\";\r\nimport { processAndInsertChosenEntry } from \"./insertEntry\";\r\nimport { queryIndexedWordList } from \"./wordList\";\r\nimport { populateAndScoreEntryCandidates, populateNoHeuristicEntryCandidates } from \"./entryCandidates\";\r\nimport { getSectionsWithSelectedCandidate, getSectionWithCandidate, \r\n    getSelectedSectionCandidatesWithSquare } from \"./section\";\r\nimport { FillStatus } from \"../models/FillStatus\";\r\nimport { SectionCandidate } from \"../models/SectionCandidate\";\r\n\r\nexport function populateWords(grid: GridState) {\r\n    function processSquare(grid: GridState, row: number, col: number, dir: WordDirection) {\r\n        let sq = grid.squares[row][col];\r\n\r\n        if (isBlackSquare(sq)) return;\r\n        if (!currentWord.number && !sq.number) return; // unchecked square\r\n\r\n        if (!currentWord.number) {\r\n            currentWord.number = sq.number;\r\n            currentWord.direction = dir;\r\n            currentWord.start = [row, col]; \r\n        }\r\n\r\n        currentWord.end = [row, col];\r\n\r\n        let nextSq = dir === WordDirection.Across ? [row, col+1] : [row+1, col];\r\n        if (nextSq[0] === grid.height || nextSq[1] === grid.width || isBlackSquare(grid.squares[nextSq[0]][nextSq[1]])) {\r\n            if ((dir === WordDirection.Across && currentWord.end[1] - currentWord.start[1] > 0) ||\r\n                (dir === WordDirection.Down && currentWord.end[0] - currentWord.start[0] > 0))\r\n                grid.words.set(wordKey(currentWord), currentWord);\r\n            currentWord = newWord();\r\n        }\r\n    }\r\n\r\n    grid.words = new Map<string, GridWord>();\r\n\r\n    numberizeGrid(grid);\r\n\r\n    let currentWord: GridWord = newWord();\r\n    for (let row = 0; row < grid.height; row++) {\r\n        for (let col = 0; col < grid.width; col++) {\r\n            processSquare(grid, row, col, WordDirection.Across);\r\n        }\r\n    }\r\n\r\n    for (let col = 0; col < grid.width; col++) {\r\n        for (let row = 0; row < grid.height; row++) {\r\n            processSquare(grid, row, col, WordDirection.Down);\r\n        }\r\n    }\r\n}\r\n\r\nexport function updateGridConstraintInfo(grid: GridState) {\r\n    grid.usedWords = new Map<string, boolean>();\r\n    forAllGridSquares(grid, sq => { sq.viableLetters = undefined; });\r\n\r\n    if (!Globals.wordList) return;\r\n\r\n    let wordKeys = mapKeys(grid.words);\r\n    let sortedWordKeys = wordKeys.filter(k => k.includes(\"A\")).concat(wordKeys.filter(k => k.includes(\"D\")));\r\n    sortedWordKeys.forEach(wordKey => {\r\n        let word = grid.words.get(wordKey)!;\r\n        let newSquares = deepClone(getSquaresForWord(grid, word)) as GridSquare[];\r\n        let letters = getLettersFromSquares(newSquares);\r\n        if (!letters.includes(\"-\")) grid.usedWords.set(letters, true);\r\n        generateConstraintInfoForSquares(newSquares);\r\n        if (newSquares !== undefined && newSquares.length > 0) {\r\n            newSquares.forEach(ns => {\r\n                grid.squares[ns.row][ns.col] = ns;\r\n            });\r\n        }\r\n    });\r\n}\r\n\r\nfunction numberizeGrid(grid: GridState) {\r\n    var currentNumber = 1;\r\n\r\n    for(var row = 0; row < grid.height; row++) {\r\n        for (var col = 0; col < grid.width; col++) {\r\n            var sq = grid.squares[row][col];  \r\n            sq.number = undefined;\r\n\r\n            if (!isBlackSquare(sq)) {\r\n                let isAboveBlocked = (row === 0 || isBlackSquare(grid.squares![row-1][col]));\r\n                let isBelowBlocked = (row === grid.height-1 || isBlackSquare(grid.squares[row+1][col]));\r\n                let isLeftBlocked = (col === 0 || isBlackSquare(grid.squares[row][col-1]));\r\n                let isRightBlocked = (col === grid.width-1 || isBlackSquare(grid.squares[row][col+1]));\r\n\r\n                let isUnchecked = (isAboveBlocked && isBelowBlocked) || (isLeftBlocked && isRightBlocked);\r\n                let isUncheckedStart = (isAboveBlocked && isBelowBlocked && isLeftBlocked && !isRightBlocked) || \r\n                                       (isLeftBlocked && isRightBlocked && isAboveBlocked && !isBelowBlocked);\r\n                let isCheckedStart = isAboveBlocked || isLeftBlocked;\r\n\r\n                if ((isUnchecked && isUncheckedStart) || (!isUnchecked && isCheckedStart)) {\r\n                    sq.number = currentNumber++;\r\n                }\r\n            } \r\n        }\r\n    }\r\n}\r\n\r\nexport function generateConstraintInfoForSquares(squares: GridSquare[]) {\r\n    squares.forEach(sq => {\r\n        if (sq.content) {\r\n            sq.viableLetters = [sq.content];\r\n        }\r\n        else if (!sq.viableLetters) {\r\n            sq.viableLetters = deepClone(fullAlphabet);\r\n        }\r\n    });\r\n    if (isWordEmpty(squares) || isWordFull(squares)) return;\r\n\r\n    let pattern = getLettersFromSquares(squares);\r\n    let entryOptions = queryIndexedWordList(pattern);\r\n    if (entryOptions.length > 500) return;\r\n\r\n    for (let i = 0; i < squares.length; i++) {\r\n        let sq = squares[i];\r\n        if (sq.content) continue;\r\n        let curViableMatrix = sq.viableLetters ? letterListToLetterMatrix(sq.viableLetters) : Array<boolean>(26).fill(true);\r\n        let newViableMatrix = Array<boolean>(26).fill(false);\r\n\r\n        let letters = entryOptions.map(entry => entry[i]);\r\n        letters.forEach(ltr => {\r\n            if (sq.viableLetters && curViableMatrix[ltr.charCodeAt(0) - 65]) return;\r\n            setLettersArrayVal(newViableMatrix, ltr, true);\r\n        });\r\n        sq.viableLetters = letterMatrixToLetterList(newViableMatrix);\r\n    }\r\n}\r\n\r\nexport function getLettersArrayVal(arr: boolean[], ltr: string) {\r\n    return arr[ltr.charCodeAt(0) - 65];\r\n}\r\n\r\nexport function setLettersArrayVal(arr: boolean[], ltr: string, newVal: boolean) {\r\n    arr[ltr.charCodeAt(0) - 65] = newVal;\r\n}\r\n\r\nexport function getConstraintSquareSum(squares: GridSquare[]): number {\r\n    let total = 0;\r\n    squares.forEach(sq => {\r\n        total += sq.viableLetters ? sq.viableLetters.length : 0;\r\n    });\r\n    return total;\r\n}\r\n\r\nexport function getLettersFromSquares(squares: GridSquare[]): string {\r\n    return squares.map(sq => sq.content ? sq.content! : \"-\").join(\"\");\r\n}\r\n\r\nexport function gridToString(grid: GridState): string {\r\n    let chs: string[] = [];\r\n    forAllGridSquares(grid, sq => {\r\n        chs.push(isBlackSquare(sq) ? \".\" : sq.content ? sq.content : \"-\");\r\n    });\r\n    return chs.join(\"\");\r\n}\r\n\r\nexport function createNewGrid(width: number, height: number): GridState {\r\n    let squares: GridSquare[][] = [];\r\n\r\n    for (let row = 0; row < height; row++) {\r\n        squares.push([]);\r\n        for (let col = 0; col < width; col++) {\r\n            squares[row][col] = {\r\n                row: row,\r\n                col: col,\r\n                type: SquareType.White,\r\n                isCircled: false,\r\n                contentType: ContentType.Autofill,\r\n            } as GridSquare;\r\n        }\r\n    }\r\n\r\n    let grid: GridState = {\r\n        height: height,\r\n        width: width,\r\n        squares: squares,\r\n        words: new Map<string, GridWord>(),\r\n        usedWords: new Map<string, boolean>(),\r\n        userFilledSectionCandidates: new Map<string, boolean>(),\r\n    };\r\n\r\n    populateWords(grid);\r\n\r\n    return grid;\r\n}\r\n\r\nexport function getUncheckedSquareDir(grid: GridState, row: number, col: number): WordDirection | undefined {\r\n    if (grid.squares[row][col].type === SquareType.Black) return undefined;\r\n    if ((col === 0 || grid.squares[row][col-1].type === SquareType.Black) &&\r\n        (col === grid.width-1 || grid.squares[row][col+1].type === SquareType.Black))\r\n        return WordDirection.Down;\r\n    if ((row === 0 || grid.squares[row-1][col].type === SquareType.Black) &&\r\n        (row === grid.height-1 || grid.squares[row+1][col].type === SquareType.Black))\r\n        return WordDirection.Across;\r\n\r\n    return undefined;\r\n}\r\n\r\nexport function getSymmetrySquares(initSquare: [number, number]): [number, number][] {\r\n    let grid = getGrid();\r\n    let w = grid.width - 1;\r\n    let h = grid.height - 1;\r\n    let r = initSquare[0];\r\n    let c = initSquare[1];\r\n    let ret = [initSquare];\r\n\r\n    switch (Globals.gridSymmetry!) {\r\n        case SymmetryType.Rotate180:\r\n            ret.push([h - r, w - c]);\r\n            break;\r\n        case SymmetryType.Rotate90:\r\n            ret.push([c, h - r]);\r\n            ret.push([h - r, w - c]);\r\n            ret.push([w - c, r]);\r\n            break;\r\n        case SymmetryType.MirrorHorizontal:\r\n            ret.push([r, w - c]);\r\n            break;\r\n        case SymmetryType.MirrorVertical:\r\n            ret.push([h - r, c]);\r\n            break;\r\n        case SymmetryType.MirrorNWSE:\r\n            ret.push([w - c, h - r]);\r\n            break;\r\n        case SymmetryType.MirrorNESW:\r\n            ret.push([c, r]);\r\n            break;\r\n    }\r\n\r\n    return ret;\r\n}\r\n\r\nexport function insertEntryIntoGrid(node: FillNode, wordKey: string, entry: string, iffyWordKey?: string, contentType?: ContentType) {\r\n    let grid = node.startGrid;\r\n    node.fillWord = grid.words.get(wordKey)!;\r\n    node.chosenEntry = node.entryCandidates.find(ec => ec.word === entry && ec.iffyWordKey === iffyWordKey);\r\n    processAndInsertChosenEntry(node, contentType);\r\n}\r\n\r\nexport function eraseGridSquare(grid: GridState, sq: GridSquare, dir: WordDirection) {\r\n    if (sq.content === undefined) return;\r\n\r\n    let word = getWordAtSquare(grid, sq.row, sq.col, dir)!;\r\n    let squares = word ? getSquaresForWord(grid, word) : [sq];\r\n\r\n    let otherDirWord = getWordAtSquare(grid, sq.row, sq.col, dir)!;\r\n    let otherDirSquares = otherDirWord ? getSquaresForWord(grid, otherDirWord) : [sq];\r\n    if (squares.length > 1 && isWordFull(squares)) grid.usedWords.delete(getLettersFromSquares(squares));\r\n    if (otherDirSquares.length > 1 && isWordFull(otherDirSquares)) grid.usedWords.delete(getLettersFromSquares(otherDirSquares));\r\n\r\n    if (squares.find(sq => sq.contentType === ContentType.Autofill)) {\r\n        ; // autofill is ephemeral, no need to explicitly delete\r\n    }\r\n    else if (squares.find(sq => [ContentType.User, ContentType.ChosenWord].includes(sq.contentType))) {\r\n        let isInSection = getSectionsWithSelectedCandidate().find(sec => sec.squares.has(squareKey(sq)));\r\n\r\n        squares.forEach(wsq => {\r\n            if (wsq.contentType === ContentType.User) return;\r\n            let cross = getWordAtSquare(grid, wsq.row, wsq.col, otherDir(dir))!;\r\n            if (wsq.contentType === ContentType.ChosenWord && !cross) {\r\n                wsq.contentType = ContentType.Autofill;\r\n                return;\r\n            }\r\n            let crossSquares = getSquaresForWord(grid, cross);\r\n            if (crossSquares.find(csq => [ContentType.Autofill, ContentType.ChosenSection].includes(csq.contentType))) {\r\n                if (isInSection)\r\n                    wsq.contentType = ContentType.ChosenSection;\r\n                else\r\n                    wsq.contentType = ContentType.Autofill;\r\n            }\r\n        });\r\n    }\r\n        \r\n    sq.content = undefined;\r\n    sq.contentType = ContentType.Autofill;\r\n    clearFill(grid);\r\n}\r\n\r\nexport function eraseSectionCandidateFromGrid(grid: GridState, sc: SectionCandidate) {\r\n    let section = getSectionWithCandidate(sc);\r\n    Globals.selectedSectionCandidateKeys?.delete(section.id);\r\n    section.squares.forEach((_, sqKey) => {\r\n        let sq = getSquareAtKey(grid, sqKey);\r\n        let scs = getSelectedSectionCandidatesWithSquare(sqKey);\r\n        if (scs.length > 1) return;\r\n        if (sq.contentType === ContentType.ChosenSection)\r\n            sq.contentType = ContentType.Autofill;\r\n    });\r\n}\r\n\r\nexport function clearFill(grid: GridState) {\r\n    Globals.selectedWordNode = undefined;\r\n    let section = getSection();\r\n    section.fillQueue = undefined;\r\n    section.comboPermsQueue = [];\r\n    section.comboPermsUsed = new Map<string, boolean>();\r\n    Globals.fillStatus = Globals.wordList !== undefined ? FillStatus.Ready : FillStatus.NoWordList;\r\n\r\n    forAllGridSquares(grid, sq => {\r\n        if (!isUserFilled(sq)) {\r\n            sq.content = undefined;\r\n        }\r\n    });\r\n\r\n    updateGridConstraintInfo(grid);\r\n}\r\n\r\nexport function updateManualEntryCandidates(grid: GridState) {\r\n    if (!Globals.selectedWordKey || !Globals.wordList) {\r\n        Globals.selectedWordNode = undefined;\r\n        return;\r\n    }\r\n\r\n    let node = makeNewNode(grid, 0, false, undefined);\r\n    node.fillWord = grid.words.get(Globals.selectedWordKey!);\r\n    if (Globals.useManualHeuristics!) {\r\n        populateAndScoreEntryCandidates(node, true);\r\n    }\r\n    else {\r\n        populateNoHeuristicEntryCandidates(node);\r\n    }\r\n    Globals.selectedWordNode = node;\r\n}\r\n","import { CluesViewProp } from \"./CluesViewProp\";\r\nimport React, { createRef, useEffect, useRef, useState } from 'react';\r\nimport \"./CluesView.scss\";\r\nimport { wordKey, deepClone, getSquaresForWord, getGrid, mapValues } from \"../../lib/util\";\r\nimport Globals from '../../lib/windowService';\r\nimport { getLettersFromSquares } from \"../../lib/grid\";\r\nimport { WordDirection } from \"../../models/WordDirection\";\r\n\r\nfunction CluesView(props: any) {\r\n    const [clueProps, setClueProps] = useState(initClueProps());\r\n    const [selectedKey, setSelectedKey] = useState(\"\");\r\n    const textareasRef = useRef([] as any[]);\r\n\r\n    useEffect(() => {\r\n        setClueProps(initClueProps());\r\n        setSelectedKey(Globals.selectedWordKey!);\r\n    }, [props.updateSemaphore])\r\n\r\n    function initClueProps(): CluesViewProp[] {\r\n        let props = [] as CluesViewProp[];\r\n        if (!Globals.puzzle) return props;\r\n\r\n        let grid = getGrid();\r\n        let words = grid.words;\r\n        let clues = Globals.puzzle.clues;\r\n        mapValues(words).sort((a, b) => (a.number || 0) - (b.number || 0)).forEach(word => {\r\n            let key = wordKey(word);\r\n            let squares = getSquaresForWord(grid, word);\r\n            let prop = {\r\n                number: word.number!,\r\n                key: key,\r\n                direction: word.direction,\r\n                clue: clues.get(key)! || \"\",\r\n                entry: getLettersFromSquares(squares),\r\n                isOpenForEditing: false,\r\n            } as CluesViewProp;\r\n            props.push(prop);\r\n        });\r\n        return props;\r\n    }\r\n\r\n    function handleClueClick(event: any) {\r\n        let target = event.target;\r\n        while (![\"clue\"].includes(target.classList[0])) {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n        let targetKey = target.attributes[\"data-key\"].value;\r\n        let refIndex = +target.attributes[\"data-ref-index\"].value;\r\n        let textareaEl = textareasRef.current[refIndex].current;\r\n        \r\n        let newClueProps = deepClone(clueProps) as CluesViewProp[];\r\n        let propToToggle = newClueProps.find(p => p.key === targetKey)!;\r\n        propToToggle.isOpenForEditing = !propToToggle.isOpenForEditing;\r\n        setClueProps(newClueProps);\r\n\r\n        if (propToToggle.isOpenForEditing) {\r\n            textareaEl.value = propToToggle.clue;\r\n            textareaEl.style.display = \"inherit\"; // have to do this before we can autofocus\r\n            textareaEl.focus();\r\n        }\r\n    }\r\n\r\n    function handleKeyDown(event: any) {\r\n        let target = event.target;\r\n        let targetKey: string = target.attributes[\"data-key\"].value;\r\n        let keyPressed: string = event.key.toUpperCase();\r\n\r\n        if (keyPressed === \"ENTER\") {\r\n            applyClueChange(targetKey, target.value);\r\n        }\r\n    }\r\n\r\n    function handleFocus(event: any) {\r\n        event.target.select();\r\n    }\r\n\r\n    function applyClueChange(targetKey: string, newValue: string) {\r\n        let newClueProps = deepClone(clueProps) as CluesViewProp[];\r\n        let targetProp = newClueProps.find(p => p.key === targetKey)!;\r\n        targetProp.clue = newValue === \"(blank clue)\" ? \"\" : newValue;\r\n        targetProp.isOpenForEditing = false;\r\n        Globals.puzzle!.clues.set(targetKey, newValue);\r\n        setClueProps(newClueProps);\r\n    }\r\n\r\n    function renderCluesContainer(isAcross: boolean, clueList: CluesViewProp[], refIndex: number) {\r\n        return (\r\n            <div className=\"clues-container\">\r\n                <div className=\"clues-header\">{isAcross ? \"ACROSS\" : \"DOWN\"}</div>\r\n                <div className=\"clues-clues\">\r\n                    {clueList.map(clue => {\r\n                        textareasRef.current.push(createRef());\r\n                        let ret = (\r\n                            <div key={clue.key}>\r\n                                <div className={\"clue\" + (clue.key === selectedKey ? \" clue-selected\" : \"\")}\r\n                                    data-key={clue.key} onClick={handleClueClick} data-ref-index={refIndex}>\r\n                                    <div className=\"clue-number\">{clue.number}</div>\r\n                                    <div className=\"clue-entry\">{clue.entry}</div>\r\n                                    {clue.entry.length > 15 && <br />}\r\n                                    {clue.clue.length > 0 ? clue.clue : \"(blank clue)\"}\r\n                                </div>\r\n                                <textarea className=\"clue-editor\" defaultValue={clue.clue} data-key={clue.key} \r\n                                    style={{display: clue.isOpenForEditing ? \"inherit\" : \"none\"}}\r\n                                    onKeyDown={handleKeyDown} onFocus={handleFocus}\r\n                                    ref={textareasRef.current[refIndex]}>\r\n                                </textarea>\r\n                            </div>\r\n                        );\r\n                        refIndex++;\r\n                        return ret;\r\n                    })}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    textareasRef.current = [] as any[];\r\n    let acrossClues = clueProps.filter(p => p.direction === WordDirection.Across);\r\n    let downClues = clueProps.filter(p => p.direction === WordDirection.Down);\r\n\r\n    return (\r\n        <div className=\"clues-view\">\r\n            {renderCluesContainer(true, acrossClues, 0)}\r\n            {renderCluesContainer(false, downClues, acrossClues.length)}\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default CluesView;\r\n","import React, { useContext, useState } from 'react';\r\nimport { SymmetryType } from '../../models/SymmetryType';\r\nimport \"./FillView.scss\";\r\nimport Globals from '../../lib/windowService';\r\nimport { FillStatus } from '../../models/FillStatus';\r\nimport { getEntryAtWordKey, getGrid, getSection, getSquaresForWord, mapKeys, mapValues } from '../../lib/util';\r\nimport { calculateSectionOrder, getLongestStackWord, getPhoneticName, insertSectionCandidateIntoGrid, \r\n    makeNewSection, sectionCandidateKey, updateSectionFilters } from '../../lib/section';\r\nimport { clearFill, eraseSectionCandidateFromGrid, getLettersFromSquares, insertEntryIntoGrid, updateGridConstraintInfo, updateManualEntryCandidates } from '../../lib/grid';\r\nimport { fillSectionWord, makeNewNode } from '../../lib/fill';\r\nimport { FillNode } from '../../models/FillNode';\r\nimport { AppContext } from '../../AppContext';\r\nimport { ContentType } from '../../models/ContentType';\r\nimport { Section } from '../../models/Section';\r\nimport { processWordListData } from '../../lib/wordList';\r\nimport { useInterval } from '../../lib/useInterval';\r\nimport { SectionCandidate } from '../../models/SectionCandidate';\r\nimport { QualityClass } from '../../models/QualityClass';\r\n\r\nfunction FillView() {\r\n    const appContext = useContext(AppContext);\r\n    const [showSectionCandidates, setShowSectionCandidates] = useState(true);\r\n    const [isWordListLoading, setIsWordListLoading] = useState(false);\r\n    const [isFillRunning, setIsFillRunning] = useState(false);\r\n\r\n    function triggerUpdate() {\r\n        appContext.triggerUpdate();\r\n    }\r\n\r\n    function setFillStatus(newStatus: FillStatus) {\r\n        Globals.fillStatus = newStatus;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleToggleFill() {\r\n        if (isFillRunning) {\r\n            clearFill(getGrid());\r\n            setFillStatus(FillStatus.Ready);\r\n            setIsFillRunning(false);\r\n            triggerUpdate();\r\n        }\r\n        else {\r\n            setFillStatus(FillStatus.Running);\r\n            setIsFillRunning(true);\r\n        }\r\n    }\r\n    \r\n    function doFillWord() {\r\n        if (Globals.fillStatus === FillStatus.Complete) return;\r\n        if (!fillSectionWord()) {\r\n            clearFill(getGrid());\r\n            setFillStatus(FillStatus.Complete);\r\n            setIsFillRunning(false);\r\n        }\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleFillWordClick(event: any) {\r\n        if (!Globals.wordList) return;\r\n\r\n        if (!fillSectionWord()) {\r\n            clearFill(getGrid());\r\n            setFillStatus(FillStatus.Complete);\r\n        }\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleSymmetryChange(event: any) {\r\n        Globals.gridSymmetry = +SymmetryType[event.target[event.target.selectedIndex].value] as SymmetryType;\r\n    }\r\n\r\n    function handleIffyLengthChange(event: any) {\r\n        Globals.maxIffyLength = +event.target[event.target.selectedIndex].value;\r\n    }\r\n\r\n    function getSymmetryTypeString(type: string): string {\r\n        switch(type) {\r\n            case \"None\": return \"None\";\r\n            case \"Rotate180\": return \"180° Rotational\";\r\n            case \"Rotate90\": return \"90° Rotational\";\r\n            case \"MirrorHorizontal\": return \"Mirror Horizontally\";\r\n            case \"MirrorVertical\": return \"Mirror Vertically\";\r\n            case \"MirrorNWSE\": return \"Mirror NW to SE\";\r\n            case \"MirrorNESW\": return \"Mirror NE to SW\";\r\n        }\r\n        return \"\";\r\n    }\r\n\r\n    function getSymmetryTypesForRectGrids(): string[] {\r\n        return [\"None\", \"Rotate180\", \"MirrorHorizontal\", \"MirrorVertical\"];\r\n    }\r\n\r\n    function getFillStatusString(status: FillStatus): string {\r\n        switch(status) {\r\n            case FillStatus.NoWordList: return \"No Word List Loaded\";\r\n            case FillStatus.Ready: return \"Ready to Fill\";\r\n            case FillStatus.Running: return \"Fill Running...\";\r\n            case FillStatus.Complete: return \"Fill Complete\";\r\n            default: return \"\";\r\n        }\r\n    }\r\n\r\n    function getManualEntryNode(entry: string, iffyWordKey?: string, isHover?: boolean): FillNode {\r\n        let node = Globals.selectedWordNode!;\r\n        let wordKey = Globals.selectedWordKey!;\r\n        insertEntryIntoGrid(node, wordKey, entry, iffyWordKey, isHover ? ContentType.HoverChosenWord : ContentType.ChosenWord);\r\n        return node;\r\n    }\r\n\r\n    function getManualSectionNode(sectionCandidateKey: string, isHover: boolean): FillNode {\r\n        let grid = getGrid();\r\n\r\n        let node = makeNewNode(grid, 0, false, undefined);\r\n        let section = getSection();\r\n        let candidate = section.candidates.get(sectionCandidateKey)!;\r\n        insertSectionCandidateIntoGrid(node.endGrid, candidate, \r\n            isHover ? ContentType.HoverChosenSection : ContentType.ChosenSection);\r\n        return node;\r\n    }\r\n\r\n    function handleEntryCandidateClick(event: any) {\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        if (!Globals.selectedWordKey) return;\r\n\r\n        let entry = target.attributes[\"data-word\"].value as string;\r\n        let iffyWordKey = target.attributes[\"data-iffykey\"].value as string | undefined;\r\n        if (iffyWordKey === \"na\") iffyWordKey = undefined;\r\n        let node = getManualEntryNode(entry, iffyWordKey, false);\r\n\r\n        updateManualEntryCandidates(node.endGrid);\r\n\r\n        Globals.activeGrid = node.endGrid;\r\n        updateSectionFilters();\r\n        Globals.hoverGrid = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleEntryCandidateHover(event: any) {\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        if (!Globals.selectedWordKey) return;\r\n\r\n        let entry = target.attributes[\"data-word\"].value as string;\r\n        let iffyWordKey = target.attributes[\"data-iffykey\"].value as string | undefined;\r\n        if (iffyWordKey === \"na\") iffyWordKey = undefined;\r\n        let node = getManualEntryNode(entry, iffyWordKey, true);\r\n\r\n        Globals.hoverGrid = node.endGrid;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleEntryCandidateBlur() {\r\n        Globals.hoverGrid = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleSectionClick(event: any) {\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n            if (target.classList[0] === \"section-checkbox\") return;\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        let sectionId = +target.attributes[\"data-id\"].value;\r\n        clearFill(getGrid());\r\n\r\n        if (sectionId === Globals.activeSectionId!) {\r\n            Globals.activeSectionId = 0;\r\n            Globals.selectedSectionIds = new Map<number, boolean>();\r\n            Globals.selectedSectionIds!.set(sectionId, true);\r\n        }\r\n        else {\r\n            Globals.activeSectionId = sectionId;\r\n            Globals.selectedSectionIds = new Map<number, boolean>();\r\n            Globals.selectedSectionIds!.set(sectionId, true);\r\n        }\r\n\r\n        Globals.hoverGrid = undefined;\r\n        Globals.hoverSectionId = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleSectionCheckClick(event: any) {\r\n        return;\r\n        // let target = event.target;\r\n        // while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n        //     target = target.parentElement;\r\n        //     if (!target) return;\r\n        // }\r\n\r\n        // let sectionId = +target.attributes[\"data-id\"].value;\r\n        // if (Globals.selectedSectionIds!.get(sectionId))\r\n        //     Globals.selectedSectionIds!.delete(sectionId);\r\n        // else\r\n        //     Globals.selectedSectionIds!.set(sectionId, true);\r\n    }\r\n\r\n    function handleSectionHover(event: any) {\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        let sectionId = +target.attributes[\"data-id\"].value;\r\n        Globals.hoverSectionId = sectionId;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleSectionBlur() {\r\n        Globals.hoverSectionId = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleSectionCandidateClick(event: any) {\r\n        function eraseSc() {\r\n            section.selectedCandidate = undefined;\r\n            section.comboPermsQueue = [];\r\n            section.comboPermsUsed = new Map<string, boolean>();\r\n            let sc = section.candidates.get(candidateKey)!;\r\n            eraseSectionCandidateFromGrid(grid, sc);\r\n            clearFill(grid);\r\n        }\r\n\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        let section = getSection();\r\n        let grid = getGrid();\r\n        let candidateKey = target.attributes[\"data-candidate-key\"].value as string;\r\n\r\n        if (section.selectedCandidate === candidateKey) {\r\n            eraseSc();\r\n        }\r\n        else {\r\n            if (section.selectedCandidate) eraseSc();\r\n\r\n            let node = getManualSectionNode(candidateKey, false);\r\n            Globals.selectedSectionCandidateKeys!.set(section.id, candidateKey);\r\n            section.selectedCandidate = candidateKey;\r\n\r\n            updateManualEntryCandidates(node.endGrid);\r\n\r\n            Globals.activeGrid = node.endGrid;\r\n        }\r\n        \r\n        updateSectionFilters();\r\n        Globals.hoverGrid = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleSectionCandidateHover(event: any) {\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        let candidateKey = target.attributes[\"data-candidate-key\"].value as string;\r\n        let node = getManualSectionNode(candidateKey, true);\r\n\r\n        Globals.hoverGrid = node.endGrid;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleShowSectionCandidatesToggle() {\r\n        setShowSectionCandidates(!showSectionCandidates);\r\n    }\r\n\r\n    function clearSectionCandidates() {\r\n        if (!window.confirm(\"Are you sure you want to clear the fills?\")) return;\r\n\r\n        let section = getSection();\r\n        section.candidates = new Map<string, SectionCandidate>();\r\n        section.selectedCandidate = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleUseHeuristicsToggle() {\r\n        let newValue = Globals.useManualHeuristics !== undefined ? !Globals.useManualHeuristics! : false;\r\n        Globals.useManualHeuristics = newValue;\r\n\r\n        triggerUpdate();\r\n        let node = Globals.selectedWordNode;\r\n        if (!node) return;\r\n\r\n        updateManualEntryCandidates(grid);\r\n    }\r\n\r\n    function handleSectionCandidateBlur() {\r\n        Globals.hoverGrid = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function loadWordList() {\r\n        document.getElementById(\"open-wordlist-input\")!.click();\r\n    }\r\n\r\n    function clearWordLists() {\r\n        if (!window.confirm(\"Are you sure you want to clear the word lists?\")) return;\r\n\r\n        Globals.wordList = undefined;\r\n        Globals.wordLists = [];\r\n        setFillStatus(FillStatus.NoWordList);\r\n        Globals.selectedWordNode = undefined;\r\n        Globals.qualityClasses = new Map<string, QualityClass>();\r\n    }\r\n\r\n    function onWordListUpload(event: any) {\r\n        let file = event.target.files[0];\r\n        event.target.value = null;\r\n        setIsWordListLoading(true);\r\n\r\n        setTimeout(() => {\r\n            processWordListData(file.name, file).then(wordList => {\r\n                if (wordList) {\r\n                    Globals.wordLists!.push(wordList);\r\n                    setFillStatus(FillStatus.Ready);\r\n                    let grid = getGrid();\r\n                    updateGridConstraintInfo(grid);\r\n                    updateManualEntryCandidates(grid);\r\n                    setIsWordListLoading(false);\r\n                    triggerUpdate();\r\n                }\r\n            });\r\n        }, 5);\r\n    }\r\n\r\n    useInterval(() => {\r\n        doFillWord();\r\n    }, isFillRunning ? 5 : null);\r\n\r\n    let grid = getGrid();\r\n    let selectedSymmetry = SymmetryType[Globals.gridSymmetry!];\r\n    let symmetryOptions = (!grid || grid.width === grid.height) ?\r\n        Object.values(SymmetryType).filter(t => isNaN(Number(t))) :\r\n        getSymmetryTypesForRectGrids();\r\n\r\n    let fillStatusStr = getFillStatusString(Globals.fillStatus!);\r\n    \r\n    let wordLists = Globals.wordLists || [];\r\n\r\n    let entryCandidates = Globals.selectedWordNode ? Globals.selectedWordNode.entryCandidates : [];\r\n    let isNoEntryCandidates = Globals.selectedWordNode && entryCandidates.length === 0;\r\n\r\n    let sections = [] as Section[];\r\n    if (Globals.sections!) {\r\n        let sectionsOrder = calculateSectionOrder(mapValues(Globals.sections!));\r\n        sections = sectionsOrder.map(id => Globals.sections!.get(id)!);\r\n    }\r\n    let activeSection = Globals.sections ? Globals.sections!.get(Globals.activeSectionId!)! : makeNewSection(-1);\r\n    let selectedScKey = activeSection.selectedCandidate;\r\n    let selectedSectionIds = mapKeys(Globals.selectedSectionIds!) || [0];\r\n    let sectionCandidates = mapValues(activeSection.candidates)\r\n        .filter(sc => !sc.isFilteredOut).sort((a, b) => b.score - a.score);\r\n    let selectedEntry = Globals.selectedWordKey ? getEntryAtWordKey(grid, Globals.selectedWordKey!) : \"\";\r\n    let selectedMaxIffyLength = Globals.maxIffyLength || 0;\r\n    let useManualHeuristics = Globals.useManualHeuristics !== undefined ? Globals.useManualHeuristics : true;\r\n\r\n    let wordListsStyle = {\r\n        gridTemplateColumns: `4fr 1fr`\r\n    } as React.CSSProperties;\r\n\r\n    let entryCandidatesStyle = {\r\n        gridTemplateColumns: `4fr 1fr 2fr`\r\n    } as React.CSSProperties;\r\n\r\n    let sectionsStyle = {\r\n        gridTemplateColumns: `1fr 2fr 1fr 1fr 1fr`\r\n    } as React.CSSProperties;\r\n\r\n    let fillsStyle = {\r\n        gridTemplateColumns: `4fr 1fr 2fr`\r\n    } as React.CSSProperties;\r\n\r\n    return (\r\n        <div id=\"FillView\" className=\"fill-container\">\r\n            <input id=\"open-wordlist-input\" hidden type=\"file\" accept=\".dict,.txt\" onChange={onWordListUpload} />\r\n            <div id=\"loader\" style={{display: isWordListLoading ? \"block\" : \"none\"}}></div>\r\n\r\n            <div className={\"fill-status\" +\r\n                (Globals.fillStatus! === FillStatus.NoWordList ? \" fill-status-red\" :\r\n                Globals.fillStatus! === FillStatus.Running ? \" fill-status-green\" : \"\")}>{fillStatusStr}</div>\r\n            {wordLists.length > 0 &&\r\n            <>\r\n                <div className=\"custom-control custom-switch fill-switch\">\r\n                    <input type=\"checkbox\" className=\"custom-control-input\" id=\"fillSwitch\" \r\n                        checked={isFillRunning} onChange={handleToggleFill} />\r\n                    <label className=\"custom-control-label\" htmlFor=\"fillSwitch\">Fill</label>\r\n                </div>\r\n                <br />\r\n                Max Iffy Length: <br />\r\n                <select className=\"custom-select iffy-select\" defaultValue={selectedMaxIffyLength} onChange={handleIffyLengthChange}>\r\n                    <option value={0} key={0}>Off</option>\r\n                    {[2, 3, 4, 5, 6, 7].map(length => (\r\n                        <option value={length} key={length}>{length}</option>\r\n                    ))}\r\n                </select>\r\n            </>\r\n            }\r\n            \r\n            <br /><br />\r\n            Grid Symmetry: <br />\r\n            <select className=\"custom-select symmetry-select\" defaultValue={selectedSymmetry} onChange={handleSymmetryChange}>\r\n                {symmetryOptions.map(type => (\r\n                    <option value={type} key={type}>{getSymmetryTypeString(type.toString())}</option>\r\n                ))}\r\n            </select>\r\n            <br /><br />\r\n            <button className=\"btn btn-primary\" onClick={handleFillWordClick} style={{display: \"none\"}}>Fill Word</button>\r\n\r\n            <div className=\"fill-lists\">\r\n                <div className=\"fill-list-box\">\r\n                    <div className=\"fill-list-title\">Word Lists</div>\r\n                    <div className=\"fill-list-button\" onClick={clearWordLists}>Clear</div>\r\n                    <div className=\"fill-list-button\" onClick={loadWordList}>Load</div>\r\n                    <div className=\"fill-list\" style={wordListsStyle}>\r\n                        <div className=\"fill-list-header\">Filename</div>\r\n                        <div className=\"fill-list-header\">Count</div>\r\n                        { wordLists.length === 0 && (\r\n                            <div className=\"fill-list-row-wrapper\" style={{cursor: \"auto\"}}>\r\n                                <div><i>No word lists loaded</i></div><div></div>\r\n                            </div>\r\n                        )}\r\n                        { wordLists.map(wl => (\r\n                            <div className=\"fill-list-row-wrapper\" style={{cursor: \"auto\"}} key={wl.filename}>\r\n                                <div>{wl.filename}</div>\r\n                                <div>{wl.wordCount}</div>\r\n                            </div>\r\n                        ))}\r\n                    </div>\r\n                </div>\r\n                <div className=\"fill-list-box\" onMouseOut={handleEntryCandidateBlur}>\r\n                    <div className=\"fill-list-title entry-color\">Entry Candidates</div>\r\n                    <div className=\"fill-sec-checkbox\">\r\n                        <input type=\"checkbox\" className=\"section-checkbox\" id=\"use-heuristics-box\"\r\n                                    checked={useManualHeuristics} onChange={handleUseHeuristicsToggle} />\r\n                        <label htmlFor=\"use-heuristics-box\">Use heuristics</label>\r\n                    </div>\r\n                    <div className=\"fill-list\" style={entryCandidatesStyle}>\r\n                        <div className=\"fill-list-header\">Entry</div>\r\n                        <div className=\"fill-list-header\">Score</div>\r\n                        <div className=\"fill-list-header\">Iffy</div>\r\n                        { isNoEntryCandidates && useManualHeuristics && (\r\n                            <div className=\"fill-list-row-wrapper\">\r\n                                <div><i>No viable entries</i></div><div></div><div></div>\r\n                            </div>\r\n                        )}\r\n                        { entryCandidates.map(ec => (\r\n                            <div className={\"fill-list-row-wrapper\" + (selectedEntry === ec.word ? \" fill-list-row-selected\" : \"\")} \r\n                                key={ec.word + (ec.iffyEntry || \"\")} data-word={ec.word} data-iffykey={ec.iffyWordKey || \"na\"}\r\n                                onClick={handleEntryCandidateClick} onMouseOver={handleEntryCandidateHover}>\r\n                                <div>{ec.word}</div>\r\n                                <div>{ec.score.toFixed(0)}</div>\r\n                                <div>{ec.iffyEntry || \"\"}</div>\r\n                            </div>\r\n                        ))}\r\n                    </div>\r\n                </div>\r\n                <div className=\"fill-list-box\" onMouseOut={handleSectionBlur}>\r\n                    <div className=\"fill-list-title section-color\">Sections</div>\r\n                    <div className=\"fill-list\" style={sectionsStyle}>\r\n                        <div className=\"fill-list-header\">Active</div>\r\n                        <div className=\"fill-list-header\">ID</div>\r\n                        <div className=\"fill-list-header\">Size</div>\r\n                        <div className=\"fill-list-header\">Conn</div>\r\n                        <div className=\"fill-list-header\">Fills</div>\r\n                        { sections.map(sec => (\r\n                            <div className={\"fill-list-row-wrapper\" + (sec.id === activeSection.id ? \" fill-list-row-selected\" : \"\")} \r\n                                key={sec.id} data-id={sec.id} onClick={handleSectionClick} onMouseOver={handleSectionHover}>\r\n                                <div><input type=\"checkbox\" className=\"section-checkbox\"\r\n                                    checked={selectedSectionIds.includes(sec.id)} onChange={handleSectionCheckClick} /></div>\r\n                                <div>{getPhoneticName(sec.id)}</div>\r\n                                <div>{sec.squares.size}</div>\r\n                                <div>{sec.connections.size}</div>\r\n                                <div>{sec.candidates.size}</div>\r\n                            </div>\r\n                        ))}\r\n                    </div>\r\n                </div>\r\n                <div className=\"fill-list-box\" onMouseOut={handleSectionCandidateBlur}>\r\n                    <div className=\"fill-list-title\">Fills {sectionCandidates.length > 0 ? `(${sectionCandidates.length})` : \"\"}</div>\r\n                    <div className=\"fill-list-button\" onClick={clearSectionCandidates}>Clear</div>\r\n                    <div className=\"fill-sec-checkbox\">\r\n                        <input type=\"checkbox\" className=\"section-checkbox\" id=\"show-fills-box\"\r\n                                    checked={showSectionCandidates} onChange={handleShowSectionCandidatesToggle} />\r\n                        <label htmlFor=\"show-fills-box\">Show</label>\r\n                    </div>\r\n                    <div className=\"fill-list\" style={fillsStyle}>\r\n                        <div className=\"fill-list-header\">Longest</div>\r\n                        <div className=\"fill-list-header\">Score</div>\r\n                        <div className=\"fill-list-header\">Iffy</div>\r\n                        {!showSectionCandidates && (\r\n                            <div className=\"fill-list-row-wrapper\">\r\n                                <div><i>Hidden</i></div><div></div><div></div>\r\n                            </div>\r\n                        )}\r\n                        {showSectionCandidates && Globals.fillStatus === FillStatus.Complete && sectionCandidates.length === 0 && (\r\n                            <div className=\"fill-list-row-wrapper\">\r\n                                <div><i>No fills found</i></div><div></div><div></div>\r\n                            </div>\r\n                        )}\r\n                        {showSectionCandidates && sectionCandidates.map(sc => {\r\n                            let entry = getLettersFromSquares(getSquaresForWord(sc.grid, getLongestStackWord(activeSection)));\r\n                            let candidateKey = sectionCandidateKey(activeSection, sc.grid);\r\n\r\n                            return (\r\n                            <div className={\"fill-list-row-wrapper\" + (selectedScKey === candidateKey ? \" fill-list-row-selected\" : \"\")}\r\n                                key={candidateKey} data-candidate-key={candidateKey}\r\n                                onClick={handleSectionCandidateClick} onMouseOver={handleSectionCandidateHover}>\r\n                                <div>{entry}</div>\r\n                                <div>{sc.score.toFixed(2)}</div>\r\n                                <div>{sc.iffyEntry || \"\"}</div>\r\n                            </div>\r\n                        )})}\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default FillView;\r\n","import { useEffect, useRef } from 'react';\r\n\r\nexport function useInterval(callback: () => void, delay: number | null) {\r\n  const savedCallback = useRef<() => void>();\r\n\r\n  // Remember the latest callback.\r\n  useEffect(() => {\r\n    savedCallback.current = callback;\r\n  }, [callback]);\r\n\r\n  // Set up the interval.\r\n  useEffect(() => {\r\n    function tick() {\r\n      if (savedCallback.current) savedCallback.current();\r\n    }\r\n    if (delay !== null) {\r\n      let id = setInterval(tick, delay);\r\n      return () => clearInterval(id);\r\n    }\r\n  }, [delay]);\r\n}\r\n","import React from 'react';\r\nimport { ContentType } from '../../models/ContentType';\r\nimport { QualityClass } from '../../models/QualityClass';\r\nimport { SquareType } from '../../models/SquareType';\r\nimport { SquareProps } from './SquareProps';\r\n\r\nfunction Square(props: SquareProps) {\r\n    return getSquareElement(props);\r\n}\r\n\r\nfunction getSquareElement(props: SquareProps) {\r\n    let content = props.content || \"\";\r\n    if (props.type === SquareType.White) {\r\n        return <div \r\n                    className={\"grid-square\" + \r\n                        (props.isSelected ? \" grid-square-selected\" : \r\n                        props.isInSelectedWord ? \" grid-square-selected-word\" : \r\n                        props.isInSelectedSection ? \" grid-square-selected-section\" : \"\") +\r\n                        (props.content ? \"\" :\r\n                        props.constraintSum === 0 ? \" grid-square-error-word\" :\r\n                        between(props.constraintSum, 1, 1) ? \" grid-square-constrained-5\" : \r\n                        between(props.constraintSum, 1, 3) ? \" grid-square-constrained-4\" : \r\n                        between(props.constraintSum, 1, 5) ? \" grid-square-constrained-3\" : \r\n                        between(props.constraintSum, 1, 10) ? \" grid-square-constrained-2\" : \r\n                        between(props.constraintSum, 1, 15) ? \" grid-square-constrained-1\" : \"\"\r\n                        )} \r\n                    data-row={props.row} data-col={props.col}>\r\n            {props.isCircled && \r\n                <div className=\"grid-square-circled\"></div>\r\n            }\r\n            <div className=\"grid-number\">{props.number ?? \"\"}</div>\r\n            <div className={\"grid-content\" + \r\n                        (content.length > 1 ? \" grid-content-rebus\" : \"\") +\r\n                        (props.content && props.contentType === ContentType.User ? \"\" :\r\n                         props.content && props.contentType === ContentType.ChosenWord ? \" grid-content-chosen-word\" :\r\n                         props.content && props.contentType === ContentType.HoverChosenWord ? \" grid-content-chosen-word-hover\" :\r\n                         props.content && props.contentType === ContentType.ChosenSection ? \" grid-content-chosen-section\" :\r\n                         props.content && props.contentType === ContentType.HoverChosenSection ? \" grid-content-chosen-section-hover\" :\r\n                         props.qualityClass === QualityClass.Lively ? \" grid-content-lively\" :\r\n                         props.qualityClass === QualityClass.Normal ? \" grid-content-normal\" :\r\n                         props.qualityClass === QualityClass.Crosswordese ? \" grid-content-crosswordese\" :\r\n                         props.qualityClass === QualityClass.Iffy ? \" grid-content-iffy\" :\r\n                         props.qualityClass === QualityClass.NotAThing ? \" grid-content-notathing\" : \"\"\r\n                        )}>\r\n                    {content}\r\n            </div>\r\n        </div>\r\n    }\r\n    else {\r\n        return <div className={\"grid-square-black\" + (props.isSelected ? \" grid-square-black-selected\" : \"\")} \r\n            data-row={props.row} data-col={props.col}>\r\n        </div>\r\n    }\r\n}\r\n\r\nfunction between(input: number, min: number, max: number): boolean {\r\n    return input >= min && input <= max;\r\n}\r\n\r\nexport default Square;\r\n","import React, { useContext, useState } from 'react';\r\nimport { SquareType } from '../../models/SquareType';\r\nimport { SquareProps } from '../Square/SquareProps';\r\nimport \"./Grid.scss\";\r\nimport Square from '../Square/Square';\r\nimport { GridState } from '../../models/GridState';\r\nimport { WordDirection } from '../../models/WordDirection';\r\nimport Globals from '../../lib/windowService';\r\nimport { compareTuples, doesWordContainSquare, getGrid, getSection, getSelectedWord, getSquaresForWord, \r\n    getWordAtSquare, initializeSessionGlobals, isWordFull, mapValues, otherDir, \r\n    squareKey, wordKey } from '../../lib/util';\r\nimport { clearFill, eraseGridSquare, getLettersFromSquares, getSymmetrySquares, getUncheckedSquareDir, populateWords, \r\n    updateGridConstraintInfo, updateManualEntryCandidates } from '../../lib/grid';\r\nimport { GridWord } from '../../models/GridWord';\r\nimport { AppContext } from '../../AppContext';\r\nimport { ContentType } from '../../models/ContentType';\r\nimport { updateSectionFilters } from '../../lib/section';\r\nimport { QualityClass } from '../../models/QualityClass';\r\nimport { GridSquare } from '../../models/GridSquare';\r\nimport { Section } from '../../models/Section';\r\n\r\nfunction Grid() {\r\n    const [selectedSquare, setSelectedSquare] = useState([-1, -1] as [number, number]);\r\n    const appContext = useContext(AppContext);\r\n\r\n    function handleClick(event: any) {\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || ![\"grid-square\", \"grid-square-black\"].includes(target.classList[0])) {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        let row = +target.attributes[\"data-row\"].value;\r\n        let col = +target.attributes[\"data-col\"].value;\r\n        let grid = getGrid();\r\n        \r\n        let newDirection = Globals.selectedWordDir || WordDirection.Across;\r\n\r\n        let uncheckedSquareDir = getUncheckedSquareDir(grid, row, col);\r\n        if (uncheckedSquareDir !== undefined) {\r\n            newDirection = uncheckedSquareDir;\r\n            setSelectedSquare([row, col]);\r\n        }\r\n        else if (compareTuples([row, col], selectedSquare)) {\r\n            newDirection = otherDir(newDirection);\r\n        }\r\n        else {\r\n            setSelectedSquare([row, col]);\r\n        }\r\n\r\n        Globals.selectedWordDir = newDirection;\r\n        setSelWordAtSelSquare([row, col]);\r\n\r\n        updateManualEntryCandidates(grid);\r\n\r\n        appContext.triggerUpdate();\r\n    }\r\n    \r\n    function handleKeyDown(event: any) {\r\n        if (!isSquareSelected()) return;\r\n\r\n        let grid = getGrid();\r\n        let row = selectedSquare[0];\r\n        let col = selectedSquare[1];\r\n\r\n        let key: string = event.key.toUpperCase();\r\n        let letterChanged = false;\r\n        let blackSquareChanged = false;\r\n        let sq = grid.squares[row][col];\r\n        let newSelSq = [-1,-1] as [number, number];\r\n\r\n        if (key.match(/^[A-Z]$/)) {\r\n            newSelSq = advanceCursor();\r\n\r\n            if (sq.type === SquareType.Black) return;\r\n            if (sq.content === key && sq.contentType === ContentType.User) return;\r\n\r\n            letterChanged = true;\r\n            if (sq.content !== key && sq.contentType !== ContentType.User)\r\n                eraseGridSquare(grid, sq, Globals.selectedWordDir!);\r\n\r\n            sq = grid.squares[row][col];\r\n            sq.content = key;\r\n            sq.contentType = ContentType.User;\r\n        }\r\n        if (key === \"BACKSPACE\") {\r\n            newSelSq = backupCursor();\r\n\r\n            if (sq.content !== undefined) {\r\n                eraseGridSquare(grid, sq, Globals.selectedWordDir!);\r\n                letterChanged = true;\r\n            }\r\n                \r\n            if (sq.type === SquareType.Black) {\r\n                getSymmetrySquares([row, col]).forEach(res => {\r\n                    let resSq = grid.squares[res[0]][res[1]];\r\n                    resSq.type = SquareType.White;\r\n                });\r\n\r\n                blackSquareChanged = true;\r\n            }\r\n        }\r\n        // toggle black square\r\n        if (key === \".\") {\r\n            newSelSq = advanceCursor();\r\n\r\n            eraseGridSquare(grid, sq, Globals.selectedWordDir!);\r\n\r\n            let newSquareType = sq.type === SquareType.White ? SquareType.Black : SquareType.White;\r\n            getSymmetrySquares([row, col]).forEach(res => {\r\n                let resSq = grid.squares[res[0]][res[1]];\r\n                resSq.type = newSquareType;\r\n            });\r\n\r\n            blackSquareChanged = true;\r\n        }\r\n        // toggle circled square\r\n        if (key === \",\") {\r\n            if (sq.type === SquareType.Black) return;\r\n            sq.isCircled = !sq.isCircled;\r\n            newSelSq = advanceCursor();\r\n            setSelWordAtSelSquare(newSelSq);\r\n        }\r\n\r\n        if (blackSquareChanged) {\r\n            populateWords(grid);\r\n            initializeSessionGlobals();\r\n            clearFill(grid);\r\n            setSelWordAtSelSquare(newSelSq);\r\n            updateGridConstraintInfo(grid);\r\n        }\r\n        else if (letterChanged)  {\r\n            updateSectionFilters();\r\n            updateGridConstraintInfo(grid);\r\n        }\r\n\r\n        updateManualEntryCandidates(grid);\r\n\r\n        appContext.triggerUpdate();\r\n    }\r\n\r\n    function advanceCursor(): [number, number] {\r\n        let selSq = selectedSquare;\r\n        if (!isSquareSelected()) return selSq;\r\n    \r\n        let grid = getGrid();\r\n        let dir = Globals.selectedWordDir!;\r\n        if ((dir === WordDirection.Across && selSq[1] === grid.width-1) || (dir === WordDirection.Down && selSq[0] === grid.height-1))\r\n            return selSq;\r\n\r\n        let newSelSq = (dir === WordDirection.Across ? [selSq[0], selSq[1] + 1] : [selSq[0] + 1, selSq[1]]) as [number, number];\r\n        setSelectedSquare(newSelSq);\r\n        setSelWordAtSelSquare(newSelSq);\r\n        return newSelSq;\r\n    }\r\n    \r\n    function backupCursor(): [number, number] {\r\n        let selSq = selectedSquare;\r\n        if (!isSquareSelected()) return selSq;\r\n    \r\n        let dir = Globals.selectedWordDir!;\r\n        if ((dir === WordDirection.Across && selSq[1] === 0) || (dir === WordDirection.Down && selSq[0] === 0))\r\n            return selSq;\r\n\r\n        let newSelSq = (dir === WordDirection.Across ? [selSq[0], selSq[1] - 1] : [selSq[0] - 1, selSq[1]]) as [number, number];\r\n        setSelectedSquare(newSelSq);\r\n        setSelWordAtSelSquare(newSelSq);\r\n        return newSelSq;\r\n    }\r\n\r\n    function isSquareSelected(): boolean {\r\n        return selectedSquare[0] > -1;\r\n    }\r\n    \r\n    function isWordSelected(): boolean {\r\n        return !!getSelectedWord();\r\n    }\r\n\r\n    function isSquareInSection(section: Section, sq: GridSquare): boolean {\r\n        return section.squares.has(squareKey(sq));\r\n    }\r\n\r\n    function setSelWordAtSelSquare(newSelSquare: [number, number]) {\r\n        let grid = getGrid();\r\n        let word = getWordAtSquare(grid, newSelSquare[0], newSelSquare[1], Globals.selectedWordDir!);\r\n        Globals.selectedWordKey = word ? wordKey(word) : undefined;\r\n    }\r\n\r\n    function getSquareProps(grid: GridState, row: number, col: number, \r\n        selectedSquare: [number, number], selectedWord: GridWord | undefined): SquareProps {\r\n        let square = grid.squares[row][col];\r\n    \r\n        return {\r\n            key: `${row},${col}`,\r\n            row: row,\r\n            col: col,\r\n            number: square.number,\r\n            type: square.type,\r\n            content: square.content,\r\n            contentType: square.contentType,\r\n            qualityClass: qualityClassMap.get(squareKey(square)) || QualityClass.Normal,\r\n            isSelected: isSquareSelected() && compareTuples(selectedSquare, [row, col]),\r\n            isInSelectedWord: isWordSelected() && doesWordContainSquare(selectedWord!, row, col),\r\n            isInSelectedSection: (Globals.activeSectionId !== 0 && isSquareInSection(getSection(), square)) ||\r\n                (Globals.hoverSectionId !== undefined && isSquareInSection(Globals.sections!.get(Globals.hoverSectionId)!, square)),\r\n            constraintSum: square.viableLetters ? square.viableLetters.length : 26,\r\n            isCircled: square.isCircled,\r\n        };\r\n    }\r\n\r\n    function getSquareElement(props: SquareProps) {\r\n        return <Square {...props}></Square>\r\n    }\r\n\r\n    function suppressEnterKey(event: any) {\r\n        let keyPressed: string = event.key.toUpperCase();\r\n\r\n        if (keyPressed === \"ENTER\") {\r\n            event.preventDefault();\r\n        }\r\n    }\r\n\r\n    function handleFocus(event: any) {\r\n        selectElementContents(event.target);\r\n    }\r\n\r\n    // https://stackoverflow.com/questions/6139107/programmatically-select-text-in-a-contenteditable-html-element/6150060#6150060\r\n    function selectElementContents(el: any) {\r\n        var range = document.createRange();\r\n        range.selectNodeContents(el);\r\n        var sel = window.getSelection();\r\n        sel!.removeAllRanges();\r\n        sel!.addRange(range);\r\n    }\r\n\r\n    function setTitle() {\r\n        let newTitle = document.getElementById(\"puzzleTitle\")!.innerText;\r\n        Globals.puzzle!.title = newTitle === \"(title)\" ? \"Untitled\" : newTitle;\r\n    }\r\n\r\n    function setAuthor() {\r\n        let newAuthor = document.getElementById(\"puzzleAuthor\")!.innerText;\r\n        Globals.puzzle!.author = newAuthor === \"(author)\" ? \"\" : newAuthor;\r\n    }\r\n\r\n    function setCopyright() {\r\n        let newCopyright = document.getElementById(\"puzzleCopyright\")!.innerText;\r\n        Globals.puzzle!.copyright = newCopyright === \"© copyright\" ? \"\" : newCopyright;\r\n    }\r\n\r\n    function setNotes() {\r\n        let newNotes = document.getElementById(\"puzzleNotes\")!.innerText;\r\n        Globals.puzzle!.notes = newNotes === \"(notes)\" ? \"\" : newNotes;\r\n    }\r\n\r\n    function generateQualityClassMap(grid: GridState): Map<string, QualityClass> {\r\n        let ret = new Map<string, QualityClass>();\r\n\r\n        let acrossWords = mapValues(grid.words).filter(w => w.direction === WordDirection.Across);\r\n        acrossWords.forEach(w => {\r\n            let squares = getSquaresForWord(grid, w);\r\n            if (isWordFull(squares)) {\r\n                let letters = getLettersFromSquares(squares);\r\n                let qc = Globals.qualityClasses ? Globals.qualityClasses!.get(letters) : QualityClass.Normal;\r\n                squares.forEach(sq => {\r\n                    if (sq.contentType === ContentType.Autofill)\r\n                        ret.set(squareKey(sq), qc || QualityClass.Iffy);\r\n                });\r\n            }\r\n        });\r\n\r\n        let downWords = mapValues(grid.words).filter(w => w.direction === WordDirection.Down);\r\n        downWords.forEach(w => {\r\n            let squares = getSquaresForWord(grid, w);\r\n            if (isWordFull(squares)) {\r\n                let letters = getLettersFromSquares(squares);\r\n                let qc = Globals.qualityClasses ? Globals.qualityClasses!.get(letters) : QualityClass.Normal;\r\n                squares.forEach(sq => {\r\n                    if (sq.contentType === ContentType.Autofill) {\r\n                        let curQc = ret.get(squareKey(sq)) || QualityClass.Normal;\r\n                        if (!qc || qc < curQc)\r\n                            ret.set(squareKey(sq), qc || QualityClass.Iffy);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n\r\n        return ret;\r\n    }\r\n\r\n    let puzzle = Globals.puzzle!;\r\n    let grid = Globals.hoverGrid ? Globals.hoverGrid! : getGrid();\r\n    let qualityClassMap = generateQualityClassMap(grid);\r\n\r\n    let squareElements = [];\r\n    for (let row = 0; row < grid.height; row++) {\r\n        for (let col = 0; col < grid.width; col++) {\r\n            let sqProps = getSquareProps(grid, row, col, selectedSquare, getSelectedWord());\r\n            squareElements.push(getSquareElement(sqProps));\r\n        }\r\n    }\r\n\r\n    let columnTemplateStyle = {\r\n        gridTemplateColumns: `repeat(${grid.width}, 1fr)`\r\n    } as React.CSSProperties;\r\n\r\n    return (\r\n        <>\r\n            <div className=\"puzzle-author-by\">&nbsp;</div>\r\n            <div id=\"puzzleTitle\" className=\"puzzle-title editable\" contentEditable={true} suppressContentEditableWarning={true}\r\n                onKeyDown={suppressEnterKey} onBlur={setTitle} onFocusCapture={handleFocus}>{puzzle.title || \"(title)\"}</div>\r\n            <div className=\"puzzle-author-by\">by&nbsp;</div>\r\n            <div id=\"puzzleAuthor\" className=\"puzzle-author editable\" contentEditable={true} suppressContentEditableWarning={true}\r\n                onKeyDown={suppressEnterKey} onBlur={setAuthor} onFocusCapture={handleFocus}>{puzzle.author || \"(author)\"}</div>\r\n            <div className=\"puzzle-author-by\">&nbsp;</div>\r\n            <div id=\"puzzleCopyright\" className=\"puzzle-copyright editable\" contentEditable={true} suppressContentEditableWarning={true}\r\n                onKeyDown={suppressEnterKey} onBlur={setCopyright} onFocusCapture={handleFocus}>{puzzle.copyright || \"© copyright\"}</div>\r\n            \r\n            <div id=\"Grid\" className=\"grid-container\" style={columnTemplateStyle}\r\n                onClick={handleClick} onKeyDown={handleKeyDown} tabIndex={0}>\r\n                {squareElements}\r\n            </div>\r\n\r\n            <div className=\"puzzle-notes-label\">Notes:</div>\r\n            <div id=\"puzzleNotes\" className=\"puzzle-notes editable\" contentEditable={true} suppressContentEditableWarning={true}\r\n                onKeyDown={suppressEnterKey} onBlur={setNotes} onFocusCapture={handleFocus}>{puzzle.notes || \"(notes)\"}</div>\r\n        </>\r\n    );\r\n}\r\n\r\nexport default Grid;\r\n","import { ContentType } from \"../models/ContentType\";\r\nimport { GridWord } from \"../models/GridWord\";\r\nimport { Puzzle } from \"../models/Puzzle\";\r\nimport { SquareType } from \"../models/SquareType\";\r\nimport { WordDirection } from \"../models/WordDirection\";\r\nimport { createNewGrid, populateWords } from \"./grid\";\r\nimport { deepClone, getGrid, mapValues, newPuzzle, wordKey } from \"./util\";\r\nimport Globals from '../lib/windowService';\r\n\r\n// https://code.google.com/archive/p/puz/wikis/FileFormat.wiki\r\n\r\nexport async function loadPuzFile(url: string): Promise<Puzzle | undefined> {\r\n    let response = await fetch(url);\r\n    let data: Blob = await response.blob();\r\n\r\n    return processPuzData(data);\r\n}\r\n\r\nexport async function processPuzData(data: Blob): Promise<Puzzle | undefined> {\r\n    let magicString = await data.slice(0x02, 0x0e).text();\r\n    if (magicString !== \"ACROSS&DOWN\\0\") return undefined;\r\n\r\n    let width = new Uint8Array(await data.slice(0x2c, 0x2d).arrayBuffer())[0];\r\n    let height = new Uint8Array(await data.slice(0x2d, 0x2e).arrayBuffer())[0];\r\n\r\n    let puzzle = newPuzzle();\r\n    let restOfFile = await blobToText(await data.slice(0x34, data.size));\r\n    let grid = createNewGrid(width, height);\r\n\r\n    let i = 0;\r\n    for (let row = 0; row < height; row++) {\r\n        for (let col = 0; col < width; col++) {\r\n            let curChar = restOfFile[i];\r\n            let square = grid.squares[row][col];\r\n            if (curChar === \".\")\r\n                square.type = SquareType.Black;\r\n            if (curChar === \"-\") {} // no data entered\r\n            if (curChar.match(/[A-Z]/)) {\r\n                square.content = curChar;\r\n                square.contentType = ContentType.User;\r\n            }\r\n            i++;\r\n        }\r\n    }\r\n    i *= 2; // skip over user progress\r\n\r\n    populateWords(grid);\r\n    \r\n    [puzzle.title, i] = getNextString(restOfFile, i);\r\n    [puzzle.author, i] = getNextString(restOfFile, i);\r\n    [puzzle.copyright, i] = getNextString(restOfFile, i);\r\n\r\n    let sortedWords = sortWordsForPuz(mapValues(grid.words));\r\n    sortedWords.forEach(word => {\r\n        let clue = \"\";\r\n        [clue, i] = getNextString(restOfFile, i);\r\n        let key = wordKey(word);\r\n        puzzle.clues.set(key, clue);\r\n    });\r\n\r\n    [puzzle.notes, i] = getNextString(restOfFile, i);\r\n\r\n    let rebusSquareMappings = new Map<string, number>();\r\n    let rebusValues = new Map<number, string>();\r\n\r\n    while (i < restOfFile.length) {\r\n        let sectionType = restOfFile.slice(i, i+4);\r\n        i += 4;\r\n        let dlI = 0x34 + i;\r\n        let dataLength = new Uint16Array(await data.slice(dlI, dlI+2).arrayBuffer())[0];\r\n        i += 2;\r\n        i += 2; // skip checksum\r\n\r\n        if (sectionType === \"GRBS\") { // rebus grid\r\n            let secI = 0x34 + i;\r\n            for (let row = 0; row < height; row++) {\r\n                for (let col = 0; col < width; col++) {\r\n                    let n = new Uint8Array(await data.slice(secI, secI + 1).arrayBuffer())[0];\r\n                    secI++;\r\n                    if (n > 0) {\r\n                        rebusSquareMappings.set(`${row},${col}`, n-1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (sectionType === \"RTBL\") { // rebus values\r\n            let valuesStr = restOfFile.slice(i, i + dataLength);\r\n            let valueStrs = valuesStr.split(\";\");\r\n            valueStrs.forEach(str => {\r\n                let tokens = str.split(\":\");\r\n                let n = +tokens[0].trim();\r\n                let val = tokens[1];\r\n                if (n > 0) rebusValues.set(n, val);\r\n            });\r\n        }\r\n        if (sectionType === \"GEXT\") { // extra flags\r\n            let secI = 0x34 + i;\r\n            for (let row = 0; row < height; row++) {\r\n                for (let col = 0; col < width; col++) {\r\n                    let n = new Uint8Array(await data.slice(secI, secI + 1).arrayBuffer())[0];\r\n                    secI++;\r\n                    if (n & 0x80) {\r\n                        grid.squares[row][col].isCircled = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        i += dataLength + 1;\r\n    }\r\n\r\n    if (rebusSquareMappings.size > 0) {\r\n        rebusSquareMappings.forEach((v, k) => {\r\n            let tokens = k.split(\",\");\r\n            let square = grid.squares[+tokens[0]][+tokens[1]];\r\n            square.content = rebusValues.get(v)![0]; // TODO: Use full value when we have rebus support\r\n            square.contentType = ContentType.User;\r\n        });\r\n    }\r\n\r\n    Globals.activeGrid = grid;\r\n    return puzzle;\r\n}\r\n\r\nasync function blobToText(blob: Blob): Promise<string> {\r\n    let arr = Array.from(new Uint8Array(await blob.arrayBuffer()));\r\n    return arr.map(x => String.fromCharCode(x)).join(\"\");\r\n}\r\n\r\nfunction getNextString(data: string, i: number): [string, number] {\r\n    let ret = \"\";\r\n    while(data[i] !== \"\\0\") {\r\n        ret += data[i];\r\n        i++;\r\n    }\r\n    i++;\r\n    return [ret.trim(), i];\r\n}\r\n\r\nexport function generatePuzFile(puzzle: Puzzle): Blob {\r\n    let grid = getGrid();\r\n    let bytes = new Uint8Array(128_000);\r\n    insertString(bytes, \"ACROSS&DOWN\\0\", 0x02);\r\n    insertString(bytes, \"1.3\\0\", 0x18);\r\n\r\n    insertNumber(bytes, grid.width, 0x2c, 1);\r\n    insertNumber(bytes, grid.height, 0x2d, 1);\r\n    insertNumber(bytes, grid.words.size, 0x2e, 2);\r\n    insertNumber(bytes, 1, 0x30, 2);\r\n    insertNumber(bytes, 0, 0x32, 2);\r\n\r\n    let pos = 0x34;\r\n    let solutionPos = pos;\r\n    let areCircledSquares = false;\r\n    for (let row = 0; row < grid.height; row++) {\r\n        for (let col = 0; col < grid.width; col++) {\r\n            let sq = grid.squares[row][col];\r\n            let char = sq.type === SquareType.Black ? \".\" : sq.content ? sq.content : \" \";\r\n            insertString(bytes, char, pos);\r\n            pos++;\r\n\r\n            if (sq.isCircled) areCircledSquares = true;\r\n        }\r\n    }\r\n    let gridPos = pos;\r\n    for (let row = 0; row < grid.height; row++) {\r\n        for (let col = 0; col < grid.width; col++) {\r\n            let sq = grid.squares[row][col];\r\n            let char = sq.type === SquareType.Black ? \".\" : \"-\";\r\n            insertString(bytes, char, pos);\r\n            pos++;\r\n        }\r\n    }\r\n\r\n    let titlePos = pos;\r\n    insertString(bytes, puzzle.title + \"\\0\", pos);\r\n    pos += puzzle.title.length + 1;\r\n    let authorPos = pos;\r\n    insertString(bytes, puzzle.author + \"\\0\", pos);\r\n    pos += puzzle.author.length + 1;\r\n    let copyrightPos = pos;\r\n    insertString(bytes, puzzle.copyright + \"\\0\", pos);\r\n    pos += puzzle.copyright.length + 1;\r\n\r\n    let orderedClues = [] as string[];\r\n    let sortedWords = sortWordsForPuz(mapValues(grid.words));\r\n    sortedWords.forEach(word => {\r\n        let key = wordKey(word);\r\n        orderedClues.push(puzzle.clues.get(key)! || \"\");\r\n    });\r\n\r\n    let cluesPos = pos;\r\n    orderedClues.forEach(oc => {\r\n        insertString(bytes, oc + \"\\0\", pos);\r\n        pos += oc.length + 1;\r\n    });\r\n\r\n    insertString(bytes, puzzle.notes + \"\\0\", pos);\r\n    pos++;\r\n\r\n    if (areCircledSquares) {\r\n        let sectionSize = grid.width * grid.height;\r\n        insertString(bytes, \"GEXT\", pos);\r\n        pos += 4;\r\n        insertNumber(bytes, sectionSize, pos, 2);\r\n        pos += 2;\r\n        let checksumPos = pos;\r\n        pos += 2;\r\n        for (let row = 0; row < grid.height; row++) {\r\n            for (let col = 0; col < grid.width; col++) {\r\n                let sq = grid.squares[row][col];\r\n                insertNumber(bytes, sq.isCircled ? 0x80 : 0, pos, 1);\r\n                pos++;\r\n            }\r\n        }\r\n        insertString(bytes, \"\\0\", pos);\r\n        pos++;\r\n\r\n        let cksum = cksum_region(bytes, checksumPos + 2, sectionSize, 0);\r\n        insertNumber(bytes, cksum, checksumPos, 2);\r\n    }\r\n\r\n    let c_cib = cksum_region(bytes, 0x2c, 8, 0);\r\n    let cksum = c_cib;\r\n    let squaresTotal = grid.width*grid.height;\r\n    cksum = cksum_region(bytes, solutionPos, squaresTotal, cksum);\r\n    cksum = cksum_region(bytes, gridPos, squaresTotal, cksum);\r\n    if (puzzle.title.length > 0) cksum = cksum_region(bytes, titlePos, puzzle.title.length+1, cksum);\r\n    if (puzzle.author.length > 0) cksum = cksum_region(bytes, authorPos, puzzle.author.length+1, cksum);\r\n    if (puzzle.copyright.length > 0) cksum = cksum_region(bytes, copyrightPos, puzzle.copyright.length+1, cksum);\r\n    let cluePos = cluesPos;\r\n    for(let i = 0; i < orderedClues.length; i++) {\r\n        let clue = orderedClues[i];\r\n        cksum = cksum_region(bytes, cluePos, clue.length, cksum);\r\n        cluePos += clue.length+1;\r\n    }\r\n    insertNumber(bytes, c_cib, 0x0e, 2);\r\n    insertNumber(bytes, cksum, 0x00, 2);\r\n\r\n    let c_sol = cksum_region(bytes, solutionPos, squaresTotal, 0);\r\n    let c_grid = cksum_region(bytes, gridPos, squaresTotal, 0);\r\n    let c_part = 0;\r\n    if (puzzle.title.length > 0) c_part = cksum_region(bytes, titlePos, puzzle.title.length+1, c_part);\r\n    if (puzzle.author.length > 0) c_part= cksum_region(bytes, authorPos, puzzle.author.length+1, c_part);\r\n    if (puzzle.copyright.length > 0) c_part = cksum_region(bytes, copyrightPos, puzzle.copyright.length+1, c_part);\r\n    cluePos = cluesPos;\r\n    for(let i = 0; i < orderedClues.length; i++) {\r\n        let clue = orderedClues[i];\r\n        c_part = cksum_region(bytes, cluePos, clue.length, c_part);\r\n        cluePos += clue.length+1;\r\n    }\r\n    insertNumber(bytes, 0x49 ^ (c_cib & 0xFF), 0x10, 1);\r\n    insertNumber(bytes, 0x43 ^ (c_sol & 0xFF), 0x11, 1);\r\n    insertNumber(bytes, 0x48 ^ (c_grid & 0xFF), 0x12, 1);\r\n    insertNumber(bytes, 0x45 ^ (c_part & 0xFF), 0x13, 1);\r\n    insertNumber(bytes, 0x41 ^ ((c_cib & 0xFF00) >> 8), 0x14, 1);\r\n    insertNumber(bytes, 0x54 ^ ((c_sol & 0xFF00) >> 8), 0x15, 1);\r\n    insertNumber(bytes, 0x45 ^ ((c_grid & 0xFF00) >> 8), 0x16, 1);\r\n    insertNumber(bytes, 0x44 ^ ((c_part & 0xFF00) >> 8), 0x17, 1);\r\n\r\n    let finalArray = bytes.slice(0, pos);\r\n    return new Blob([finalArray], {type: \"application/octet-stream; charset=ISO-8859-1\"});\r\n}\r\n\r\n// http://www.keiranking.com/phil/\r\nfunction cksum_region(bytes: Uint8Array, startPos: number, len: number, cksum: number) {\r\n    for (let i = 0; i < len; i++) {\r\n        cksum = (cksum >> 1) | ((cksum & 1) << 15);\r\n        cksum = (cksum + bytes[startPos + i]) & 0xffff;\r\n    }\r\n    \r\n    return cksum; \r\n}\r\n\r\nfunction insertString(bytes: Uint8Array, str: string, pos: number) {\r\n    for (let i = 0; i < str.length; i++) {\r\n        bytes[pos] = str[i].charCodeAt(0);\r\n        pos++;\r\n    }\r\n}\r\n\r\nfunction insertNumber(bytes: Uint8Array, n: number, pos: number, size: number) {\r\n    for (var index = size-1; index >= 0; --index) {\r\n      bytes[pos] = n % 256;\r\n      n = n >> 8;\r\n      pos++;\r\n    }\r\n}\r\n\r\nfunction sortWordsForPuz(words: GridWord[]): GridWord[] {\r\n    let sortedWords = (deepClone(words) as GridWord[]).sort((a, b) => {\r\n        if (a.start[0] !== b.start[0]) return a.start[0] - b.start[0];\r\n        if (a.start[1] !== b.start[1]) return a.start[1] - b.start[1];\r\n        return a.direction === WordDirection.Across ? -1 : 1;\r\n    });\r\n    return sortedWords;\r\n}\r\n","import React, { createRef, useContext, useRef } from 'react';\r\nimport \"./Menu.scss\";\r\nimport { MenuProps } from './MenuProps';\r\nimport { AppContext } from '../../AppContext';\r\nimport { processPuzData } from '../../lib/puzFiles';\r\n\r\nfunction Menu(props: MenuProps) {\r\n    const appContext = useContext(AppContext);\r\n    const sizeRefs = useRef([createRef(), createRef()] as any[]);\r\n\r\n    function handleViewChange(event: any) {\r\n        let target = event.target;\r\n        let newView = target.attributes[\"data-view-id\"].value;\r\n        \r\n        appContext.switchActiveView(newView);\r\n    }\r\n\r\n    function handleNewPuzzle() {\r\n        if (!window.confirm(\"Are you sure you want to start a new puzzle?\")) return;\r\n\r\n        let newWidth = +sizeRefs.current[0].current.value;\r\n        let newHeight = +sizeRefs.current[1].current.value;\r\n\r\n        appContext.createNewPuzzle(newWidth, newHeight);\r\n    }\r\n\r\n    function handleLoadPuz() {\r\n        document.getElementById(\"open-puzzle-input\")!.click();\r\n    }\r\n\r\n    function handleExportPuz() {\r\n        appContext.exportPuz();\r\n    }\r\n\r\n    function handleFocus(event: any) {\r\n        event.target.select();\r\n    }\r\n\r\n    function onFileUpload(event: any) {\r\n        let file = event.target.files[0];\r\n        event.target.value = null;\r\n\r\n        processPuzData(file).then(puzzle => {\r\n            if (puzzle) {\r\n                appContext.setPuzzle(puzzle);\r\n            }\r\n        });\r\n    }\r\n\r\n    return (\r\n        <div id=\"Menu\">\r\n            <input id=\"open-puzzle-input\" hidden type=\"file\" accept=\".puz\" onChange={onFileUpload} />\r\n\r\n            <div className=\"site-title\">CrossHatch</div>\r\n\r\n            <div className=\"menu-label\">View: </div>\r\n            <div className=\"btn-group\" role=\"group\" id=\"view-change-group\">\r\n                <button type=\"button\" data-view-id=\"Clues\"\r\n                    className={\"btn\" + (props.openView === \"Clues\" ? \" btn-primary\" : \" btn-secondary\")}\r\n                    onClick={handleViewChange}>\r\n                    Clues\r\n                </button>\r\n                <button type=\"button\" data-view-id=\"Fill\"\r\n                    className={\"btn\" + (props.openView === \"Fill\" ? \" btn-primary\" : \" btn-secondary\")}\r\n                    onClick={handleViewChange}>\r\n                    Fill\r\n                </button>\r\n            </div>\r\n            \r\n            <div className=\"new-grid-group\">\r\n                <div className=\"btn btn-primary\" onClick={handleNewPuzzle}>New Puzzle</div>\r\n                <input type=\"text\" className=\"form-control\" defaultValue={props.gridWidth} onFocus={handleFocus}\r\n                    ref={sizeRefs.current[0]}></input>\r\n                <div className=\"menu-gridsize-sep\"><div style={{height:\"6px\", float:\"none\"}}></div>x</div>\r\n                <input type=\"text\" className=\"form-control\" defaultValue={props.gridHeight} onFocus={handleFocus}\r\n                    ref={sizeRefs.current[1]}></input>\r\n            </div>\r\n            \r\n            <div id=\"loadPuz\" className=\"btn btn-primary menu-button\" onClick={handleLoadPuz}>Load .puz</div>\r\n            <div id=\"exportPuz\" className=\"btn btn-primary menu-button\" onClick={handleExportPuz}>Export .puz</div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Menu;\r\n","import React, { useEffect, useState } from 'react';\r\nimport { AppContext } from './AppContext';\r\nimport { AppProps } from './AppProps';\r\nimport CluesView from './components/CluesView/CluesView';\r\nimport FillView from './components/FillView/FillView';\r\nimport Grid from './components/Grid/Grid';\r\nimport Menu from './components/Menu/Menu';\r\nimport Globals from './lib/windowService';\r\nimport \"./App.scss\";\r\nimport { Puzzle } from './models/Puzzle';\r\nimport { getGrid, initializeSessionGlobals, newPuzzle } from './lib/util';\r\nimport { generatePuzFile } from './lib/puzFiles';\r\nimport { SymmetryType } from './models/SymmetryType';\r\nimport { clearFill, createNewGrid } from './lib/grid';\r\nimport { WordDirection } from './models/WordDirection';\r\nimport { FillStatus } from './models/FillStatus';\r\n\r\nfunction App(props: AppProps) {\r\n  const [activeView, setActiveView] = useState(props.activeView);\r\n  const [gridWidth, setGridWidth] = useState(7);\r\n  const [gridHeight, setGridHeight] = useState(7);\r\n  const [updateSemaphore, setUpdateSemaphore] = useState(0);\r\n  const [appState, setAppState] = useState(getAppContext());\r\n\r\n  useEffect(() => {\r\n    setAppState(getAppContext());\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [updateSemaphore]);\r\n\r\n  function getAppContext() {\r\n    return { \r\n      triggerUpdate: triggerUpdate,\r\n      switchActiveView: switchActiveView,\r\n      setPuzzle: setPuzzle,\r\n      createNewPuzzle: createNewPuzzle,\r\n      exportPuz: exportPuz,\r\n    }\r\n  }\r\n\r\n  function triggerUpdate() {\r\n    setUpdateSemaphore(updateSemaphore + 1);\r\n  }\r\n\r\n  function switchActiveView(newView: string) {\r\n    setActiveView(newView);\r\n  }\r\n\r\n  function createNewPuzzle(width: number, height: number) {\r\n    initializeGlobals(undefined, width, height);\r\n    triggerUpdate();\r\n  }\r\n\r\n  function setPuzzle(puzzle: Puzzle) {\r\n    let grid = getGrid();\r\n    initializeGlobals(puzzle, grid.width, grid.height);\r\n    triggerUpdate();\r\n  }\r\n\r\n  function exportPuz() {\r\n    let puzzle = Globals.puzzle!;\r\n    let blob = generatePuzFile(puzzle);\r\n    let filename = (puzzle.title || \"Untitled\")+\".puz\";\r\n    let file = new File([blob], filename);\r\n    const url= window.URL.createObjectURL(file);\r\n    let puzzleLink = document.getElementById(\"download-puzzle-link\");\r\n    puzzleLink!.setAttribute(\"href\", url);\r\n    puzzleLink!.setAttribute(\"download\", filename);\r\n    puzzleLink!.click();\r\n  }\r\n\r\n  function initializeGlobals(puzzle?: Puzzle, width?: number, height?: number) {\r\n    let isNewPuzzle = !!puzzle;\r\n    Globals.puzzle = puzzle || newPuzzle();\r\n    if (width === undefined) width = gridWidth;\r\n    if (height === undefined) height = gridHeight;\r\n    if (!Globals.activeGrid || !isNewPuzzle)\r\n      Globals.activeGrid = createNewGrid(width, height);\r\n    Globals.hoverGrid = undefined;\r\n    Globals.selectedWordKey = undefined;\r\n    Globals.selectedWordDir = WordDirection.Across;\r\n    if (!Globals.gridSymmetry) Globals.gridSymmetry = SymmetryType.Rotate180;\r\n    if (Globals.useManualHeuristics === undefined) Globals.useManualHeuristics = true;\r\n    if (Globals.maxIffyLength === undefined) Globals.maxIffyLength = 0;\r\n    Globals.selectedWordNode = undefined;\r\n    Globals.curChainId = 1;\r\n    if (Globals.wordLists === undefined) Globals.wordLists = [];\r\n    Globals.fillStatus = Globals.wordList !== undefined ? FillStatus.Ready : FillStatus.NoWordList;\r\n\r\n    initializeSessionGlobals();\r\n    clearFill(Globals.activeGrid!);\r\n\r\n    setGridWidth(width);\r\n    setGridHeight(height);\r\n  }\r\n\r\n  if (!Globals.puzzle) {\r\n    initializeGlobals();\r\n    triggerUpdate();\r\n  }\r\n\r\n  return (\r\n    <AppContext.Provider value={appState}>\r\n      <a id=\"download-puzzle-link\" href=\"http://www.example.com\" style={{display: \"none\"}}>stuff</a>\r\n\r\n      <Menu gridHeight={gridHeight} gridWidth={gridWidth} openView={activeView}></Menu>\r\n\r\n      <div className=\"left-panel\">\r\n        {activeView === \"Clues\" && \r\n            <CluesView updateSemaphore={updateSemaphore}></CluesView>\r\n        }\r\n        {activeView === \"Fill\" && \r\n            <FillView></FillView>\r\n        }\r\n      </div>\r\n      \r\n      <div className=\"right-panel\">\r\n        <Grid></Grid>\r\n      </div>\r\n    </AppContext.Provider>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\nimport 'bootstrap/dist/css/bootstrap.css';\r\n\r\n// import { loadWordListFromLocalhost } from './lib/wordList';\r\n// import Globals from './lib/windowService';\r\n// import { FillStatus } from './models/FillStatus';\r\n// loadWordListFromLocalhost(\"http://localhost/classifier/mainBrodaEntries.txt\").then(() => {\r\n//   Globals.fillStatus = FillStatus.Ready;\r\n// });\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App activeView=\"Fill\" />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n"],"sourceRoot":""}