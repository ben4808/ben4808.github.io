{"version":3,"sources":["models/SquareType.ts","models/WordDirection.ts","AppContext.ts","lib/windowService.tsx","models/SymmetryType.ts","models/ContentType.ts","models/QualityClass.ts","lib/wordList.ts","lib/entryCandidates.ts","lib/util.ts","lib/section.ts","lib/insertEntry.ts","lib/priorityQueue.ts","models/FillStatus.ts","lib/fill.ts","lib/grid.ts","components/CluesView/CluesView.tsx","components/FillView/FillView.tsx","lib/useInterval.ts","components/Square/Square.tsx","components/Grid/Grid.tsx","lib/puzFiles.ts","components/Menu/Menu.tsx","App.tsx","index.tsx"],"names":["SquareType","WordDirection","AppContext","React","createContext","triggerUpdate","switchActiveView","_","setPuzzle","createNewPuzzle","w","h","exportPuz","window","Globals","SymmetryType","ContentType","QualityClass","filename","data","a","text","lines","split","indexWordList","words","parseWordList","wordList","wordCount","length","qcMap","qualityClasses","Map","forEach","line","tokens","trim","match","score","qualityClass","Lively","Normal","Crosswordese","word","has","push","set","queryIndexedWordList","pattern","wl","letters","i","buckets","oneVal","charCodeAt","pos1","pos2","val1","val2","twoVal","filter","entries","existingList","ch1","ch2","populateAndScoreEntryCandidates","node","isForManualFill","wordKey","fillWord","iffyWordKey","populateNoHeuristicEntryCandidates","anchorSquareKeys","anchorInfo","populateFillWordAnchors","getSquaresForWord","startGrid","anchorCombosLeft","eligibleCandidates","heuristicsLevel","processAnchorCombo","getEligibleCandidates","ec","entryCandidates","sort","b","dontRecalc","undefined","getLettersFromSquares","deepClone","get","entry","getWordScore","isViable","hasBeenChained","wasChainFailure","crossScore","minCrossScore","squares","calculatedSquares","anchorKeyCounts","sq","count","squareKey","viableLetters","constraintLetterCount","combos","constraintLetters","map","sqKey","find","content","fullAlphabet","comboScores","letter1","letter2","letterFrequencies","Math","random","generateAnchorCombos","grid","combo","pop","fillWordKey","wordSquares","patternWithAnchor","insertLetterIntoPattern","isWordFull","crossKeys","crossCrossKeys","getAllCrosses","cross","crossCross","size","manualIffyKey","getWordAtSquare","row","col","otherDir","direction","crossSquares","csq","delete","getFilteredEntries","usedWords","processEntry","maxIffyLength","ck","wordLength","wordScore","topCrossScore","topMinCrossScore","calculateEntryCandidateScore","distillIndex","includes","foundCountReduction","wKey","wordPattern","filteredEntries","anchorComboCount","newPattern","fe","reduce","newMatrix","Array","fill","letterMatrixToLetterList","existingCounts","iffyEntry","iffyWord","iffySquares","isq","idx","calSq","substring","anchorPattern","constraintCounts","x","curPatterns","lowestCount","index","newCurPatterns","ltr","broadenAnchorPatterns","newLetter","findIndex","updateSectionFilters","sections","getGrid","sec","candidates","can","sqKeys","mapKeys","isFilteredOut","gridSq","getSquareAtKey","canSq","isUserOrWordFilled","insertSectionCandidateIntoGrid","candidate","contentType","ChosenSection","newGrid","section","sectionId","foundDiscrepancy","candidateSq","HoverChosenSection","Autofill","forAllGridSquares","newSq","key","neighboringCrosses","generateConstraintInfoForSquares","userFilledSectionCandidates","sectionCandidateKey","generateGridSections","usedSquares","nextSectionId","fullSection","makeNewSection","isBlackSquare","isOpenSquare","newSection","iterateSection","openSquareCount","getNeighboringSquares","neighbor","Across","Down","dir","wsq","id","stackWords","stackedNeighbors","otherKey","otherWord","isAcross","abs","start","min","end","max","sk","crossKey","wordOrder","calculateSectionOrder","mapValues","secOrder","calculateWordOrder","wk","connections","wordsSort","iterateWordGroup","group","centerIndex","floor","rowOrCol","slice","acrossSortedStackWords","downSortedStackWords","longestStack","stack","curGroup","prevRowOrCol","j","newWord","newRowOrCol","neighbors","n","ret","nClear","sClear","height","wClear","eClear","width","calculateSectionCandidateScore","total","foundIffy","natoAlphabet","k","join","comboPermsQueue","comboPermsUsed","getSelectedSectionCandidates","selectedSectionCandidateKeys","scKey","getSectionWithCandidate","sc","getSectionsWithWord","processAndInsertChosenEntry","chosenEntry","crosses","HoverChosenWord","ChosenWord","newSquares","getSectionCandidatesFromKeys","removeNonmatchingSectionCandidates","endGrid","FillStatus","fillSectionWord","getSection","fillQueue","newFillQueue","heap","left","right","hasRight","swap","temp","isEmpty","peek","value","insert","item","prio","p","tmp","current","largerChild","priorityQueue","populateSeedNodes","needsNewPriority","shouldBeDeleted","calculateNodePriority","isChainNode","chainId","curChainId","activeGrid","selectWordToFill","topScore","c","pow","roll","runningTotal","chooseEntryFromCandidates","processSectionNode","sectionString","getSectionString","newSecCandidateFound","newCandidate","getEntryAtWordKey","newSectionCandidate","invalidateChainNode","newNode","makeNewNode","depth","nextFillWord","curSections","nextSections","cs","ns","selectedWordNode","parent","prevCandidate","backtracks","chainBaseNode","chainIffyCandidates","chainGoodCandidates","curNode","isSectionBase","situationScore","selectedSectionIds","activeSectionId","activeSection","connectionIds","selectedCandidate","candidateCounts","comboKey","perm","toString","shift","defaultCombo","allOnes","foundNew","newPerm","newPermKey","getNewPermutations","wasSuccess","viableLetterCounts","Iffy","populateWords","processSquare","currentWord","number","nextSq","currentNumber","isAboveBlocked","isBelowBlocked","isLeftBlocked","isRightBlocked","isUnchecked","isUncheckedStart","isCheckedStart","numberizeGrid","updateGridConstraintInfo","wordKeys","concat","isWordEmpty","entryOptions","curViableMatrix","list","matrix","letterListToLetterMatrix","newViableMatrix","arr","newVal","setLettersArrayVal","createNewGrid","type","White","isCircled","getSymmetrySquares","initSquare","r","gridSymmetry","Rotate180","Rotate90","MirrorHorizontal","MirrorVertical","MirrorNWSE","MirrorNESW","eraseGridSquare","otherDirWord","otherDirSquares","User","isInSection","clearFill","eraseSectionCandidateFromGrid","getSelectedSectionCandidatesWithSquare","fillStatus","Ready","NoWordList","isUserFilled","updateManualEntryCandidates","selectedWordKey","useManualHeuristics","obj","Date","getTime","from","Object","keys","newObj","compareTuples","first","second","Black","doesWordContainSquare","func","newPuzzle","title","author","copyright","clues","notes","getSelectedWord","values","sck","initializeSessionGlobals","hoverSectionId","String","fromCharCode","CluesView","props","useState","initClueProps","clueProps","setClueProps","selectedKey","setSelectedKey","textareasRef","useRef","puzzle","prop","clue","isOpenForEditing","handleClueClick","event","target","classList","parentElement","targetKey","attributes","refIndex","textareaEl","newClueProps","propToToggle","style","display","focus","handleKeyDown","toUpperCase","newValue","targetProp","applyClueChange","handleFocus","select","renderCluesContainer","clueList","className","createRef","data-key","onClick","data-ref-index","defaultValue","onKeyDown","onFocus","ref","useEffect","updateSemaphore","acrossClues","downClues","FillView","appContext","useContext","showSectionCandidates","setShowSectionCandidates","isWordListLoading","setIsWordListLoading","isFillRunning","setIsFillRunning","setFillStatus","newStatus","getManualEntryNode","isHover","insertEntryIntoGrid","getManualSectionNode","handleEntryCandidateClick","hoverGrid","handleEntryCandidateHover","handleSectionClick","handleSectionCheckClick","handleSectionHover","handleSectionCandidateClick","eraseSc","candidateKey","handleSectionCandidateHover","callback","delay","savedCallback","setInterval","clearInterval","useInterval","Complete","selectedSymmetry","symmetryOptions","t","isNaN","Number","fillStatusStr","status","Running","getFillStatusString","wordLists","isNoEntryCandidates","selectedScKey","sectionCandidates","selectedEntry","selectedMaxIffyLength","hidden","accept","onChange","file","files","setTimeout","processWordListData","name","then","checked","htmlFor","selectedIndex","getSymmetryTypeString","confirm","document","getElementById","click","gridTemplateColumns","cursor","onMouseOut","data-word","data-iffykey","onMouseOver","toFixed","data-id","getLongest","getLongestStackWord","data-candidate-key","between","input","Square","isSelected","isInSelectedWord","isInSelectedSection","constraintSum","data-row","data-col","NotAThing","getSquareElement","Grid","selectedSquare","setSelectedSquare","advanceCursor","selSq","isSquareSelected","selectedWordDir","newSelSq","setSelWordAtSelSquare","isSquareInSection","newSelSquare","getSquareProps","selectedWord","square","qualityClassMap","suppressEnterKey","preventDefault","el","range","createRange","selectNodeContents","sel","getSelection","removeAllRanges","addRange","selectElementContents","qc","curQc","generateQualityClassMap","squareElements","sqProps","columnTemplateStyle","contentEditable","suppressContentEditableWarning","onBlur","newTitle","innerText","onFocusCapture","newAuthor","newCopyright","newDirection","uncheckedSquareDir","getUncheckedSquareDir","letterChanged","blackSquareChanged","backupCursor","res","newSquareType","tabIndex","newNotes","processPuzData","Uint8Array","arrayBuffer","blobToText","restOfFile","curChar","getNextString","sortWordsForPuz","rebusSquareMappings","rebusValues","sectionType","dlI","Uint16Array","dataLength","secI","valuesStr","str","val","v","blob","cksum_region","bytes","startPos","len","cksum","insertString","pos","insertNumber","Menu","sizeRefs","handleViewChange","newView","role","data-view-id","openView","newWidth","newHeight","gridWidth","float","gridHeight","App","activeView","setActiveView","setGridWidth","setGridHeight","setUpdateSemaphore","getAppContext","appState","setAppState","initializeGlobals","solutionPos","areCircledSquares","char","gridPos","titlePos","authorPos","copyrightPos","orderedClues","cluesPos","oc","sectionSize","checksumPos","c_cib","squaresTotal","cluePos","c_sol","c_grid","c_part","finalArray","Blob","generatePuzFile","File","url","URL","createObjectURL","puzzleLink","setAttribute","isNewPuzzle","Provider","href","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.3ed88824.chunk.js","sourcesContent":["export enum SquareType {\r\n    White,\r\n    Black,\r\n    //Blank,\r\n}\r\n","export enum WordDirection {\r\n    Across,\r\n    Down,\r\n}\r\n","import React from \"react\";\r\nimport { Puzzle } from \"./models/Puzzle\";\r\n\r\nexport const AppContext = React.createContext({\r\n    triggerUpdate: () => {},\r\n    switchActiveView: (_: string) => {},\r\n    setPuzzle: (_: Puzzle) => {},\r\n    createNewPuzzle: (w: number, h: number) => {},\r\n    exportPuz: () => {},\r\n  });\r\n  ","import { GlobalsObj } from \"../models/GlobalsObj\";\r\n\r\ndeclare const window: any;\r\nwindow.Globals = {} as GlobalsObj;\r\nexport default window.Globals as GlobalsObj;\r\n","export enum SymmetryType {\r\n    None,\r\n    Rotate180,\r\n    Rotate90,\r\n    MirrorHorizontal,\r\n    MirrorVertical,\r\n    MirrorNWSE,\r\n    MirrorNESW,\r\n}\r\n","export enum ContentType {\r\n    User,\r\n    ChosenWord,\r\n    HoverChosenWord,\r\n    ChosenSection,\r\n    HoverChosenSection,\r\n    Autofill,\r\n}\r\n","export enum QualityClass {\r\n    NotAThing,\r\n    Iffy,\r\n    Crosswordese,\r\n    Normal,\r\n    Lively,\r\n}\r\n","import { IndexedWordList } from \"../models/IndexedWordList\";\r\nimport { QualityClass } from \"../models/QualityClass\";\r\nimport { WordList } from \"../models/WordList\";\r\nimport Globals from './windowService';\r\n\r\nexport async function processWordListData(filename: string, data: Blob): Promise<WordList | undefined> {\r\n    let lines = (await data.text()).split(\"\\n\");\r\n    let words = parseWordList(lines);\r\n    indexWordList(words, Globals.wordList);\r\n\r\n    return {\r\n        filename: filename,\r\n        wordCount: words.length,\r\n    } as WordList;\r\n}\r\n\r\nexport async function loadWordListFromLocalhost(url: string) {\r\n    var response = await fetch(url);\r\n    const lines = (await response.text()).split('\\n');\r\n    let words = parseWordList(lines);\r\n    indexWordList(words, Globals.wordList);\r\n    let filenameTokens = url.split(\"/\");\r\n    let filename = filenameTokens[filenameTokens.length - 1];\r\n\r\n    Globals.wordLists = [];\r\n    Globals.wordLists!.push({\r\n        filename: filename,\r\n        wordCount: words.length,\r\n    });\r\n\r\n    console.log(\"Word List loaded\");\r\n}\r\n\r\nfunction parseWordList(lines: string[]): string[] {\r\n    let qcMap = Globals.qualityClasses || new Map<string, QualityClass>();\r\n    let words = [] as string[];\r\n\r\n    lines.forEach(line => {\r\n        let tokens = line.trim().split(\";\");\r\n        if (tokens.length > 2) return;\r\n        if (!tokens[0].match(/^[A-Z]+$/)) return;\r\n\r\n        let score = tokens.length === 2 ? +tokens[1] : 50;\r\n        let qualityClass = score >= 100 ? QualityClass.Lively :\r\n                           score >= 50 ? QualityClass.Normal :\r\n                           QualityClass.Crosswordese;\r\n        let word = tokens[0];\r\n        if (word.length >= 2 && word.length <= 15) {\r\n            if (!qcMap.has(word)) words.push(word);\r\n            qcMap.set(word, qualityClass);\r\n        }\r\n    });\r\n\r\n    Globals.qualityClasses = qcMap;\r\n\r\n    return words;\r\n}\r\n\r\nexport function queryIndexedWordList(pattern: string): string[] {\r\n    let wl = Globals.wordList!;\r\n    let words = [] as string[];\r\n    if (pattern.length > 15) return words;\r\n    let letters = [] as [number, string][];\r\n    let length = pattern.length;\r\n    for (let i = 0; i < pattern.length; i++) {\r\n        if (pattern[i] !== \"-\") {\r\n            letters.push([i+1, pattern[i]]);\r\n        }\r\n    }\r\n\r\n    if (letters.length === 1) {\r\n        words = wl.buckets.oneVal[length-2][letters[0][0]-1][letters[0][1].charCodeAt(0)-65];\r\n    }\r\n    else if (letters.length === pattern.length) {\r\n        words = Globals.qualityClasses?.has(pattern) ? [pattern] : [];\r\n    }\r\n    else if (letters.length > 1) {\r\n        let pos1 = letters[0][0];\r\n        let pos2 = letters[1][0];\r\n        let val1 = letters[0][1];\r\n        let val2 = letters[1][1];\r\n        words = wl.buckets.twoVal[length-2][pos1-1][pos2-(pos1+1)][val1.charCodeAt(0)-65][val2.charCodeAt(0)-65];\r\n\r\n        for (let i = 2; i < letters.length; i++) {\r\n            words = words.filter(w => w[letters[i][0]-1] === letters[i][1]);\r\n        }\r\n    }\r\n\r\n    return words;\r\n}\r\n\r\nfunction indexWordList(entries: string[], existingList?: IndexedWordList) {\r\n    let buckets = existingList ? existingList.buckets : {\r\n        oneVal: [] as any[],\r\n        twoVal: [] as any[],\r\n    };\r\n\r\n    for (let length = 2; length <= 15; length++) {\r\n        buckets.oneVal.push([] as any[]);\r\n        for (let pos1 = 1; pos1 <= length; pos1++) {\r\n            buckets.oneVal[length-2].push([] as any[]);\r\n            for (let ch1 = 65; ch1 <= 90; ch1++) {\r\n                buckets.oneVal[length-2][pos1-1].push([] as string[]);\r\n            }\r\n        }\r\n    }\r\n\r\n    for (let length = 2; length <= 15; length++) {\r\n        buckets.twoVal.push([] as any[]);\r\n        for (let pos1 = 1; pos1 <= length-1; pos1++) {\r\n            buckets.twoVal[length-2].push([] as any[]);\r\n            for (let pos2 = pos1+1; pos2 <= length; pos2++) {\r\n                buckets.twoVal[length-2][pos1-1].push([] as any[]);\r\n                for (let ch1 = 65; ch1 <= 90; ch1++) {\r\n                    buckets.twoVal[length-2][pos1-1][pos2-(pos1+1)].push([] as any[]);\r\n                    for (let ch2 = 65; ch2 <= 90; ch2++) {\r\n                        buckets.twoVal[length-2][pos1-1][pos2-(pos1+1)][ch1-65].push([] as string[]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    entries.forEach(word => {\r\n        // 1-position entries\r\n        for (let pos1 = 1; pos1 <= word.length; pos1++) {\r\n            buckets.oneVal[word.length-2][pos1-1][word[pos1-1].charCodeAt(0)-65].push(word);\r\n        }\r\n\r\n        // 2-position entries\r\n        for (let pos1 = 1; pos1 < word.length; pos1++) {\r\n            for (let pos2 = pos1 + 1; pos2 <= word.length; pos2++) {\r\n                buckets.twoVal[word.length-2][pos1-1][pos2-(pos1+1)][word[pos1-1].charCodeAt(0)-65][word[pos2-1].charCodeAt(0)-65].push(word);\r\n            }\r\n        }\r\n    });\r\n\r\n    Globals.wordList = { buckets: buckets } as IndexedWordList;\r\n}\r\n","import { EntryCandidate } from \"../models/EntryCandidate\";\r\nimport { FillNode } from \"../models/FillNode\";\r\nimport { GridSquare } from \"../models/GridSquare\";\r\nimport { getAllCrosses, getEligibleCandidates, getWordScore } from \"./fill\";\r\nimport { getLettersFromSquares } from \"./grid\";\r\nimport { constraintLetterCount, deepClone, fullAlphabet, getSquaresForWord, getWordAtSquare,\r\n    isWordFull, letterMatrixToLetterList, otherDir, squareKey, sum, wordKey, wordLength } from \"./util\";\r\nimport { queryIndexedWordList } from \"./wordList\";\r\nimport Globals from './windowService';\r\n\r\n// returns false if no viable candidates were found or iffy was set\r\nexport function populateAndScoreEntryCandidates(node: FillNode, isForManualFill: boolean): boolean {\r\n    if (isForManualFill && wordKey(node.fillWord!) === node.iffyWordKey) {\r\n        populateNoHeuristicEntryCandidates(node);\r\n        return true;\r\n    }\r\n\r\n    if (node.anchorSquareKeys.length === 0) {\r\n        let word = node.fillWord!;\r\n        let squares = getSquaresForWord(node.startGrid, word);\r\n        let anchorInfo = populateFillWordAnchors(squares);\r\n        node.anchorCombosLeft = anchorInfo.anchorCombosLeft;\r\n        node.anchorSquareKeys = anchorInfo.anchorSquareKeys;\r\n    }\r\n\r\n    let eligibleCandidates = [] as EntryCandidate[];\r\n    let heuristicsLevel = node.anchorCombosLeft.length > 100 ? 1 : node.anchorCombosLeft.length > 25 ? 2 : 3;\r\n\r\n    while(true) {\r\n        processAnchorCombo(node, isForManualFill, heuristicsLevel);\r\n        eligibleCandidates = getEligibleCandidates(node);\r\n        if (node.anchorCombosLeft.length === 0) break;\r\n        if (eligibleCandidates.filter(ec => !ec.iffyWordKey).length > (isForManualFill ? 100 : 0)) break;\r\n    }\r\n\r\n    node.entryCandidates.sort((a, b) => b.score! - a.score!);\r\n    return true;\r\n}\r\n\r\nexport function populateNoHeuristicEntryCandidates(node: FillNode, dontRecalc?: boolean) {\r\n    if (dontRecalc === undefined) dontRecalc = false;\r\n    if (node.entryCandidates.length > 0 && dontRecalc) return;\r\n\r\n    let word = node.fillWord!;\r\n    let squares = deepClone(getSquaresForWord(node.startGrid, word)) as GridSquare[];\r\n    let pattern = getLettersFromSquares(squares);\r\n    let entries = queryIndexedWordList(pattern).sort((a, b) => Globals.qualityClasses!.get(b)! - Globals.qualityClasses!.get(a)!);\r\n\r\n    node.entryCandidates = [];\r\n    entries.forEach(entry => {\r\n        node.entryCandidates.push({\r\n            word: entry,\r\n            score: getWordScore(entry),\r\n            isViable: true,\r\n            hasBeenChained: false,\r\n            wasChainFailure: false,\r\n            crossScore: 0,\r\n            minCrossScore: 0,\r\n        } as EntryCandidate);\r\n    });\r\n}\r\n\r\nfunction populateFillWordAnchors(squares: GridSquare[], calculatedSquares?: Map<string, string[]>):\r\n    { anchorSquareKeys: string[], anchorCombosLeft: [string, string][] } {\r\n    let anchorKeyCounts = [] as [string, number][];\r\n\r\n    squares.forEach(sq => {\r\n        let count = (calculatedSquares && calculatedSquares.has(squareKey(sq))) ? \r\n            calculatedSquares!.get(squareKey(sq))!.length : constraintLetterCount(sq);\r\n        if (count === 0) return; // don't anchor iffy\r\n\r\n        if (anchorKeyCounts.length < 2) {\r\n            anchorKeyCounts.push([squareKey(sq), count]);\r\n            anchorKeyCounts.sort((a, b) => a[1] - b[1]);\r\n            return;\r\n        }\r\n\r\n        if (count < anchorKeyCounts[1][1]) {\r\n            anchorKeyCounts[1] = [squareKey(sq), count];\r\n            anchorKeyCounts.sort((a, b) => a[1] - b[1]);\r\n        }\r\n    });\r\n\r\n    if (anchorKeyCounts.length < 2) {\r\n        return {\r\n            anchorSquareKeys: [],\r\n            anchorCombosLeft: [],\r\n        };\r\n    }\r\n\r\n    let anchorSquareKeys = [anchorKeyCounts[0][0], anchorKeyCounts[1][0]];\r\n    let combos = generateAnchorCombos(squares, anchorSquareKeys, calculatedSquares);\r\n\r\n    return {\r\n        anchorSquareKeys: anchorSquareKeys,\r\n        anchorCombosLeft: combos,\r\n    };\r\n}\r\n\r\nconst letterFrequencies = {\r\n    \"A\": 8.2, \"B\": 1.5, \"C\": 2.8, \"D\": 4.3,\r\n    \"E\": 13, \"F\": 2.2, \"G\": 2, \"H\": 6.1,\r\n    \"I\": 7, \"J\": 0.15, \"K\": 0.77, \"L\": 4,\r\n    \"M\": 2.4, \"N\": 6.7, \"O\": 7.5, \"P\": 1.9,\r\n    \"Q\": 0.095, \"R\": 6, \"S\": 6.3, \"T\": 9.1,\r\n    \"U\": 2.8, \"V\": 0.98, \"W\": 2.4, \"X\": 0.15,\r\n    \"Y\": 2, \"Z\": 0.074,\r\n} as any;\r\n\r\nfunction generateAnchorCombos(squares: GridSquare[], anchorSquareKeys: string[], \r\n    calculatedSquares?: Map<string, string[]>): [string, string][] {\r\n    let constraintLetters = anchorSquareKeys\r\n        .map(sqKey => squares.find(sq => squareKey(sq) === sqKey)!)\r\n        .map(sq => sq.content ? [sq.content!] : (calculatedSquares && calculatedSquares.has(squareKey(sq))) ? \r\n        calculatedSquares!.get(squareKey(sq))! : sq.viableLetters || fullAlphabet);\r\n\r\n    let combos = [] as [string, string][];\r\n    let comboScores = new Map<string, number>();\r\n    for (var letter1 of constraintLetters[0]) {\r\n        for (var letter2 of constraintLetters[1]) {\r\n            combos.push([letter1, letter2]);\r\n            comboScores.set(`[${letter1},${letter2}]`, letterFrequencies[letter1] * letterFrequencies[letter2] * Math.random());\r\n        }\r\n    }\r\n\r\n    combos.sort((a, b) => {\r\n        return comboScores.get(`[${a[0]},${a[1]}]`)! - comboScores.get(`[${b[0]},${b[1]}]`)!;\r\n    });\r\n\r\n    return combos;\r\n}\r\n\r\nfunction processAnchorCombo(node: FillNode, isForManualFill: boolean, heuristicsLevel: number) {\r\n    let grid = node.startGrid;\r\n    let combo = node.anchorCombosLeft.pop()!;\r\n\r\n    let fillWordKey = wordKey(node.fillWord!);\r\n    let wordSquares = getSquaresForWord(grid, node.fillWord!);\r\n    let patternWithAnchor = getLettersFromSquares(wordSquares);\r\n    node.anchorSquareKeys.forEach((sqKey, i) => {\r\n        patternWithAnchor = insertLetterIntoPattern(patternWithAnchor, combo[i], wordSquares, sqKey);\r\n    });\r\n    if (isForManualFill && isWordFull(wordSquares)) {\r\n        node.entryCandidates = [];\r\n        node.entryCandidates.push({\r\n            word: patternWithAnchor,\r\n            score: 1,\r\n            isViable: true,\r\n            hasBeenChained: false,\r\n            wasChainFailure: false,\r\n            crossScore: 0,\r\n            minCrossScore: 0,\r\n        } as EntryCandidate);\r\n        return;\r\n    }\r\n\r\n    let crossKeys = new Map<string, boolean>();\r\n    let crossCrossKeys = new Map<string, boolean>();\r\n    getAllCrosses(grid, node.fillWord!).forEach(cross => {\r\n        crossKeys.set(wordKey(cross), true);\r\n        getAllCrosses(grid, cross).forEach(crossCross => {\r\n            if (wordKey(crossCross) !== fillWordKey)\r\n                crossCrossKeys.set(wordKey(crossCross), true);\r\n        });\r\n    });\r\n\r\n    if (wordSquares.length < 6 || (wordSquares.length < 7 && crossKeys.size + crossCrossKeys.size <= 15))\r\n        heuristicsLevel = 3;\r\n    if (heuristicsLevel === 3 && wordSquares.length > 8 && crossKeys.size + crossCrossKeys.size > 20)\r\n        heuristicsLevel = 2;\r\n\r\n    let iffyWordKey = isForManualFill ? Globals.manualIffyKey : node.iffyWordKey;\r\n    wordSquares.forEach(sq => {\r\n        let cross = getWordAtSquare(grid, sq.row, sq.col, otherDir(node.fillWord!.direction))!;\r\n        if (!cross) return;\r\n        let crossSquares = getSquaresForWord(grid, cross);\r\n        if (wordKey(cross) === iffyWordKey) {\r\n            crossSquares.forEach(csq => {\r\n                if (!csq.content)\r\n                    csq.viableLetters = deepClone(fullAlphabet);\r\n            });\r\n        }\r\n        if (isWordFull(crossSquares))\r\n            crossKeys.delete(wordKey(cross));\r\n    });\r\n    if (crossKeys.size === 0) {\r\n        populateNoHeuristicEntryCandidates(node, true);\r\n        return;\r\n    }\r\n\r\n    let entries = getFilteredEntries(wordSquares, patternWithAnchor, undefined, grid.usedWords);\r\n\r\n    entries.forEach(entry => {\r\n        let success = processEntry(entry, iffyWordKey);\r\n\r\n        if (!success && !node.iffyWordKey && heuristicsLevel === 3 && Globals.maxIffyLength! > 0) {\r\n            crossKeys.forEach((_, ck) => {\r\n                let cross = grid.words.get(ck)!;\r\n                if (wordLength(cross) > Globals.maxIffyLength!) return;\r\n                processEntry(entry, ck);\r\n            });\r\n        }\r\n    });\r\n\r\n    node.entryCandidates.forEach(ec => {\r\n        if(ec.score === -1) {\r\n            ec.score = calculateEntryCandidateScore(node, ec);\r\n        }\r\n    });\r\n\r\n    function processEntry(entry: string, iffyWordKey?: string): boolean {\r\n        let isViable = true;\r\n        let distillIndex = 1;\r\n        let calculatedSquares = new Map<string, string[]>();\r\n        let crossScore = 0;\r\n        let minCrossScore = 1e8;\r\n        let usedWords = deepClone(grid.usedWords) as Map<string, boolean>;\r\n        usedWords.set(entry, true);\r\n\r\n        wordSquares.forEach((sq, i) => {\r\n            let sqKey = squareKey(sq);\r\n            calculatedSquares.set(sqKey, [entry[i]]);\r\n\r\n            let cross = getWordAtSquare(grid, sq.row, sq.col, otherDir(node.fillWord!.direction))!;\r\n            if (!cross) {\r\n                calculatedSquares.set(sqKey, deepClone(fullAlphabet));\r\n                return;\r\n            }\r\n\r\n            let crossSquares = getSquaresForWord(grid, cross);\r\n            let pattern = getLettersFromSquares(crossSquares);\r\n            insertLetterIntoPattern(pattern, entry[i], crossSquares, sqKey);\r\n            if (!pattern.includes(\"-\"))\r\n                usedWords.set(pattern, true);\r\n\r\n            if (wordKey(cross) === iffyWordKey) {\r\n                crossSquares.forEach(csq => {\r\n                    if (!csq.content)\r\n                        csq.viableLetters = deepClone(fullAlphabet);\r\n                });\r\n            }\r\n        });\r\n\r\n        while(true) {\r\n            let wordKeys = distillIndex % 2 === 1  ? crossKeys : crossCrossKeys;\r\n            let foundCountReduction = false;\r\n    \r\n            // eslint-disable-next-line\r\n            wordKeys.forEach((_, wKey) => {\r\n                if (!isViable) return;\r\n                if (wKey === fillWordKey) return;\r\n                if (wKey === iffyWordKey) return;\r\n\r\n                let word = grid.words.get(wKey)!;\r\n                let squares = getSquaresForWord(grid, word);\r\n                if (isWordFull(squares)) return;\r\n                if (distillIndex === 1 && squares.filter(sq => !calculatedSquares.has(squareKey(sq)) && \r\n                    (!sq.viableLetters || sq.viableLetters.length < 20)).length === 0) return;\r\n                let wordPattern = getLettersFromSquares(squares);\r\n                let filteredEntries = [] as string[];\r\n                let anchorInfo = populateFillWordAnchors(squares, calculatedSquares);\r\n                let anchorComboCount = anchorInfo.anchorCombosLeft.length;\r\n                if (distillIndex > 1 && anchorComboCount > 20) return;\r\n\r\n                anchorInfo.anchorCombosLeft.forEach(combo => {\r\n                    let newPattern = wordPattern;\r\n                    anchorInfo.anchorSquareKeys.forEach((sqKey, i) => {\r\n                        newPattern = insertLetterIntoPattern(newPattern, combo[i], squares, sqKey);\r\n                    });\r\n                    filteredEntries.push(...getFilteredEntries(squares, newPattern, calculatedSquares, usedWords));\r\n                });\r\n    \r\n                if (filteredEntries.length === 0) {\r\n                    isViable = false;\r\n                    return;\r\n                }\r\n\r\n                if (distillIndex === 1) {\r\n                    let score = sum(filteredEntries.map(fe => getWordScore(fe)));\r\n                    crossScore += score;\r\n                    if (score < minCrossScore) minCrossScore = score;\r\n                }\r\n\r\n                if (heuristicsLevel === 1) return;\r\n                if (distillIndex === 2 && heuristicsLevel === 2) return;\r\n    \r\n                squares.forEach((sq, i) => {\r\n                    let newMatrix = Array<boolean>(26).fill(false);\r\n                    filteredEntries.forEach(entry => {\r\n                        newMatrix[entry[i].charCodeAt(0) - 65] = true;\r\n                    });\r\n                    let letters = letterMatrixToLetterList(newMatrix);\r\n\r\n                    let existingCounts = calculatedSquares.get(squareKey(sq))!;\r\n                    if (!existingCounts || existingCounts.length > letters.length)\r\n                        foundCountReduction = true;\r\n\r\n                    calculatedSquares.set(squareKey(sq), letters);\r\n                });\r\n            });\r\n\r\n            if (distillIndex === 3) break;\r\n            if (!foundCountReduction) break;\r\n            if (!isViable) break;\r\n            if (distillIndex > 0 && heuristicsLevel === 1) break;\r\n            if (distillIndex === 2 && heuristicsLevel === 2) break;\r\n\r\n            distillIndex++;\r\n        }\r\n\r\n        if (!isViable) return false;\r\n\r\n        if (crossScore > node.topCrossScore) node.topCrossScore = crossScore;\r\n        if (minCrossScore > node.topMinCrossScore) node.topMinCrossScore = minCrossScore;\r\n\r\n        let iffyEntry = undefined as string | undefined;\r\n        if (iffyWordKey) {\r\n            let iffyWord = grid.words.get(iffyWordKey)!;\r\n            let iffySquares = getSquaresForWord(grid, iffyWord);\r\n            let pattern = getLettersFromSquares(iffySquares);\r\n            iffySquares.forEach((isq, idx) => {\r\n                let calSq = calculatedSquares.get(squareKey(isq));\r\n                if (!isq.content && calSq && calSq.length === 1)\r\n                    pattern = pattern.substring(0, idx) + calSq[0] + pattern.substring(idx+1);\r\n            });\r\n            iffyEntry = pattern;\r\n        }\r\n\r\n        if (iffyEntry && usedWords.has(iffyEntry)) return false;\r\n\r\n        node.entryCandidates.push({\r\n            word: entry,\r\n            score: -1,\r\n            isViable: isViable,\r\n            hasBeenChained: false,\r\n            wasChainFailure: false,\r\n            iffyEntry: iffyEntry,\r\n            iffyWordKey: iffyWordKey,\r\n            crossScore: crossScore,\r\n            minCrossScore: minCrossScore,\r\n        } as EntryCandidate);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\nfunction getFilteredEntries(squares: GridSquare[], anchorPattern: string, calculatedSquares?: Map<string, string[]>,\r\n    usedWords?: Map<string, boolean>): string[] {\r\n    let entries = [] as string[];\r\n    broadenAnchorPatterns(squares, anchorPattern, calculatedSquares).forEach(pattern => {\r\n        entries.push(...queryIndexedWordList(pattern));\r\n    });\r\n\r\n    let filteredEntries = entries.filter(entry => {\r\n        if (usedWords && usedWords.has(entry)) return false;\r\n\r\n        for (let i = 0; i < squares.length; i++) {\r\n            let sq = squares[i];\r\n            let sqKey = squareKey(sq);\r\n            \r\n            if (calculatedSquares && calculatedSquares.has(sqKey) && !calculatedSquares.get(sqKey)!.includes(entry[i])) {\r\n                return false;\r\n            }\r\n            else if (sq.viableLetters && !sq.viableLetters.includes(entry[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        \r\n        return true;\r\n    });\r\n\r\n    return filteredEntries;\r\n}\r\n\r\nfunction broadenAnchorPatterns(squares: GridSquare[], anchorPattern: string, calculatedSquares?: Map<string, string[]>): string[] {\r\n    let constraintCounts = squares.map((sq, i) => {\r\n        if (anchorPattern[i] !== \"-\") return [i, [anchorPattern[i]]] as [number, string[]];\r\n        if (calculatedSquares && calculatedSquares.has(squareKey(sq))) {\r\n            return [i, calculatedSquares.get(squareKey(sq))!] as [number, string[]];\r\n        }\r\n        return [i, sq.viableLetters || fullAlphabet] as [number, string[]];\r\n    })\r\n    .filter(x => x[1].length > 0).sort((a, b) => b[1].length - a[1].length);\r\n\r\n    let curPatterns = [anchorPattern];\r\n    while(constraintCounts.length > 0 && curPatterns.length < 12) {\r\n        let lowestCount = constraintCounts.pop()!;\r\n        if (lowestCount[1].length >= 6) \r\n            return curPatterns;\r\n\r\n        let index = lowestCount[0];\r\n        let viableLetters = lowestCount[1];\r\n        let newCurPatterns = [] as string[];\r\n        // eslint-disable-next-line\r\n        viableLetters.forEach(ltr => {\r\n            curPatterns.forEach(pattern => {\r\n                newCurPatterns.push(pattern.substring(0, index) + ltr + pattern.substring(index+1));\r\n            });\r\n        });\r\n        curPatterns = newCurPatterns;\r\n    }\r\n\r\n    return curPatterns;\r\n}\r\n\r\nfunction calculateEntryCandidateScore(node: FillNode, ec: EntryCandidate): number {\r\n    let wordScore = getWordScore(ec.word);\r\n    let crossScore = node.topCrossScore > 0 ? ec.crossScore / node.topCrossScore : 1;\r\n    let minCrossScore = node.topMinCrossScore > 0 ? ec.minCrossScore / node.topMinCrossScore : 1;\r\n    let ret = (crossScore + minCrossScore) * wordScore * (ec.iffyWordKey ? 1 : 100);\r\n    return ret;\r\n}\r\n\r\nfunction insertLetterIntoPattern(pattern: string, newLetter: string, squares: GridSquare[], sqKey: string): string {\r\n    let i = squares.findIndex(sq => squareKey(sq) === sqKey);\r\n    return pattern.substring(0, i) + newLetter + pattern.substring(i+1);\r\n}\r\n","import { GridSquare } from \"../models/GridSquare\";\r\nimport { GridState } from \"../models/GridState\";\r\nimport { GridWord } from \"../models/GridWord\";\r\nimport { SquareType } from \"../models/SquareType\";\r\nimport { WordDirection } from \"../models/WordDirection\";\r\nimport Globals from './windowService';\r\nimport { Puzzle } from \"../models/Puzzle\";\r\nimport { getLettersFromSquares } from \"./grid\";\r\nimport { ContentType } from \"../models/ContentType\";\r\nimport { Section } from \"../models/Section\";\r\nimport { SectionCandidate } from \"../models/SectionCandidate\";\r\nimport { generateGridSections } from \"./section\";\r\n\r\nexport const fullAlphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".split(\"\");\r\n\r\nexport function average(arr: number[]): number {\r\n    return arr.reduce((a,b) => a + b, 0) / arr.length;\r\n}\r\n\r\nexport function sum(arr: number[]): number {\r\n    return arr.reduce((a,b) => a + b, 0);\r\n}\r\n\r\n// https://stackoverflow.com/questions/38416020/deep-copy-in-es6-using-the-spread-syntax\r\nexport function deepClone(obj: any): any {\r\n    if(typeof obj !== 'object' || obj === null) {\r\n        return obj;\r\n    }\r\n\r\n    if(obj instanceof Date) {\r\n        return new Date(obj.getTime());\r\n    }\r\n\r\n    if(obj instanceof Map) {\r\n        return new Map(Array.from(obj.entries()));\r\n    }\r\n\r\n    if(obj instanceof Array) {\r\n        return obj.reduce((arr, item, i) => {\r\n            arr[i] = deepClone(item);\r\n            return arr;\r\n        }, []);\r\n    }\r\n\r\n    if(obj instanceof Object) {\r\n        return Object.keys(obj).reduce((newObj: any, key) => {\r\n            newObj[key] = deepClone(obj[key]);\r\n            return newObj;\r\n        }, {})\r\n    }\r\n}\r\n\r\nexport function compareTuples(first: [number, number], second: [number, number]): boolean {\r\n    return first[0] === second[0] && first[1] === second[1];\r\n}\r\n\r\nexport function isBlackSquare(sq: GridSquare): boolean {\r\n    return sq.type === SquareType.Black;\r\n}\r\n\r\nexport function otherDir(dir: WordDirection): WordDirection {\r\n    return dir === WordDirection.Across ? WordDirection.Down : WordDirection.Across;\r\n}\r\n\r\nexport function getSquaresForWord(grid: GridState, word: GridWord): GridSquare[] {\r\n    let row = word.start[0];\r\n    let col = word.start[1];\r\n    let squares = [grid.squares[row][col]];\r\n    while (!compareTuples([row, col], word.end)) {\r\n        row = word.direction === WordDirection.Across ? row : row+1;\r\n        col = word.direction === WordDirection.Across ? col+1 : col;\r\n        squares.push(grid.squares[row][col]);\r\n    }\r\n\r\n    return squares;\r\n}\r\n\r\nexport function getWordAtSquare(grid: GridState, row: number, col: number, dir: WordDirection): GridWord | undefined {\r\n    let ret = undefined as GridWord | undefined;\r\n\r\n    grid.words.forEach((word, _) => {\r\n        if (dir === WordDirection.Across && word.direction === dir && word.start[0] === row &&\r\n            word.start[1] <= col && word.end[1] >= col)\r\n            ret = word;\r\n        if (dir === WordDirection.Down && word.direction === dir && word.start[1] === col &&\r\n            word.start[0] <= row && word.end[0] >= row)\r\n            ret = word;\r\n    });\r\n\r\n    return ret;\r\n}\r\n\r\nexport function newWord(): GridWord {\r\n    return {\r\n        number: undefined,\r\n        direction: WordDirection.Across,\r\n        start: [-1, -1],\r\n        end: [-1, -1],\r\n    }\r\n}\r\n\r\nexport function doesWordContainSquare(word: GridWord, row: number, col: number): boolean {\r\n    if (word.direction === WordDirection.Across) {\r\n        return word.start[0] === row && word.start[1] <= col && word.end[1] >= col;\r\n    }\r\n    else {\r\n        return word.start[1] === col && word.start[0] <= row && word.end[0] >= row;\r\n    }\r\n}\r\n\r\nexport function isWordEmpty(squares: GridSquare[]): boolean {\r\n    return !squares.find(x => !isBlackSquare(x) && x.content);\r\n}\r\n\r\nexport function isWordFull(squares: GridSquare[]): boolean {\r\n    return !squares.find(x => !isBlackSquare(x) && !x.content);\r\n}\r\n\r\nexport function shuffleArray(array: any[]) {\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1));\r\n        [array[i], array[j]] = [array[j], array[i]];\r\n    }\r\n}\r\n\r\nexport function forAllGridSquares(grid: GridState, func: (sq: GridSquare) => void) {\r\n    grid.squares.forEach(row => {\r\n        row.forEach(sq => {\r\n            func(sq);\r\n        });\r\n    });\r\n}\r\n\r\nexport function wordLength(word: GridWord): number {\r\n    if (word.direction === WordDirection.Across)\r\n        return word.end[1] - word.start[1] + 1;\r\n    else\r\n        return word.end[0] - word.start[0] + 1;\r\n}\r\n\r\nexport function newPuzzle(): Puzzle {\r\n    return {\r\n        title: \"\",\r\n        author: \"\",\r\n        copyright: \"\",\r\n        clues: new Map<string, string>(),\r\n        notes: \"\",\r\n    } as Puzzle;    \r\n}\r\n\r\nexport function wordKey(word: GridWord): string {\r\n    return `[${word.start[0]},${word.start[1]},${word.direction === WordDirection.Across ? \"A\" : \"D\"}]`;\r\n}\r\n\r\nexport function squareKey(sq: GridSquare | undefined): string {\r\n    return sq ? `[${sq.row},${sq.col}]` : \"\";\r\n}\r\n\r\nexport function getGrid(): GridState {\r\n    return Globals.activeGrid!;\r\n}\r\n\r\nexport function getSection(): Section {\r\n    return Globals.sections!.get(Globals.activeSectionId!)!;\r\n}\r\n\r\nexport function getSelectedWord(): GridWord | undefined {\r\n    let grid = getGrid();\r\n    if (!Globals.selectedWordKey) return undefined;\r\n    return grid.words.get(Globals.selectedWordKey);\r\n}\r\n\r\nexport function mapKeys<TKey, TVal>(map: Map<TKey, TVal>): TKey[] {\r\n    return Array.from(map.keys()) || [];\r\n}\r\n\r\nexport function mapValues<TKey, TVal>(map: Map<TKey, TVal>): TVal[] {\r\n    return Array.from(map.values()) || [];\r\n}\r\n\r\nexport function isUserFilled(sq: GridSquare): boolean {\r\n    return sq.contentType === ContentType.User || sq.contentType === ContentType.ChosenWord \r\n        || sq.contentType === ContentType.ChosenSection;\r\n}\r\n\r\nexport function isUserOrWordFilled(sq: GridSquare): boolean {\r\n    return sq.contentType === ContentType.User || sq.contentType === ContentType.ChosenWord;\r\n}\r\n\r\nexport function isAcross(word: GridWord): boolean {\r\n    return word.direction === WordDirection.Across;\r\n}\r\n\r\nexport function getSquareAtKey(grid: GridState, squareKey: string): GridSquare {\r\n    let tokens = squareKey.substring(1, squareKey.length - 1).split(\",\");\r\n    return grid.squares[+tokens[0]][+tokens[1]];\r\n}\r\n\r\nexport function isPartOfIffyWord(sq: GridSquare): boolean {\r\n    if (!sq.viableLetters) return false;\r\n    return sq.viableLetters.length === 0;\r\n}\r\n\r\n// https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\r\nexport function shuffle(array: any[]) {\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1));\r\n        [array[i], array[j]] = [array[j], array[i]];\r\n    }\r\n}\r\n\r\nexport function getEntryAtWordKey(grid: GridState, wordKey: string): string {\r\n    return getLettersFromSquares(getSquaresForWord(grid, grid.words.get(wordKey)!));\r\n}\r\n\r\nexport function getSectionCandidatesFromKeys(keys: string[]): SectionCandidate[] {\r\n    return keys\r\n        .map(sck => mapValues(Globals.sections!).find(sec => sec.candidates.has(sck))?.candidates.get(sck))\r\n        .filter(sck => sck !== undefined)\r\n        .map(sck => sck!);\r\n}\r\n\r\nexport function constraintLetterCount(sq: GridSquare): number {\r\n    if (!sq.viableLetters) return 26;\r\n\r\n    return sq.viableLetters.length;\r\n}\r\n\r\nexport function isPatternFull(pattern: string): boolean {\r\n    return !pattern.includes(\"-\");\r\n}\r\n\r\nexport function getUserFilledSections(grid: GridState): Section[] {\r\n    let sectionCandidates = getSectionCandidatesFromKeys(mapKeys(grid.userFilledSectionCandidates));\r\n    return sectionCandidates.map(sc => Globals.sections!.get(sc.sectionId)!);\r\n}\r\n\r\nexport function getUserFilledSectionCandidates(grid: GridState): SectionCandidate[] {\r\n    return getSectionCandidatesFromKeys(mapKeys(grid.userFilledSectionCandidates));\r\n}\r\n\r\nexport function initializeSessionGlobals() {\r\n    let grid = getGrid();\r\n    Globals.sections = generateGridSections(grid);\r\n    Globals.activeSectionId = 0;\r\n    Globals.hoverSectionId = undefined;\r\n    Globals.selectedSectionIds = new Map<number, boolean>();\r\n    Globals.selectedSectionIds.set(0, true);\r\n    Globals.selectedSectionCandidateKeys = new Map<number, string>();\r\n}\r\n\r\nexport function letterMatrixToLetterList(matrix: boolean[]): string[] {\r\n    return matrix.map((x, i) => x ? String.fromCharCode(i + 65) : \"\").filter(x => x);\r\n}\r\n\r\nexport function letterListToLetterMatrix(list: string[]): boolean[] {\r\n    let matrix = Array<boolean>(26).fill(false);\r\n    list.forEach(ltr => {\r\n        matrix[ltr.charCodeAt(0)] = true;\r\n    });\r\n    return matrix;\r\n}\r\n","import { ContentType } from \"../models/ContentType\";\r\nimport { FillNode } from \"../models/FillNode\";\r\nimport { GridSquare } from \"../models/GridSquare\";\r\nimport { GridState } from \"../models/GridState\";\r\nimport { GridWord } from \"../models/GridWord\";\r\nimport { Section } from \"../models/Section\";\r\nimport { SectionCandidate } from \"../models/SectionCandidate\";\r\nimport { WordDirection } from \"../models/WordDirection\";\r\nimport { getAllCrosses, getWordScore } from \"./fill\";\r\nimport { generateConstraintInfoForSquares, getLettersFromSquares } from \"./grid\";\r\nimport { forAllGridSquares, getEntryAtWordKey, getGrid, getSquaresForWord, getWordAtSquare, getSquareAtKey, isAcross, \r\n    isBlackSquare, mapKeys, squareKey, wordKey, wordLength, mapValues, isUserOrWordFilled, deepClone } from \"./util\";\r\nimport Globals from './windowService';\r\n\r\nexport function updateSectionFilters() {\r\n    let sections = Globals.sections!;\r\n    let grid = getGrid();\r\n    sections.forEach(sec => {\r\n        sec.candidates.forEach((can, _) => {\r\n            let sqKeys = mapKeys(sec.squares);\r\n            can.isFilteredOut = false;\r\n            for (let sqKey of sqKeys) {\r\n                let gridSq = getSquareAtKey(grid, sqKey);\r\n                let canSq = getSquareAtKey(can.grid, sqKey);\r\n                if (isUserOrWordFilled(gridSq) && canSq.content !== gridSq.content)\r\n                    can.isFilteredOut = true;\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\nexport function getSectionString(grid: GridState, section: Section): string {\r\n    let ret = [] as string[];\r\n    mapKeys(section.squares).sort().forEach(sqKey => {\r\n        let sq = getSquareAtKey(grid, sqKey);\r\n        let content = sq.content;\r\n        ret.push(content ? content! : \"-\");\r\n    });\r\n    return ret.join(\"\");\r\n}\r\n\r\n// returns whether it was a success\r\nexport function insertSectionCandidateIntoGrid(grid: GridState, candidate: SectionCandidate, contentType?: ContentType): boolean {\r\n    if (contentType === undefined) contentType = ContentType.ChosenSection;\r\n    let newGrid = deepClone(grid) as GridState;\r\n    let section = Globals.sections!.get(candidate.sectionId)!;\r\n    let foundDiscrepancy = false;\r\n    section.squares.forEach((_, sqKey) => {\r\n        let sq = getSquareAtKey(newGrid, sqKey);\r\n        let candidateSq = getSquareAtKey(candidate.grid, sqKey);\r\n        if (isUserOrWordFilled(sq) && sq.content! !== candidateSq.content!)\r\n            foundDiscrepancy = true;\r\n        sq.content = candidateSq.content;\r\n        sq.viableLetters = [sq.content!];\r\n        if (!isUserOrWordFilled(sq)) {\r\n            sq.contentType = [ContentType.HoverChosenSection, ContentType.Autofill].includes(contentType!) ? \r\n                ContentType.Autofill : ContentType.ChosenSection;\r\n        }\r\n    });\r\n    if (foundDiscrepancy) return false;\r\n    else {\r\n        forAllGridSquares(newGrid, newSq => {\r\n            grid.squares[newSq.row][newSq.col] = newSq;\r\n        });\r\n    }\r\n\r\n    section.words.forEach((_, key) => {\r\n        let word = grid.words.get(key)!;\r\n        let squares = getSquaresForWord(grid, word);\r\n        grid.usedWords.set(getLettersFromSquares(squares), true);\r\n    });\r\n\r\n    section.neighboringCrosses.forEach((_, key) => {\r\n        let word = grid.words.get(key)!;\r\n        let squares = getSquaresForWord(grid, word);\r\n        generateConstraintInfoForSquares(squares);\r\n    });\r\n\r\n    grid.userFilledSectionCandidates.set(sectionCandidateKey(section, grid), true);\r\n    return true;\r\n}\r\n\r\nexport function generateGridSections(grid: GridState): Map<number, Section> {\r\n    function iterateSection(section: Section, grid: GridState, sq: GridSquare, usedSquares: Map<string, boolean>) {\r\n        section.openSquareCount++;\r\n        usedSquares.set(squareKey(sq), true);\r\n\r\n        getNeighboringSquares(grid, sq).forEach(neighbor => {\r\n            if (!usedSquares.has(squareKey(neighbor)) && isOpenSquare(grid, neighbor)) {\r\n                iterateSection(section, grid, neighbor, usedSquares);\r\n            }\r\n\r\n            [WordDirection.Across, WordDirection.Down].forEach(dir => {\r\n                let word = getWordAtSquare(grid, neighbor.row, neighbor.col, dir)!;\r\n                if (word !== undefined && !section.words.has(wordKey(word))) {\r\n                    section.words.set(wordKey(word), true);\r\n                    let squares = getSquaresForWord(grid, word);\r\n                    squares.forEach(wsq => {\r\n                        section.squares.set(squareKey(wsq), true);\r\n                    });\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    let sections = new Map<number, Section>();\r\n    let usedSquares = new Map<string, boolean>();\r\n    let nextSectionId = 1;\r\n\r\n    // add full grid section\r\n    let fullSection = makeNewSection(0);\r\n    forAllGridSquares(grid, sq => {\r\n        if (!isBlackSquare(sq)) fullSection.squares.set(squareKey(sq), true);\r\n    });\r\n    grid.words.forEach(w => {\r\n        fullSection.words.set(wordKey(w), true);\r\n    });\r\n    sections.set(0, fullSection);\r\n\r\n    // populate sections\r\n    forAllGridSquares(grid, sq => {\r\n        if (!usedSquares.has(squareKey(sq)) && isOpenSquare(grid, sq)) {\r\n            let newSection = makeNewSection(nextSectionId);\r\n            iterateSection(newSection, grid, sq, usedSquares);\r\n            if (newSection.openSquareCount === 1) return;\r\n            sections.set(newSection.id, newSection);\r\n            nextSectionId++;\r\n        }\r\n    });\r\n    if (sections.size === 2) sections.delete(1);\r\n\r\n    // populate stackWords\r\n    sections.forEach(section => {\r\n        section.stackWords = new Map<string, boolean>();\r\n\r\n        section.words.forEach((_, key) => {\r\n            if (section.stackWords.has(key)) return;\r\n\r\n            let word = grid.words.get(key)!;\r\n            let stackedNeighbors = mapKeys(section.words).filter(otherKey => {\r\n                if (otherKey === key) return false;\r\n\r\n                let otherWord = grid.words.get(otherKey)!;\r\n                if (isAcross(word) && isAcross(otherWord) && Math.abs(word.start[0] - otherWord.start[0]) === 1) {\r\n                    let intersectionCount = Math.min(word.end[1], otherWord.end[1]) - Math.max(word.start[1], otherWord.start[1]) + 1;\r\n                    return intersectionCount >= 5;\r\n                }\r\n                if (!isAcross(word) && !isAcross(otherWord) && Math.abs(word.start[1] - otherWord.start[1]) === 1) {\r\n                    let intersectionCount = Math.min(word.end[0], otherWord.end[0]) - Math.max(word.start[0], otherWord.start[0]) + 1;\r\n                    return intersectionCount >= 5;\r\n                }\r\n                return false;\r\n            }); \r\n\r\n            if (stackedNeighbors.length > 0) {\r\n                section.stackWords.set(key, true);\r\n                stackedNeighbors.forEach(sk => {\r\n                    section.stackWords.set(sk, true);\r\n                });\r\n            }\r\n        });\r\n    });\r\n\r\n    // populate neighboringCrosses\r\n    sections.forEach(section => {\r\n        section.words.forEach((_, key) => {\r\n            let word = grid.words.get(key)!;\r\n            let crosses = getAllCrosses(grid, word);\r\n            crosses.forEach(cross => {\r\n                let crossKey = wordKey(cross);\r\n                if (!section.words.has(crossKey))\r\n                    section.neighboringCrosses.set(crossKey, true);\r\n            });\r\n        });\r\n    });\r\n\r\n    // calculate word order\r\n    sections.forEach(section => {\r\n        if (section.id === 0) {\r\n            let wordOrder = [] as string[];\r\n            let usedWords = new Map<string, boolean>();\r\n            let orderedSections = calculateSectionOrder(mapValues(sections));\r\n            orderedSections.forEach(id => {\r\n                if (id === 0 && sections.size > 1) return;\r\n                let secOrder = calculateWordOrder(grid, sections.get(id)!);\r\n                wordOrder.push(...secOrder.filter(wk => !usedWords.has(wk)));\r\n                secOrder.forEach(wk => {usedWords.set(wk, true);});\r\n            });\r\n            mapKeys(section.words).filter(wKey => !usedWords.has(wKey)).forEach(wk => {\r\n                wordOrder.push(wk);\r\n            });\r\n            section.wordOrder = wordOrder;\r\n            return;\r\n        }\r\n\r\n        section.wordOrder = calculateWordOrder(grid, section);\r\n    });\r\n\r\n    // calculate connections\r\n    sections.forEach(section => {\r\n        sections.forEach((sec, id) => {\r\n            if (id === section.id) return;\r\n            if (mapKeys(sec.words).find(wk => section.words.has(wk)))\r\n                section.connections.set(id, true);\r\n        });\r\n    });\r\n\r\n    return sections;\r\n}\r\n\r\nexport function calculateSectionOrder(sections: Section[]): number[] {\r\n    return sections.sort((a, b) => {\r\n        if (a.id === 0) return -1;\r\n        if (b.id === 0) return 1;\r\n        if (a.connections.size !== b.connections.size) return b.connections.size - a.connections.size;\r\n        return b.squares.size - a.squares.size;\r\n    }).map(sec => sec.id);\r\n}\r\n\r\nfunction calculateWordOrder(grid: GridState, section: Section): string[] {\r\n    function wordsSort(a: GridWord, b: GridWord): number {\r\n        if (wordLength(a) !== wordLength(b)) return wordLength(b) - wordLength(a);\r\n        return a.direction === WordDirection.Across ? a.start[0] - b.start[0] : a.start[1] - b.start[1];\r\n    }\r\n\r\n    function iterateWordGroup(group: GridWord[]) {\r\n        if (group.length === 0) return;\r\n        if (group.length === 1) {\r\n            wordOrder.push(wordKey(group[0]));\r\n            usedWords.set(wordKey(group[0]), true);\r\n            return;\r\n        }\r\n\r\n        let centerIndex = Math.floor((rowOrCol(group[group.length-1]) - rowOrCol(group[0])) / 2);\r\n        wordOrder.push(wordKey(group[centerIndex]));\r\n        usedWords.set(wordKey(group[centerIndex]), true);\r\n        iterateWordGroup(group.slice(0, centerIndex));\r\n        iterateWordGroup(group.slice(centerIndex + 1));\r\n    }\r\n\r\n    let wordOrder = [] as string[];\r\n    let usedWords = new Map<string, boolean>();\r\n\r\n    // stack words\r\n    if (section.stackWords.size > 0) {\r\n        let acrossSortedStackWords = mapKeys(section.stackWords).map(wKey => grid.words.get(wKey)!)\r\n            .filter(word => word.direction === WordDirection.Across).sort(wordsSort);\r\n        let downSortedStackWords = mapKeys(section.stackWords).map(wKey => grid.words.get(wKey)!)\r\n            .filter(word => word.direction === WordDirection.Down).sort(wordsSort);\r\n        let longestStack = downSortedStackWords.length === 0 ? acrossSortedStackWords :\r\n            acrossSortedStackWords.length === 0 ? downSortedStackWords :\r\n            wordLength(acrossSortedStackWords[0]) >= wordLength(downSortedStackWords[0]) ? acrossSortedStackWords :\r\n            downSortedStackWords;\r\n        let otherStack = longestStack === acrossSortedStackWords ? downSortedStackWords : acrossSortedStackWords;\r\n        [longestStack, otherStack].forEach(stack => {\r\n            for (let i = 0; i < stack.length; i++) {\r\n                let word = stack[i];\r\n                let length = wordLength(word);\r\n                let curGroup = [word];\r\n                let prevRowOrCol = rowOrCol(word);\r\n                for (let j = i+1; j < stack.length && wordLength(stack[j]) === length; j++) {\r\n                    let newWord = stack[j];\r\n                    let newRowOrCol = rowOrCol(newWord);\r\n                    if (newRowOrCol - prevRowOrCol === 1) {\r\n                        curGroup.push(newWord);\r\n                        prevRowOrCol = newRowOrCol;\r\n                        i++;\r\n                    }\r\n                    else break;\r\n                }\r\n    \r\n                iterateWordGroup(curGroup);\r\n            }\r\n        });\r\n    }\r\n\r\n    // restOfWords\r\n    let remainingWords = mapKeys(section.words).filter(wKey => !usedWords.has(wKey))\r\n        .map(wKey => grid.words.get(wKey)!).sort(wordsSort);\r\n    remainingWords.forEach(word => {\r\n        wordOrder.push(wordKey(word));\r\n    });\r\n\r\n    return wordOrder;\r\n}\r\n\r\nfunction rowOrCol(word: GridWord): number {\r\n    return word.direction === WordDirection.Across ? word.start[0] : word.start[1];\r\n}\r\n\r\nfunction isOpenSquare(grid: GridState, sq: GridSquare): boolean {\r\n    let neighbors = getNeighboringSquares(grid, sq);\r\n    return neighbors.length === 8 && !neighbors.find(n => isBlackSquare(n));\r\n}\r\n\r\nfunction getNeighboringSquares(grid: GridState, sq: GridSquare): GridSquare[] {\r\n    let ret = [] as GridSquare[];\r\n    let nClear = sq.row > 0;\r\n    let sClear = sq.row < grid.height-1;\r\n    let wClear = sq.col > 0;\r\n    let eClear = sq.col < grid.width-1;\r\n\r\n    if (nClear && wClear) ret.push(grid.squares[sq.row-1][sq.col-1]);\r\n    if (nClear) ret.push(grid.squares[sq.row-1][sq.col]);\r\n    if (nClear && eClear) ret.push(grid.squares[sq.row-1][sq.col+1]);\r\n    if (eClear) ret.push(grid.squares[sq.row][sq.col+1]);\r\n    if (sClear && eClear) ret.push(grid.squares[sq.row+1][sq.col+1]);\r\n    if (sClear) ret.push(grid.squares[sq.row+1][sq.col]);\r\n    if (sClear && wClear) ret.push(grid.squares[sq.row+1][sq.col-1]);\r\n    if (wClear) ret.push(grid.squares[sq.row][sq.col-1]);\r\n\r\n    return ret;\r\n}\r\n\r\nexport function newSectionCandidate(node: FillNode, section: Section): SectionCandidate {\r\n    let grid = node.endGrid;\r\n    return {\r\n        sectionId: section.id,\r\n        grid: grid,\r\n        score: calculateSectionCandidateScore(grid, section),\r\n        iffyEntry: node.iffyWordKey ? getEntryAtWordKey(grid, node.iffyWordKey) : undefined,\r\n        isFilteredOut: false,\r\n    } as SectionCandidate;\r\n}\r\n\r\nexport function calculateSectionCandidateScore(grid: GridState, section: Section): number {\r\n    let total = 0;\r\n    let foundIffy = false;\r\n    section.words.forEach((_, wordKey) => {\r\n        let word = grid.words.get(wordKey)!;\r\n        let squares = getSquaresForWord(grid, word);\r\n        let str = getLettersFromSquares(squares);\r\n        let score = getWordScore(str);\r\n        if (score < 3) foundIffy = true;\r\n        total += score;\r\n    });\r\n\r\n    if (!foundIffy) total *= 10;\r\n    return total / section.words.size;\r\n}\r\n\r\nconst natoAlphabet = {\r\n    \"A\": \"Alfa\",   \"B\": \"Bravo\",   \"C\": \"Charlie\",\r\n    \"D\": \"Delta\",  \"E\": \"Echo\",    \"F\": \"Foxtrot\",\r\n    \"G\": \"Golf\",   \"H\": \"Hotel\",   \"I\": \"India\",\r\n    \"J\": \"Juliett\",\"K\": \"Kilo\",    \"L\": \"Lima\",\r\n    \"M\": \"Mike\",   \"N\": \"November\",\"O\": \"Oscar\",\r\n    \"P\": \"Papa\",   \"Q\": \"Quebec\",  \"R\": \"Romeo\",\r\n    \"S\": \"Sierra\", \"T\": \"Tango\",   \"U\": \"Uniform\",\r\n    \"V\": \"Victor\", \"W\": \"Whiskey\", \"X\": \"X-ray\",\r\n    \"Y\": \"Yankee\", \"Z\": \"Zulu\"\r\n} as any;\r\n\r\nexport function getPhoneticName(n: number): string {\r\n    if (n === 0) return \"Full Grid\";\r\n    return n <= 26 ? natoAlphabet[String.fromCharCode(n+64)] : \"Section \" + n.toString();\r\n}\r\n\r\nexport function sectionCandidateKey(section: Section, grid: GridState): string {\r\n    let keys = mapKeys(section.squares).sort();\r\n    return keys.map(k => getSquareAtKey(grid, k).content!).join(\"\");\r\n}\r\n\r\nexport function makeNewSection(id: number): Section {\r\n    return {\r\n        id: id,\r\n        openSquareCount: 0,\r\n        squares: new Map<string, boolean>(),\r\n        words: new Map<string, boolean>(),\r\n        stackWords: new Map<string, boolean>(),\r\n        wordOrder: [],\r\n        neighboringCrosses: new Map<string, boolean>(),\r\n        candidates: new Map<string, SectionCandidate>(),\r\n        connections: new Map<number, boolean>(),\r\n        comboPermsQueue: [],\r\n        comboPermsUsed: new Map<string, boolean>(),\r\n    } as Section;\r\n}\r\n\r\nexport function getLongestStackWord(section: Section): GridWord {\r\n    function getLongest(wordKeys: string[]): GridWord {\r\n        return wordKeys.map(w => grid.words.get(w)!).sort((a, b) => wordLength(b) - wordLength(a))[0];\r\n    }\r\n\r\n    let grid = getGrid();\r\n    if (section.stackWords.size > 0)\r\n        return getLongest(mapKeys(section.stackWords))\r\n    else\r\n        return getLongest(mapKeys(section.words));\r\n}\r\n\r\nexport function getSelectedSections(): Section[] {\r\n    if (Globals.selectedSectionIds!.size === 0) return [Globals.sections!.get(0)!];\r\n    return mapKeys(Globals.selectedSectionIds!).sort().map(id => Globals.sections!.get(id)!);\r\n}\r\n\r\nexport function getSelectedSectionCandidates(): SectionCandidate[] {\r\n    let ret = [] as SectionCandidate[];\r\n    Globals.sections!.forEach((section, _) => {\r\n        Globals.selectedSectionCandidateKeys!.forEach((scKey, _) => {\r\n            if (section.candidates.has(scKey))\r\n                ret.push(section.candidates.get(scKey)!);\r\n        });\r\n    });\r\n    return ret;\r\n}\r\n\r\nexport function getSelectedSectionCandidatesWithWord(wordKey: string): SectionCandidate[] {\r\n    let ret = [] as SectionCandidate[];\r\n    getSelectedSectionCandidates().forEach(sc => {\r\n        let section = Globals.sections!.get(sc.sectionId)!;\r\n        if (section.words.has(wordKey))\r\n            ret.push(sc);\r\n    });\r\n    return ret;\r\n}\r\n\r\nexport function getSelectedSectionCandidatesWithSquare(squareKey: string): SectionCandidate[] {\r\n    let ret = [] as SectionCandidate[];\r\n    getSelectedSectionCandidates().forEach(sc => {\r\n        let section = Globals.sections!.get(sc.sectionId)!;\r\n        if (section.squares.has(squareKey))\r\n            ret.push(sc);\r\n    });\r\n    return ret;\r\n}\r\n\r\nexport function getSectionsWithSelectedCandidate(): Section[] {\r\n    return getSelectedSectionCandidates().map(sc => getSectionWithCandidate(sc));\r\n}\r\n\r\nexport function getSectionWithCandidate(sc: SectionCandidate): Section {\r\n    return Globals.sections!.get(sc.sectionId)!;\r\n}\r\n\r\nexport function getUnfilteredSectionCandidates(section: Section): SectionCandidate[] {\r\n    return mapValues(section.candidates).filter(sc => !sc.isFilteredOut);\r\n}\r\n\r\nexport function getSectionsWithWord(word: GridWord): Section[] {\r\n    return mapValues(Globals.sections!).filter(sec => sec.id > 0 && sec.words.has(wordKey(word)));\r\n}\r\n","import { ContentType } from \"../models/ContentType\";\r\nimport { FillNode } from \"../models/FillNode\";\r\nimport { GridSquare } from \"../models/GridSquare\";\r\nimport { GridState } from \"../models/GridState\";\r\nimport { getAllCrosses } from \"./fill\";\r\nimport { generateConstraintInfoForSquares, getLettersFromSquares } from \"./grid\";\r\nimport { sectionCandidateKey } from \"./section\";\r\nimport { deepClone, getSectionCandidatesFromKeys, getSquaresForWord, isWordFull, mapKeys } from \"./util\";\r\nimport Globals from './windowService';\r\n\r\nexport function processAndInsertChosenEntry(node: FillNode, contentType?: ContentType) {\r\n    if (contentType === undefined) contentType = ContentType.Autofill;\r\n    if (!node.chosenEntry) return false;\r\n\r\n    let grid = deepClone(node.startGrid) as GridState;\r\n    let word = node.fillWord!;\r\n    let wordSquares = getSquaresForWord(grid, word);\r\n    let crosses = getAllCrosses(grid, word);\r\n\r\n    wordSquares.forEach((sq, i) => {\r\n        sq.content = node.chosenEntry!.word[i];\r\n        if ([ContentType.Autofill, ContentType.ChosenSection, ContentType.HoverChosenWord].includes(sq.contentType))\r\n            sq.contentType = contentType!;\r\n    });\r\n    grid.usedWords.set(getLettersFromSquares(wordSquares), true);\r\n    node.iffyWordKey = node.chosenEntry!.iffyWordKey;\r\n\r\n    if (contentType === ContentType.ChosenWord) {\r\n        removeNonmatchingSectionCandidates(grid, wordSquares, node.chosenEntry!.word);\r\n    }  \r\n\r\n    crosses.forEach(cross => {\r\n        let newSquares = getSquaresForWord(grid, cross);\r\n        generateConstraintInfoForSquares(newSquares);\r\n\r\n        if (isWordFull(newSquares)) {\r\n            grid.usedWords.set(getLettersFromSquares(newSquares), true);\r\n        }\r\n    });\r\n    \r\n    node.endGrid = grid;\r\n}\r\n\r\nfunction removeNonmatchingSectionCandidates(grid: GridState, newSquares: GridSquare[], chosenEntry: string) {\r\n    let sectionCandidates = getSectionCandidatesFromKeys(mapKeys(grid.userFilledSectionCandidates));\r\n    sectionCandidates.forEach(sc => {\r\n        let section = Globals.sections!.get(sc.sectionId)!;\r\n        newSquares.forEach((sq, i) => {\r\n            if (sc.grid.squares[sq.row][sq.col].content !== chosenEntry[i])\r\n                grid.userFilledSectionCandidates.delete(sectionCandidateKey(section, grid));\r\n        });\r\n    });\r\n}\r\n","// https://itnext.io/priority-queue-in-typescript-6ef23116901\r\n\r\n  interface Node<T> {\r\n    key: number\r\n    value: T\r\n  }\r\n\r\n  export interface PriorityQueue<T> {\r\n      isEmpty: () => boolean,\r\n      peek: () => T | null,\r\n      size: () => number,\r\n      insert: (item: T, prio: number) => void,\r\n      pop: () => T | null,\r\n  }\r\n  \r\n  export const priorityQueue = <T>(): PriorityQueue<T> => {\r\n    let heap: Node<T>[] = []\r\n\r\n    const parent = (index: number) => Math.floor((index - 1) / 2)\r\n    const left = (index: number) => 2 * index + 1\r\n    const right = (index: number) =>  2 * index + 2\r\n    const hasLeft = (index: number) => left(index) < heap.length\r\n    const hasRight = (index: number) => right(index) < heap.length\r\n\r\n    const swap = (a: number, b: number) => {\r\n        let temp = heap[a];\r\n        heap[a] = heap[b];\r\n        heap[b] = temp;\r\n    }\r\n  \r\n    return {\r\n      \r\n      isEmpty: () => heap.length === 0,\r\n  \r\n      peek: () => heap.length === 0 ? null : heap[0].value,\r\n      \r\n      size: () => heap.length,\r\n\r\n      insert: (item, prio) => {\r\n        heap.push({key: prio, value: item})\r\n  \r\n        let i = heap.length -1\r\n        while(i > 0) {\r\n          const p = parent(i)\r\n          if(heap[p].key > heap[i].key) break\r\n          const tmp = heap[i]\r\n          heap[i] = heap[p]\r\n          heap[p] = tmp\r\n          i = p\r\n        }\r\n      },\r\n\r\n      pop: () => {\r\n        if(heap.length === 0) return null\r\n        \r\n        swap(0, heap.length - 1)\r\n        const item = heap.pop()\r\n  \r\n        let current = 0\r\n        while(hasLeft(current)) {\r\n          let largerChild = left(current)\r\n          if(hasRight(current) && heap[right(current)].key > heap[left(current)].key) \r\n            largerChild = right(current)\r\n  \r\n          if(heap[largerChild].key < heap[current].key) break\r\n  \r\n          swap(current, largerChild)\r\n          current = largerChild\r\n        }\r\n  \r\n        return item!.value\r\n      }\r\n    }\r\n  }\r\n  ","export enum FillStatus {\r\n    NoWordList,\r\n    Ready,\r\n    Running,\r\n    Complete,\r\n}\r\n","import { ContentType } from '../models/ContentType';\r\nimport { EntryCandidate } from '../models/EntryCandidate';\r\nimport { FillNode } from '../models/FillNode';\r\nimport { GridSquare } from '../models/GridSquare';\r\nimport { GridState } from '../models/GridState';\r\nimport { GridWord } from '../models/GridWord';\r\nimport { QualityClass } from '../models/QualityClass';\r\nimport { Section } from '../models/Section';\r\nimport { WordDirection } from '../models/WordDirection';\r\nimport { populateAndScoreEntryCandidates } from './entryCandidates';\r\nimport { processAndInsertChosenEntry } from './insertEntry';\r\nimport { PriorityQueue, priorityQueue } from './priorityQueue';\r\nimport { getSectionString, getSectionsWithWord, insertSectionCandidateIntoGrid, newSectionCandidate } from './section';\r\nimport { deepClone, getSquaresForWord, mapKeys, isWordFull, \r\n    getWordAtSquare, otherDir, mapValues, getSection, getGrid, wordKey } from './util';\r\nimport Globals from './windowService';\r\n\r\nexport function fillSectionWord(): boolean {\r\n    let section = getSection();\r\n    let fillQueue = section.fillQueue;\r\n    if (!fillQueue) {\r\n        let newFillQueue = priorityQueue<FillNode>();\r\n        populateSeedNodes(newFillQueue);\r\n        fillQueue = newFillQueue;\r\n        section.fillQueue = newFillQueue;\r\n    }\r\n\r\n    let node = fillQueue.peek()!;\r\n    if (!node) {\r\n        populateSeedNodes(fillQueue);\r\n        node = fillQueue.peek()!;\r\n        if (!node) {\r\n            return false;\r\n        }\r\n    }\r\n    while (node.needsNewPriority || node.shouldBeDeleted) {\r\n        node.needsNewPriority = false;\r\n        fillQueue.pop();\r\n        if (!node.shouldBeDeleted) fillQueue.insert(node, calculateNodePriority(node));\r\n        node = fillQueue.peek()!;\r\n        if (!node) return false;\r\n    }\r\n    while (node.isChainNode && node.chainId! !== Globals.curChainId!) {\r\n        fillQueue.pop();\r\n        node = fillQueue.peek()!;\r\n        if (!node) return false;\r\n    }\r\n\r\n    if (!node.isChainNode && Globals.activeGrid !== node.startGrid) {\r\n        Globals.activeGrid = node.startGrid;\r\n        return true;\r\n    }\r\n\r\n    let success = processSectionNode(node, section);\r\n    if (success) {\r\n        let sectionString = getSectionString(node.endGrid, section);\r\n        // is section filled?\r\n        if (!sectionString.includes(\"-\")) {\r\n            let newSecCandidateFound = false;\r\n            if (!section.candidates.has(sectionString)) {\r\n                let newCandidate = newSectionCandidate(node, section);\r\n                section.candidates.set(sectionString, newCandidate);\r\n                Globals.activeGrid = node.endGrid;\r\n                newSecCandidateFound = true;\r\n            }\r\n            \r\n            invalidateChainNode(node, newSecCandidateFound);\r\n            fillQueue.pop();\r\n            return true;\r\n        }\r\n\r\n        Globals.activeGrid = node.endGrid;\r\n        let newNode = makeNewNode(node.endGrid, node.depth + 1, true, node);\r\n        \r\n        if (section.id === 0) {\r\n            let nextFillWord = selectWordToFill(node, getSection());\r\n            let curSections = getSectionsWithWord(node.fillWord!);\r\n            let nextSections = getSectionsWithWord(nextFillWord!);\r\n            if (curSections.length > 0 && !curSections.find(cs => nextSections.find(ns => ns.id === cs.id))) {\r\n                newNode = makeNewNode(node.endGrid, node.depth + 1, false, node, true);\r\n                Globals.curChainId!++;\r\n            }\r\n        }\r\n        \r\n        fillQueue.insert(newNode, calculateNodePriority(newNode));\r\n    }\r\n    else {\r\n        fillQueue.pop();\r\n        if (node.isChainNode) invalidateChainNode(node);\r\n        fillSectionWord();\r\n    }\r\n\r\n    Globals.selectedWordNode = undefined;\r\n    return true;\r\n}\r\n\r\nfunction invalidateChainNode(node: FillNode, newSecCandidateFound?: boolean) {\r\n    if (newSecCandidateFound === undefined) newSecCandidateFound = false;\r\n\r\n    let parent = node.parent!;\r\n    if (!parent) return;\r\n\r\n    let prevCandidate = parent.chosenEntry!;\r\n    if (parent.isChainNode) {\r\n        if (prevCandidate)\r\n            prevCandidate.wasChainFailure = true;\r\n        parent.backtracks++;\r\n    }\r\n    else {\r\n        if (prevCandidate)\r\n            prevCandidate.hasBeenChained = true;\r\n    }\r\n\r\n    parent.chosenEntry = undefined;\r\n    parent.iffyWordKey = parent.parent ? parent.parent.iffyWordKey : undefined;\r\n    parent.endGrid = deepClone(parent.startGrid);\r\n\r\n    if (parent.backtracks >= 3) {\r\n        if (parent.parent && !parent.parent.isChainNode) {\r\n            parent.isChainNode = false;\r\n            parent.needsNewPriority = true;\r\n            Globals.curChainId!++;\r\n        }\r\n            \r\n        invalidateChainNode(parent);\r\n    }\r\n\r\n    if (newSecCandidateFound) {\r\n        if (node.iffyWordKey && node.chainBaseNode!.chainIffyCandidates < 24) {\r\n            node.chainBaseNode!.chainIffyCandidates++;\r\n            return;\r\n        }\r\n        else if (!node.iffyWordKey && node.chainBaseNode!.chainGoodCandidates < 4) {\r\n            node.chainBaseNode!.chainGoodCandidates++;\r\n            return;\r\n        }\r\n\r\n        let curNode = parent;\r\n        while (curNode.parent && (curNode.parent.isChainNode || curNode.parent.isSectionBase)) {\r\n            if (curNode.isSectionBase) curNode.shouldBeDeleted = true;\r\n            curNode = curNode.parent!;\r\n        }\r\n        curNode.isChainNode = false;\r\n        curNode.needsNewPriority = true;\r\n        Globals.curChainId!++;\r\n    }\r\n}\r\n\r\nfunction calculateNodePriority(node: FillNode): number {\r\n    let grid = node.startGrid;\r\n    let wordScore = 0;\r\n    grid.usedWords.forEach((_, word) => {\r\n        wordScore += getWordScore(word);\r\n    });\r\n\r\n    let situationScore: number;\r\n    if (node.isChainNode)\r\n        situationScore = 1e8 + 10000*(node.depth+1);\r\n    else if (node.isSectionBase)\r\n        situationScore = (10000 + node.depth) * 10000;\r\n    else\r\n        situationScore = (10000 - node.depth) * 10000;\r\n\r\n    return wordScore + situationScore;\r\n}\r\n\r\nfunction populateSeedNodes(fillQueue: PriorityQueue<FillNode>) {\r\n    let grid = getGrid();\r\n    let selectedSectionIds = [Globals.activeSectionId!]; //Globals.selectedSectionIds!.size > 0 ? mapKeys(Globals.selectedSectionIds!) : [0];\r\n    let activeSection = getSection();\r\n    let connectionIds = mapKeys(activeSection.connections)\r\n        .filter(id => selectedSectionIds.includes(id) && Globals.sections!.get(id)!.selectedCandidate === undefined\r\n            && Globals.sections!.get(id)!.candidates.size > 0)\r\n        .sort();\r\n    let candidateCounts = connectionIds.map(i => Globals.sections!.get(i)!.candidates.size);\r\n    \r\n    getNewPermutations(candidateCounts, activeSection);\r\n    activeSection.comboPermsQueue.forEach(perm => {\r\n        let node = makeNewNode(grid, 0, false, undefined);\r\n        if (perm[0] === -1) {\r\n            fillQueue.insert(node, calculateNodePriority(node));\r\n            return;\r\n        }\r\n        let wasSuccess = true;\r\n        for (let i = 0; i < perm.length; i++) {\r\n            let sortedCandidates = mapValues(Globals.sections!.get(connectionIds[i])!.candidates)\r\n                .sort((a, b) => b.score - a.score);\r\n            let candidate = sortedCandidates[perm[i]];\r\n            if (!insertSectionCandidateIntoGrid(node.startGrid, candidate, ContentType.Autofill))\r\n                wasSuccess = false;\r\n        }\r\n        if (wasSuccess)\r\n            fillQueue.insert(node, calculateNodePriority(node));\r\n    });\r\n}\r\n\r\nfunction getNewPermutations(candidateCounts: number[], section: Section) {\r\n    function comboKey(perm: number[]): string {\r\n        return \"[\" + perm.map(n => n.toString()).join(\",\") + \"]\";\r\n    }\r\n\r\n    if (section.comboPermsUsed.size > 0 && section.comboPermsQueue.length > 0 && section.comboPermsQueue[0][0] === -1)\r\n        section.comboPermsQueue.shift();\r\n    if (section.comboPermsUsed.size > 0 && section.comboPermsQueue.length === 0) return;\r\n\r\n    if (candidateCounts.length === 0) {\r\n        let defaultCombo = [-1];\r\n        section.comboPermsQueue = [defaultCombo];\r\n        section.comboPermsUsed.set(comboKey(defaultCombo), true);\r\n        return;\r\n    }\r\n\r\n    if (section.comboPermsUsed.size === 0) {\r\n        let allOnes = [] as number[];\r\n        for(let i = 0; i < candidateCounts.length; i++) allOnes.push(1);\r\n        section.comboPermsQueue = [allOnes];\r\n        section.comboPermsUsed.set(comboKey(allOnes), true);\r\n        return;\r\n    }\r\n\r\n    while(true) {\r\n        let perm = section.comboPermsQueue.shift()!;\r\n        if (!perm) break;\r\n        let foundNew = false;\r\n\r\n        for(let i = 0; i < perm.length; i++) {\r\n            if (perm[i] === candidateCounts[i] - 1) continue;\r\n    \r\n            let newPerm = deepClone(perm);\r\n            newPerm[i]++;\r\n            let newPermKey = comboKey(newPerm);\r\n            if (section.comboPermsUsed.has(newPermKey)) continue;\r\n\r\n            section.comboPermsUsed.set(newPermKey, true);\r\n            foundNew = true;\r\n            section.comboPermsQueue.push(newPerm);\r\n        }\r\n\r\n        if (foundNew) break;\r\n    }\r\n}\r\n\r\nexport function processSectionNode(node: FillNode, section: Section): boolean {\r\n    if (!node.fillWord)\r\n        node.fillWord = selectWordToFill(node, section);\r\n\r\n    if (node.anchorSquareKeys.length === 0 || node.anchorCombosLeft.length > 0) {\r\n        let areEligibleCandidates = populateAndScoreEntryCandidates(node, false);\r\n        if (!areEligibleCandidates) return false;\r\n    }\r\n\r\n    let eligibleCandidates = getEligibleCandidates(node);\r\n    if (eligibleCandidates.length > 0) {\r\n        node.chosenEntry = chooseEntryFromCandidates(eligibleCandidates);\r\n        processAndInsertChosenEntry(node);\r\n        return true;\r\n    }\r\n    \r\n    return false;\r\n}\r\n\r\nexport function makeNewNode(grid: GridState, depth: number, isChainNode: boolean, parent: FillNode | undefined, \r\n    isSectionBase?: boolean): FillNode {\r\n    return {\r\n        startGrid: deepClone(grid),\r\n        endGrid: deepClone(grid),\r\n        entryCandidates: [],\r\n        depth: depth,\r\n        isChainNode: isChainNode,\r\n        isSectionBase: !!isSectionBase,\r\n        backtracks: 0,\r\n        parent: parent,\r\n        chainBaseNode: isChainNode ? (parent!.isChainNode ? parent!.chainBaseNode : parent!) : undefined,\r\n        needsNewPriority: false,\r\n        shouldBeDeleted: false,\r\n        anchorSquareKeys: [],\r\n        anchorCombosLeft: [],\r\n        viableLetterCounts: new Map<string, Map<string, number>>(),\r\n        iffyWordKey: parent ? parent.iffyWordKey : undefined,\r\n        chainGoodCandidates: parent ? parent.chainGoodCandidates : 0,\r\n        chainIffyCandidates: parent ? parent.chainIffyCandidates : 0,\r\n        chainId: Globals.curChainId!,\r\n        topCrossScore: 0,\r\n        topMinCrossScore: 0,\r\n    } as FillNode;\r\n}\r\n\r\nfunction selectWordToFill(node: FillNode, section: Section): GridWord | undefined {\r\n    let grid = node.startGrid;\r\n\r\n    for (let key of section.wordOrder) {\r\n        let word = grid.words.get(key)!;\r\n        let squares = getSquaresForWord(grid, word);\r\n        if (wordKey(word) !== node.iffyWordKey && !isWordFull(squares))\r\n            return word;\r\n    }\r\n\r\n    return undefined;\r\n}\r\n\r\nexport function getPositionOfCross(wordSquares: GridSquare[], crossSquares: GridSquare[], dir: WordDirection): number {\r\n    return dir === WordDirection.Across ? \r\n            wordSquares[0].row - crossSquares[0].row : \r\n            wordSquares[0].col - crossSquares[0].col;\r\n}\r\n\r\nexport function getAllCrosses(grid: GridState, word: GridWord): GridWord[] {\r\n    let squares = getSquaresForWord(grid, word);\r\n    let crosses = squares\r\n        .map(sq => getWordAtSquare(grid, sq.row, sq.col, otherDir(word.direction)))\r\n        .filter(w => w).map(w => w!);\r\n    return crosses.length > 0 ? crosses : [];\r\n}\r\n\r\nexport function getUnfilledCrosses(grid: GridState, word: GridWord): GridWord[] {\r\n    let squares = getSquaresForWord(grid, word);\r\n    let crosses = squares\r\n        .map(sq => getWordAtSquare(grid, sq.row, sq.col, otherDir(word.direction)))\r\n        .filter(w => w && !isWordFull(getSquaresForWord(grid, w)))\r\n        .map(w => w!);\r\n    return crosses.length > 0 ? crosses : [];\r\n}\r\n\r\nexport function getEligibleCandidates(node: FillNode): EntryCandidate[] {\r\n    if (node.isChainNode) {\r\n        return node.entryCandidates.filter(ec => ec.isViable && !ec.wasChainFailure);\r\n    }\r\n    else {\r\n        return node.entryCandidates.filter(ec => ec.isViable && !ec.hasBeenChained);\r\n    }\r\n}\r\n\r\nfunction chooseEntryFromCandidates(candidates: EntryCandidate[]): EntryCandidate {\r\n    let topScore = candidates[0].score!;\r\n    let total = 0;\r\n    candidates.forEach(c => {\r\n        total += Math.pow(c.score / topScore, 4);\r\n    });\r\n\r\n    let roll = Math.random() * total;\r\n    let runningTotal = 0;\r\n    for (let can of candidates) {\r\n        runningTotal += Math.pow(can.score / topScore, 4);\r\n        if (runningTotal >= roll)\r\n            return can;\r\n    }\r\n\r\n    return candidates[0];\r\n}\r\n\r\nexport function getWordScore(word: string): number {\r\n    let qualityClass = Globals.qualityClasses!.get(word);\r\n    if (!qualityClass) return 0;\r\n\r\n    switch(qualityClass) {\r\n        case QualityClass.Lively: return 12;\r\n        case QualityClass.Normal: return 9;\r\n        case QualityClass.Crosswordese: return 3;\r\n        case QualityClass.Iffy: return 1;\r\n    }\r\n}\r\n","import { FillNode } from \"../models/FillNode\";\r\nimport { GridSquare } from \"../models/GridSquare\";\r\nimport { GridState } from \"../models/GridState\";\r\nimport { GridWord } from \"../models/GridWord\";\r\nimport { SquareType } from \"../models/SquareType\";\r\nimport { WordDirection } from \"../models/WordDirection\";\r\nimport Globals from './windowService';\r\nimport { getSquaresForWord, isBlackSquare, newWord, forAllGridSquares, isWordFull, isWordEmpty, getGrid, \r\n    isUserFilled, deepClone, wordKey, getWordAtSquare, getSquareAtKey, otherDir, squareKey, getSection, mapKeys, \r\n    fullAlphabet, letterListToLetterMatrix, letterMatrixToLetterList } from \"./util\";\r\nimport { SymmetryType } from \"../models/SymmetryType\";\r\nimport { makeNewNode } from \"./fill\";\r\nimport { ContentType } from \"../models/ContentType\";\r\nimport { processAndInsertChosenEntry } from \"./insertEntry\";\r\nimport { queryIndexedWordList } from \"./wordList\";\r\nimport { populateAndScoreEntryCandidates, populateNoHeuristicEntryCandidates } from \"./entryCandidates\";\r\nimport { getSectionsWithSelectedCandidate, getSectionWithCandidate, \r\n    getSelectedSectionCandidatesWithSquare } from \"./section\";\r\nimport { FillStatus } from \"../models/FillStatus\";\r\nimport { SectionCandidate } from \"../models/SectionCandidate\";\r\n\r\nexport function populateWords(grid: GridState) {\r\n    function processSquare(grid: GridState, row: number, col: number, dir: WordDirection) {\r\n        let sq = grid.squares[row][col];\r\n\r\n        if (isBlackSquare(sq)) return;\r\n        if (!currentWord.number && !sq.number) return; // unchecked square\r\n\r\n        if (!currentWord.number) {\r\n            currentWord.number = sq.number;\r\n            currentWord.direction = dir;\r\n            currentWord.start = [row, col]; \r\n        }\r\n\r\n        currentWord.end = [row, col];\r\n\r\n        let nextSq = dir === WordDirection.Across ? [row, col+1] : [row+1, col];\r\n        if (nextSq[0] === grid.height || nextSq[1] === grid.width || isBlackSquare(grid.squares[nextSq[0]][nextSq[1]])) {\r\n            if ((dir === WordDirection.Across && currentWord.end[1] - currentWord.start[1] > 0) ||\r\n                (dir === WordDirection.Down && currentWord.end[0] - currentWord.start[0] > 0))\r\n                grid.words.set(wordKey(currentWord), currentWord);\r\n            currentWord = newWord();\r\n        }\r\n    }\r\n\r\n    grid.words = new Map<string, GridWord>();\r\n\r\n    numberizeGrid(grid);\r\n\r\n    let currentWord: GridWord = newWord();\r\n    for (let row = 0; row < grid.height; row++) {\r\n        for (let col = 0; col < grid.width; col++) {\r\n            processSquare(grid, row, col, WordDirection.Across);\r\n        }\r\n    }\r\n\r\n    for (let col = 0; col < grid.width; col++) {\r\n        for (let row = 0; row < grid.height; row++) {\r\n            processSquare(grid, row, col, WordDirection.Down);\r\n        }\r\n    }\r\n}\r\n\r\nexport function updateGridConstraintInfo(grid: GridState) {\r\n    grid.usedWords = new Map<string, boolean>();\r\n    forAllGridSquares(grid, sq => { sq.viableLetters = undefined; });\r\n\r\n    if (!Globals.wordList) return;\r\n\r\n    let wordKeys = mapKeys(grid.words);\r\n    let sortedWordKeys = wordKeys.filter(k => k.includes(\"A\")).concat(wordKeys.filter(k => k.includes(\"D\")));\r\n    sortedWordKeys.forEach(wordKey => {\r\n        let word = grid.words.get(wordKey)!;\r\n        let newSquares = deepClone(getSquaresForWord(grid, word)) as GridSquare[];\r\n        let letters = getLettersFromSquares(newSquares);\r\n        if (!letters.includes(\"-\")) grid.usedWords.set(letters, true);\r\n        generateConstraintInfoForSquares(newSquares);\r\n        if (newSquares !== undefined && newSquares.length > 0) {\r\n            newSquares.forEach(ns => {\r\n                grid.squares[ns.row][ns.col] = ns;\r\n            });\r\n        }\r\n    });\r\n}\r\n\r\nfunction numberizeGrid(grid: GridState) {\r\n    var currentNumber = 1;\r\n\r\n    for(var row = 0; row < grid.height; row++) {\r\n        for (var col = 0; col < grid.width; col++) {\r\n            var sq = grid.squares[row][col];  \r\n            sq.number = undefined;\r\n\r\n            if (!isBlackSquare(sq)) {\r\n                let isAboveBlocked = (row === 0 || isBlackSquare(grid.squares![row-1][col]));\r\n                let isBelowBlocked = (row === grid.height-1 || isBlackSquare(grid.squares[row+1][col]));\r\n                let isLeftBlocked = (col === 0 || isBlackSquare(grid.squares[row][col-1]));\r\n                let isRightBlocked = (col === grid.width-1 || isBlackSquare(grid.squares[row][col+1]));\r\n\r\n                let isUnchecked = (isAboveBlocked && isBelowBlocked) || (isLeftBlocked && isRightBlocked);\r\n                let isUncheckedStart = (isAboveBlocked && isBelowBlocked && isLeftBlocked && !isRightBlocked) || \r\n                                       (isLeftBlocked && isRightBlocked && isAboveBlocked && !isBelowBlocked);\r\n                let isCheckedStart = isAboveBlocked || isLeftBlocked;\r\n\r\n                if ((isUnchecked && isUncheckedStart) || (!isUnchecked && isCheckedStart)) {\r\n                    sq.number = currentNumber++;\r\n                }\r\n            } \r\n        }\r\n    }\r\n}\r\n\r\nexport function generateConstraintInfoForSquares(squares: GridSquare[]) {\r\n    squares.forEach(sq => {\r\n        if (sq.content) {\r\n            sq.viableLetters = [sq.content];\r\n        }\r\n        else if (!sq.viableLetters) {\r\n            sq.viableLetters = deepClone(fullAlphabet);\r\n        }\r\n    });\r\n    if (isWordEmpty(squares) || isWordFull(squares)) return;\r\n\r\n    let pattern = getLettersFromSquares(squares);\r\n    let entryOptions = queryIndexedWordList(pattern);\r\n    if (entryOptions.length > 500) return;\r\n\r\n    for (let i = 0; i < squares.length; i++) {\r\n        let sq = squares[i];\r\n        if (sq.content) continue;\r\n        let curViableMatrix = sq.viableLetters ? letterListToLetterMatrix(sq.viableLetters) : Array<boolean>(26).fill(true);\r\n        let newViableMatrix = Array<boolean>(26).fill(false);\r\n\r\n        let letters = entryOptions.map(entry => entry[i]);\r\n        letters.forEach(ltr => {\r\n            if (sq.viableLetters && curViableMatrix[ltr.charCodeAt(0) - 65]) return;\r\n            setLettersArrayVal(newViableMatrix, ltr, true);\r\n        });\r\n        sq.viableLetters = letterMatrixToLetterList(newViableMatrix);\r\n    }\r\n}\r\n\r\nexport function getLettersArrayVal(arr: boolean[], ltr: string) {\r\n    return arr[ltr.charCodeAt(0) - 65];\r\n}\r\n\r\nexport function setLettersArrayVal(arr: boolean[], ltr: string, newVal: boolean) {\r\n    arr[ltr.charCodeAt(0) - 65] = newVal;\r\n}\r\n\r\nexport function getConstraintSquareSum(squares: GridSquare[]): number {\r\n    let total = 0;\r\n    squares.forEach(sq => {\r\n        total += sq.viableLetters ? sq.viableLetters.length : 0;\r\n    });\r\n    return total;\r\n}\r\n\r\nexport function getLettersFromSquares(squares: GridSquare[]): string {\r\n    return squares.map(sq => sq.content ? sq.content! : \"-\").join(\"\");\r\n}\r\n\r\nexport function gridToString(grid: GridState): string {\r\n    let chs: string[] = [];\r\n    forAllGridSquares(grid, sq => {\r\n        chs.push(isBlackSquare(sq) ? \".\" : sq.content ? sq.content : \"-\");\r\n    });\r\n    return chs.join(\"\");\r\n}\r\n\r\nexport function createNewGrid(width: number, height: number): GridState {\r\n    let squares: GridSquare[][] = [];\r\n\r\n    for (let row = 0; row < height; row++) {\r\n        squares.push([]);\r\n        for (let col = 0; col < width; col++) {\r\n            squares[row][col] = {\r\n                row: row,\r\n                col: col,\r\n                type: SquareType.White,\r\n                isCircled: false,\r\n                contentType: ContentType.Autofill,\r\n            } as GridSquare;\r\n        }\r\n    }\r\n\r\n    let grid: GridState = {\r\n        height: height,\r\n        width: width,\r\n        squares: squares,\r\n        words: new Map<string, GridWord>(),\r\n        usedWords: new Map<string, boolean>(),\r\n        userFilledSectionCandidates: new Map<string, boolean>(),\r\n    };\r\n\r\n    populateWords(grid);\r\n\r\n    return grid;\r\n}\r\n\r\nexport function getUncheckedSquareDir(grid: GridState, row: number, col: number): WordDirection | undefined {\r\n    if (grid.squares[row][col].type === SquareType.Black) return undefined;\r\n    if ((col === 0 || grid.squares[row][col-1].type === SquareType.Black) &&\r\n        (col === grid.width-1 || grid.squares[row][col+1].type === SquareType.Black))\r\n        return WordDirection.Down;\r\n    if ((row === 0 || grid.squares[row-1][col].type === SquareType.Black) &&\r\n        (row === grid.height-1 || grid.squares[row+1][col].type === SquareType.Black))\r\n        return WordDirection.Across;\r\n\r\n    return undefined;\r\n}\r\n\r\nexport function getSymmetrySquares(initSquare: [number, number]): [number, number][] {\r\n    let grid = getGrid();\r\n    let w = grid.width - 1;\r\n    let h = grid.height - 1;\r\n    let r = initSquare[0];\r\n    let c = initSquare[1];\r\n    let ret = [initSquare];\r\n\r\n    switch (Globals.gridSymmetry!) {\r\n        case SymmetryType.Rotate180:\r\n            ret.push([h - r, w - c]);\r\n            break;\r\n        case SymmetryType.Rotate90:\r\n            ret.push([c, h - r]);\r\n            ret.push([h - r, w - c]);\r\n            ret.push([w - c, r]);\r\n            break;\r\n        case SymmetryType.MirrorHorizontal:\r\n            ret.push([r, w - c]);\r\n            break;\r\n        case SymmetryType.MirrorVertical:\r\n            ret.push([h - r, c]);\r\n            break;\r\n        case SymmetryType.MirrorNWSE:\r\n            ret.push([w - c, h - r]);\r\n            break;\r\n        case SymmetryType.MirrorNESW:\r\n            ret.push([c, r]);\r\n            break;\r\n    }\r\n\r\n    return ret;\r\n}\r\n\r\nexport function insertEntryIntoGrid(node: FillNode, wordKey: string, entry: string, iffyWordKey?: string, contentType?: ContentType) {\r\n    let grid = node.startGrid;\r\n    node.fillWord = grid.words.get(wordKey)!;\r\n    node.chosenEntry = node.entryCandidates.find(ec => ec.word === entry && ec.iffyWordKey === iffyWordKey);\r\n    processAndInsertChosenEntry(node, contentType);\r\n}\r\n\r\nexport function eraseGridSquare(grid: GridState, sq: GridSquare, dir: WordDirection) {\r\n    if (sq.content === undefined) return;\r\n\r\n    let word = getWordAtSquare(grid, sq.row, sq.col, dir)!;\r\n    let squares = word ? getSquaresForWord(grid, word) : [sq];\r\n\r\n    let otherDirWord = getWordAtSquare(grid, sq.row, sq.col, dir)!;\r\n    let otherDirSquares = otherDirWord ? getSquaresForWord(grid, otherDirWord) : [sq];\r\n    if (squares.length > 1 && isWordFull(squares)) grid.usedWords.delete(getLettersFromSquares(squares));\r\n    if (otherDirSquares.length > 1 && isWordFull(otherDirSquares)) grid.usedWords.delete(getLettersFromSquares(otherDirSquares));\r\n\r\n    if (squares.find(sq => sq.contentType === ContentType.Autofill)) {\r\n        ; // autofill is ephemeral, no need to explicitly delete\r\n    }\r\n    else if (squares.find(sq => [ContentType.User, ContentType.ChosenWord].includes(sq.contentType))) {\r\n        let isInSection = getSectionsWithSelectedCandidate().find(sec => sec.squares.has(squareKey(sq)));\r\n\r\n        squares.forEach(wsq => {\r\n            if (wsq.contentType === ContentType.User) return;\r\n            let cross = getWordAtSquare(grid, wsq.row, wsq.col, otherDir(dir))!;\r\n            if (wsq.contentType === ContentType.ChosenWord && !cross) {\r\n                wsq.contentType = ContentType.Autofill;\r\n                return;\r\n            }\r\n            let crossSquares = getSquaresForWord(grid, cross);\r\n            if (crossSquares.find(csq => [ContentType.Autofill, ContentType.ChosenSection].includes(csq.contentType))) {\r\n                if (isInSection)\r\n                    wsq.contentType = ContentType.ChosenSection;\r\n                else\r\n                    wsq.contentType = ContentType.Autofill;\r\n            }\r\n        });\r\n    }\r\n        \r\n    sq.content = undefined;\r\n    sq.contentType = ContentType.Autofill;\r\n    clearFill(grid);\r\n}\r\n\r\nexport function eraseSectionCandidateFromGrid(grid: GridState, sc: SectionCandidate) {\r\n    let section = getSectionWithCandidate(sc);\r\n    Globals.selectedSectionCandidateKeys?.delete(section.id);\r\n    section.squares.forEach((_, sqKey) => {\r\n        let sq = getSquareAtKey(grid, sqKey);\r\n        let scs = getSelectedSectionCandidatesWithSquare(sqKey);\r\n        if (scs.length > 1) return;\r\n        if (sq.contentType === ContentType.ChosenSection)\r\n            sq.contentType = ContentType.Autofill;\r\n    });\r\n}\r\n\r\nexport function clearFill(grid: GridState) {\r\n    Globals.selectedWordNode = undefined;\r\n    let section = getSection();\r\n    section.fillQueue = undefined;\r\n    section.comboPermsQueue = [];\r\n    section.comboPermsUsed = new Map<string, boolean>();\r\n    Globals.fillStatus = Globals.wordList !== undefined ? FillStatus.Ready : FillStatus.NoWordList;\r\n\r\n    forAllGridSquares(grid, sq => {\r\n        if (!isUserFilled(sq)) {\r\n            sq.content = undefined;\r\n        }\r\n    });\r\n\r\n    updateGridConstraintInfo(grid);\r\n}\r\n\r\nexport function updateManualEntryCandidates(grid: GridState) {\r\n    if (!Globals.selectedWordKey || !Globals.wordList) {\r\n        Globals.selectedWordNode = undefined;\r\n        return;\r\n    }\r\n\r\n    let node = makeNewNode(grid, 0, false, undefined);\r\n    node.fillWord = grid.words.get(Globals.selectedWordKey!);\r\n    if (Globals.useManualHeuristics!) {\r\n        populateAndScoreEntryCandidates(node, true);\r\n    }\r\n    else {\r\n        populateNoHeuristicEntryCandidates(node);\r\n    }\r\n    Globals.selectedWordNode = node;\r\n}\r\n","import { CluesViewProp } from \"./CluesViewProp\";\r\nimport React, { createRef, useEffect, useRef, useState } from 'react';\r\nimport \"./CluesView.scss\";\r\nimport { wordKey, deepClone, getSquaresForWord, getGrid, mapValues } from \"../../lib/util\";\r\nimport Globals from '../../lib/windowService';\r\nimport { getLettersFromSquares } from \"../../lib/grid\";\r\nimport { WordDirection } from \"../../models/WordDirection\";\r\n\r\nfunction CluesView(props: any) {\r\n    const [clueProps, setClueProps] = useState(initClueProps());\r\n    const [selectedKey, setSelectedKey] = useState(\"\");\r\n    const textareasRef = useRef([] as any[]);\r\n\r\n    useEffect(() => {\r\n        setClueProps(initClueProps());\r\n        setSelectedKey(Globals.selectedWordKey!);\r\n    }, [props.updateSemaphore])\r\n\r\n    function initClueProps(): CluesViewProp[] {\r\n        let props = [] as CluesViewProp[];\r\n        if (!Globals.puzzle) return props;\r\n\r\n        let grid = getGrid();\r\n        let words = grid.words;\r\n        let clues = Globals.puzzle.clues;\r\n        mapValues(words).sort((a, b) => (a.number || 0) - (b.number || 0)).forEach(word => {\r\n            let key = wordKey(word);\r\n            let squares = getSquaresForWord(grid, word);\r\n            let prop = {\r\n                number: word.number!,\r\n                key: key,\r\n                direction: word.direction,\r\n                clue: clues.get(key)! || \"\",\r\n                entry: getLettersFromSquares(squares),\r\n                isOpenForEditing: false,\r\n            } as CluesViewProp;\r\n            props.push(prop);\r\n        });\r\n        return props;\r\n    }\r\n\r\n    function handleClueClick(event: any) {\r\n        let target = event.target;\r\n        while (![\"clue\"].includes(target.classList[0])) {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n        let targetKey = target.attributes[\"data-key\"].value;\r\n        let refIndex = +target.attributes[\"data-ref-index\"].value;\r\n        let textareaEl = textareasRef.current[refIndex].current;\r\n        \r\n        let newClueProps = deepClone(clueProps) as CluesViewProp[];\r\n        let propToToggle = newClueProps.find(p => p.key === targetKey)!;\r\n        propToToggle.isOpenForEditing = !propToToggle.isOpenForEditing;\r\n        setClueProps(newClueProps);\r\n\r\n        if (propToToggle.isOpenForEditing) {\r\n            textareaEl.value = propToToggle.clue;\r\n            textareaEl.style.display = \"inherit\"; // have to do this before we can autofocus\r\n            textareaEl.focus();\r\n        }\r\n    }\r\n\r\n    function handleKeyDown(event: any) {\r\n        let target = event.target;\r\n        let targetKey: string = target.attributes[\"data-key\"].value;\r\n        let keyPressed: string = event.key.toUpperCase();\r\n\r\n        if (keyPressed === \"ENTER\") {\r\n            applyClueChange(targetKey, target.value);\r\n        }\r\n    }\r\n\r\n    function handleFocus(event: any) {\r\n        event.target.select();\r\n    }\r\n\r\n    function applyClueChange(targetKey: string, newValue: string) {\r\n        let newClueProps = deepClone(clueProps) as CluesViewProp[];\r\n        let targetProp = newClueProps.find(p => p.key === targetKey)!;\r\n        targetProp.clue = newValue === \"(blank clue)\" ? \"\" : newValue;\r\n        targetProp.isOpenForEditing = false;\r\n        Globals.puzzle!.clues.set(targetKey, newValue);\r\n        setClueProps(newClueProps);\r\n    }\r\n\r\n    function renderCluesContainer(isAcross: boolean, clueList: CluesViewProp[], refIndex: number) {\r\n        return (\r\n            <div className=\"clues-container\">\r\n                <div className=\"clues-header\">{isAcross ? \"ACROSS\" : \"DOWN\"}</div>\r\n                <div className=\"clues-clues\">\r\n                    {clueList.map(clue => {\r\n                        textareasRef.current.push(createRef());\r\n                        let ret = (\r\n                            <div key={clue.key}>\r\n                                <div className={\"clue\" + (clue.key === selectedKey ? \" clue-selected\" : \"\")}\r\n                                    data-key={clue.key} onClick={handleClueClick} data-ref-index={refIndex}>\r\n                                    <div className=\"clue-number\">{clue.number}</div>\r\n                                    <div className=\"clue-entry\">{clue.entry}</div>\r\n                                    {clue.entry.length > 15 && <br />}\r\n                                    {clue.clue.length > 0 ? clue.clue : \"(blank clue)\"}\r\n                                </div>\r\n                                <textarea className=\"clue-editor\" defaultValue={clue.clue} data-key={clue.key} \r\n                                    style={{display: clue.isOpenForEditing ? \"inherit\" : \"none\"}}\r\n                                    onKeyDown={handleKeyDown} onFocus={handleFocus}\r\n                                    ref={textareasRef.current[refIndex]}>\r\n                                </textarea>\r\n                            </div>\r\n                        );\r\n                        refIndex++;\r\n                        return ret;\r\n                    })}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    textareasRef.current = [] as any[];\r\n    let acrossClues = clueProps.filter(p => p.direction === WordDirection.Across);\r\n    let downClues = clueProps.filter(p => p.direction === WordDirection.Down);\r\n\r\n    return (\r\n        <div className=\"clues-view\">\r\n            {renderCluesContainer(true, acrossClues, 0)}\r\n            {renderCluesContainer(false, downClues, acrossClues.length)}\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default CluesView;\r\n","import React, { useContext, useState } from 'react';\r\nimport { SymmetryType } from '../../models/SymmetryType';\r\nimport \"./FillView.scss\";\r\nimport Globals from '../../lib/windowService';\r\nimport { FillStatus } from '../../models/FillStatus';\r\nimport { getEntryAtWordKey, getGrid, getSection, getSquaresForWord, mapKeys, mapValues } from '../../lib/util';\r\nimport { calculateSectionOrder, getLongestStackWord, getPhoneticName, insertSectionCandidateIntoGrid, \r\n    makeNewSection, sectionCandidateKey, updateSectionFilters } from '../../lib/section';\r\nimport { clearFill, eraseSectionCandidateFromGrid, getLettersFromSquares, insertEntryIntoGrid, updateGridConstraintInfo, updateManualEntryCandidates } from '../../lib/grid';\r\nimport { fillSectionWord, makeNewNode } from '../../lib/fill';\r\nimport { FillNode } from '../../models/FillNode';\r\nimport { AppContext } from '../../AppContext';\r\nimport { ContentType } from '../../models/ContentType';\r\nimport { Section } from '../../models/Section';\r\nimport { processWordListData } from '../../lib/wordList';\r\nimport { useInterval } from '../../lib/useInterval';\r\nimport { SectionCandidate } from '../../models/SectionCandidate';\r\nimport { QualityClass } from '../../models/QualityClass';\r\n\r\nfunction FillView() {\r\n    const appContext = useContext(AppContext);\r\n    const [showSectionCandidates, setShowSectionCandidates] = useState(true);\r\n    const [isWordListLoading, setIsWordListLoading] = useState(false);\r\n    const [isFillRunning, setIsFillRunning] = useState(false);\r\n\r\n    function triggerUpdate() {\r\n        appContext.triggerUpdate();\r\n    }\r\n\r\n    function setFillStatus(newStatus: FillStatus) {\r\n        Globals.fillStatus = newStatus;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleToggleFill() {\r\n        if (isFillRunning) {\r\n            clearFill(getGrid());\r\n            setFillStatus(FillStatus.Ready);\r\n            setIsFillRunning(false);\r\n            triggerUpdate();\r\n        }\r\n        else {\r\n            setFillStatus(FillStatus.Running);\r\n            setIsFillRunning(true);\r\n        }\r\n    }\r\n    \r\n    function doFillWord() {\r\n        if (Globals.fillStatus === FillStatus.Complete) return;\r\n        if (!fillSectionWord()) {\r\n            clearFill(getGrid());\r\n            setFillStatus(FillStatus.Complete);\r\n            setIsFillRunning(false);\r\n        }\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleFillWordClick(event: any) {\r\n        if (!Globals.wordList) return;\r\n\r\n        if (!fillSectionWord()) {\r\n            clearFill(getGrid());\r\n            setFillStatus(FillStatus.Complete);\r\n        }\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleSymmetryChange(event: any) {\r\n        Globals.gridSymmetry = +SymmetryType[event.target[event.target.selectedIndex].value] as SymmetryType;\r\n    }\r\n\r\n    function handleIffyLengthChange(event: any) {\r\n        Globals.maxIffyLength = +event.target[event.target.selectedIndex].value;\r\n        Globals.manualIffyKey = undefined;\r\n    }\r\n\r\n    function getSymmetryTypeString(type: string): string {\r\n        switch(type) {\r\n            case \"None\": return \"None\";\r\n            case \"Rotate180\": return \"180° Rotational\";\r\n            case \"Rotate90\": return \"90° Rotational\";\r\n            case \"MirrorHorizontal\": return \"Mirror Horizontally\";\r\n            case \"MirrorVertical\": return \"Mirror Vertically\";\r\n            case \"MirrorNWSE\": return \"Mirror NW to SE\";\r\n            case \"MirrorNESW\": return \"Mirror NE to SW\";\r\n        }\r\n        return \"\";\r\n    }\r\n\r\n    function getSymmetryTypesForRectGrids(): string[] {\r\n        return [\"None\", \"Rotate180\", \"MirrorHorizontal\", \"MirrorVertical\"];\r\n    }\r\n\r\n    function getFillStatusString(status: FillStatus): string {\r\n        switch(status) {\r\n            case FillStatus.NoWordList: return \"No Word List Loaded\";\r\n            case FillStatus.Ready: return \"Ready to Fill\";\r\n            case FillStatus.Running: return \"Fill Running...\";\r\n            case FillStatus.Complete: return \"Fill Complete\";\r\n            default: return \"\";\r\n        }\r\n    }\r\n\r\n    function getManualEntryNode(entry: string, iffyWordKey?: string, isHover?: boolean): FillNode {\r\n        let node = Globals.selectedWordNode!;\r\n        let wordKey = Globals.selectedWordKey!;\r\n        insertEntryIntoGrid(node, wordKey, entry, iffyWordKey, isHover ? ContentType.HoverChosenWord : ContentType.ChosenWord);\r\n        return node;\r\n    }\r\n\r\n    function getManualSectionNode(sectionCandidateKey: string, isHover: boolean): FillNode {\r\n        let grid = getGrid();\r\n\r\n        let node = makeNewNode(grid, 0, false, undefined);\r\n        let section = getSection();\r\n        let candidate = section.candidates.get(sectionCandidateKey)!;\r\n        insertSectionCandidateIntoGrid(node.endGrid, candidate, \r\n            isHover ? ContentType.HoverChosenSection : ContentType.ChosenSection);\r\n        return node;\r\n    }\r\n\r\n    function handleEntryCandidateClick(event: any) {\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        if (!Globals.selectedWordKey) return;\r\n\r\n        let entry = target.attributes[\"data-word\"].value as string;\r\n        let iffyWordKey = target.attributes[\"data-iffykey\"].value as string | undefined;\r\n        if (iffyWordKey === \"na\") iffyWordKey = undefined;\r\n        let node = getManualEntryNode(entry, iffyWordKey, false);\r\n\r\n        Globals.manualIffyKey = iffyWordKey;\r\n\r\n        updateManualEntryCandidates(node.endGrid);\r\n\r\n        Globals.activeGrid = node.endGrid;\r\n        updateSectionFilters();\r\n        Globals.hoverGrid = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleEntryCandidateHover(event: any) {\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        if (!Globals.selectedWordKey) return;\r\n\r\n        let entry = target.attributes[\"data-word\"].value as string;\r\n        let iffyWordKey = target.attributes[\"data-iffykey\"].value as string | undefined;\r\n        if (iffyWordKey === \"na\") iffyWordKey = undefined;\r\n        let node = getManualEntryNode(entry, iffyWordKey, true);\r\n\r\n        Globals.hoverGrid = node.endGrid;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleEntryCandidateBlur() {\r\n        Globals.hoverGrid = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleSectionClick(event: any) {\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n            if (target.classList[0] === \"section-checkbox\") return;\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        let sectionId = +target.attributes[\"data-id\"].value;\r\n        clearFill(getGrid());\r\n\r\n        if (sectionId === Globals.activeSectionId!) {\r\n            Globals.activeSectionId = 0;\r\n            Globals.selectedSectionIds = new Map<number, boolean>();\r\n            Globals.selectedSectionIds!.set(sectionId, true);\r\n        }\r\n        else {\r\n            Globals.activeSectionId = sectionId;\r\n            Globals.selectedSectionIds = new Map<number, boolean>();\r\n            Globals.selectedSectionIds!.set(sectionId, true);\r\n        }\r\n\r\n        Globals.hoverGrid = undefined;\r\n        Globals.hoverSectionId = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleSectionCheckClick(event: any) {\r\n        return;\r\n        // let target = event.target;\r\n        // while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n        //     target = target.parentElement;\r\n        //     if (!target) return;\r\n        // }\r\n\r\n        // let sectionId = +target.attributes[\"data-id\"].value;\r\n        // if (Globals.selectedSectionIds!.get(sectionId))\r\n        //     Globals.selectedSectionIds!.delete(sectionId);\r\n        // else\r\n        //     Globals.selectedSectionIds!.set(sectionId, true);\r\n    }\r\n\r\n    function handleSectionHover(event: any) {\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        let sectionId = +target.attributes[\"data-id\"].value;\r\n        Globals.hoverSectionId = sectionId;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleSectionBlur() {\r\n        Globals.hoverSectionId = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleSectionCandidateClick(event: any) {\r\n        function eraseSc() {\r\n            section.selectedCandidate = undefined;\r\n            section.comboPermsQueue = [];\r\n            section.comboPermsUsed = new Map<string, boolean>();\r\n            let sc = section.candidates.get(candidateKey)!;\r\n            eraseSectionCandidateFromGrid(grid, sc);\r\n            clearFill(grid);\r\n        }\r\n\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        let section = getSection();\r\n        let grid = getGrid();\r\n        let candidateKey = target.attributes[\"data-candidate-key\"].value as string;\r\n\r\n        if (section.selectedCandidate === candidateKey) {\r\n            eraseSc();\r\n        }\r\n        else {\r\n            if (section.selectedCandidate) eraseSc();\r\n\r\n            let node = getManualSectionNode(candidateKey, false);\r\n            Globals.selectedSectionCandidateKeys!.set(section.id, candidateKey);\r\n            section.selectedCandidate = candidateKey;\r\n\r\n            updateManualEntryCandidates(node.endGrid);\r\n\r\n            Globals.activeGrid = node.endGrid;\r\n        }\r\n        \r\n        updateSectionFilters();\r\n        Globals.hoverGrid = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleSectionCandidateHover(event: any) {\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || target.classList[0] !== \"fill-list-row-wrapper\") {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        let candidateKey = target.attributes[\"data-candidate-key\"].value as string;\r\n        let node = getManualSectionNode(candidateKey, true);\r\n\r\n        Globals.hoverGrid = node.endGrid;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleShowSectionCandidatesToggle() {\r\n        setShowSectionCandidates(!showSectionCandidates);\r\n    }\r\n\r\n    function clearSectionCandidates() {\r\n        if (!window.confirm(\"Are you sure you want to clear the fills?\")) return;\r\n\r\n        let section = getSection();\r\n        section.candidates = new Map<string, SectionCandidate>();\r\n        section.selectedCandidate = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function handleUseHeuristicsToggle() {\r\n        let newValue = Globals.useManualHeuristics !== undefined ? !Globals.useManualHeuristics! : false;\r\n        Globals.useManualHeuristics = newValue;\r\n\r\n        triggerUpdate();\r\n        let node = Globals.selectedWordNode;\r\n        if (!node) return;\r\n\r\n        updateManualEntryCandidates(grid);\r\n    }\r\n\r\n    function handleSectionCandidateBlur() {\r\n        Globals.hoverGrid = undefined;\r\n        triggerUpdate();\r\n    }\r\n\r\n    function loadWordList() {\r\n        document.getElementById(\"open-wordlist-input\")!.click();\r\n    }\r\n\r\n    function clearWordLists() {\r\n        if (!window.confirm(\"Are you sure you want to clear the word lists?\")) return;\r\n\r\n        Globals.wordList = undefined;\r\n        Globals.wordLists = [];\r\n        setFillStatus(FillStatus.NoWordList);\r\n        Globals.selectedWordNode = undefined;\r\n        Globals.qualityClasses = new Map<string, QualityClass>();\r\n    }\r\n\r\n    function onWordListUpload(event: any) {\r\n        let file = event.target.files[0];\r\n        event.target.value = null;\r\n        setIsWordListLoading(true);\r\n\r\n        setTimeout(() => {\r\n            processWordListData(file.name, file).then(wordList => {\r\n                if (wordList) {\r\n                    Globals.wordLists!.push(wordList);\r\n                    setFillStatus(FillStatus.Ready);\r\n                    let grid = getGrid();\r\n                    updateGridConstraintInfo(grid);\r\n                    updateManualEntryCandidates(grid);\r\n                    setIsWordListLoading(false);\r\n                    triggerUpdate();\r\n                }\r\n            });\r\n        }, 5);\r\n    }\r\n\r\n    useInterval(() => {\r\n        doFillWord();\r\n    }, isFillRunning ? 5 : null);\r\n\r\n    let grid = getGrid();\r\n    let selectedSymmetry = SymmetryType[Globals.gridSymmetry!];\r\n    let symmetryOptions = (!grid || grid.width === grid.height) ?\r\n        Object.values(SymmetryType).filter(t => isNaN(Number(t))) :\r\n        getSymmetryTypesForRectGrids();\r\n\r\n    let fillStatusStr = getFillStatusString(Globals.fillStatus!);\r\n    \r\n    let wordLists = Globals.wordLists || [];\r\n\r\n    let entryCandidates = Globals.selectedWordNode ? Globals.selectedWordNode.entryCandidates : [];\r\n    let isNoEntryCandidates = Globals.selectedWordNode && entryCandidates.length === 0;\r\n\r\n    let sections = [] as Section[];\r\n    if (Globals.sections!) {\r\n        let sectionsOrder = calculateSectionOrder(mapValues(Globals.sections!));\r\n        sections = sectionsOrder.map(id => Globals.sections!.get(id)!);\r\n    }\r\n    let activeSection = Globals.sections ? Globals.sections!.get(Globals.activeSectionId!)! : makeNewSection(-1);\r\n    let selectedScKey = activeSection.selectedCandidate;\r\n    let selectedSectionIds = mapKeys(Globals.selectedSectionIds!) || [0];\r\n    let sectionCandidates = mapValues(activeSection.candidates)\r\n        .filter(sc => !sc.isFilteredOut).sort((a, b) => b.score - a.score);\r\n    let selectedEntry = Globals.selectedWordKey ? getEntryAtWordKey(grid, Globals.selectedWordKey!) : \"\";\r\n    let selectedMaxIffyLength = Globals.maxIffyLength || 0;\r\n    let useManualHeuristics = Globals.useManualHeuristics !== undefined ? Globals.useManualHeuristics : true;\r\n\r\n    let wordListsStyle = {\r\n        gridTemplateColumns: `4fr 1fr`\r\n    } as React.CSSProperties;\r\n\r\n    let entryCandidatesStyle = {\r\n        gridTemplateColumns: `4fr 1fr 2fr`\r\n    } as React.CSSProperties;\r\n\r\n    let sectionsStyle = {\r\n        gridTemplateColumns: `1fr 2fr 1fr 1fr 1fr`\r\n    } as React.CSSProperties;\r\n\r\n    let fillsStyle = {\r\n        gridTemplateColumns: `4fr 1fr 2fr`\r\n    } as React.CSSProperties;\r\n\r\n    return (\r\n        <div id=\"FillView\" className=\"fill-container\">\r\n            <input id=\"open-wordlist-input\" hidden type=\"file\" accept=\".dict,.txt\" onChange={onWordListUpload} />\r\n            <div id=\"loader\" style={{display: isWordListLoading ? \"block\" : \"none\"}}></div>\r\n\r\n            <div className={\"fill-status\" +\r\n                (Globals.fillStatus! === FillStatus.NoWordList ? \" fill-status-red\" :\r\n                Globals.fillStatus! === FillStatus.Running ? \" fill-status-green\" : \"\")}>{fillStatusStr}</div>\r\n            {wordLists.length > 0 &&\r\n            <>\r\n                <div className=\"custom-control custom-switch fill-switch\">\r\n                    <input type=\"checkbox\" className=\"custom-control-input\" id=\"fillSwitch\" \r\n                        checked={isFillRunning} onChange={handleToggleFill} />\r\n                    <label className=\"custom-control-label\" htmlFor=\"fillSwitch\">Fill</label>\r\n                </div>\r\n                <br />\r\n                Max Iffy Length: <br />\r\n                <select className=\"custom-select iffy-select\" defaultValue={selectedMaxIffyLength} onChange={handleIffyLengthChange}>\r\n                    <option value={0} key={0}>Off</option>\r\n                    {[2, 3, 4, 5, 6, 7].map(length => (\r\n                        <option value={length} key={length}>{length}</option>\r\n                    ))}\r\n                </select>\r\n            </>\r\n            }\r\n            \r\n            <br /><br />\r\n            Grid Symmetry: <br />\r\n            <select className=\"custom-select symmetry-select\" defaultValue={selectedSymmetry} onChange={handleSymmetryChange}>\r\n                {symmetryOptions.map(type => (\r\n                    <option value={type} key={type}>{getSymmetryTypeString(type.toString())}</option>\r\n                ))}\r\n            </select>\r\n            <br /><br />\r\n            <button className=\"btn btn-primary\" onClick={handleFillWordClick} style={{display: \"none\"}}>Fill Word</button>\r\n\r\n            <div className=\"fill-lists\">\r\n                <div className=\"fill-list-box\">\r\n                    <div className=\"fill-list-title\">Word Lists</div>\r\n                    <div className=\"fill-list-button\" onClick={clearWordLists}>Clear</div>\r\n                    <div className=\"fill-list-button\" onClick={loadWordList}>Load</div>\r\n                    <div className=\"fill-list\" style={wordListsStyle}>\r\n                        <div className=\"fill-list-header\">Filename</div>\r\n                        <div className=\"fill-list-header\">Count</div>\r\n                        { wordLists.length === 0 && (\r\n                            <div className=\"fill-list-row-wrapper\" style={{cursor: \"auto\"}}>\r\n                                <div><i>No word lists loaded</i></div><div></div>\r\n                            </div>\r\n                        )}\r\n                        { wordLists.map(wl => (\r\n                            <div className=\"fill-list-row-wrapper\" style={{cursor: \"auto\"}} key={wl.filename}>\r\n                                <div>{wl.filename}</div>\r\n                                <div>{wl.wordCount}</div>\r\n                            </div>\r\n                        ))}\r\n                    </div>\r\n                </div>\r\n                <div className=\"fill-list-box\" onMouseOut={handleEntryCandidateBlur}>\r\n                    <div className=\"fill-list-title entry-color\">Entry Candidates</div>\r\n                    <div className=\"fill-sec-checkbox\">\r\n                        <input type=\"checkbox\" className=\"section-checkbox\" id=\"use-heuristics-box\"\r\n                                    checked={useManualHeuristics} onChange={handleUseHeuristicsToggle} />\r\n                        <label htmlFor=\"use-heuristics-box\">Use heuristics</label>\r\n                    </div>\r\n                    <div className=\"fill-list\" style={entryCandidatesStyle}>\r\n                        <div className=\"fill-list-header\">Entry</div>\r\n                        <div className=\"fill-list-header\">Score</div>\r\n                        <div className=\"fill-list-header\">Iffy</div>\r\n                        { isNoEntryCandidates && useManualHeuristics && (\r\n                            <div className=\"fill-list-row-wrapper\">\r\n                                <div><i>No viable entries</i></div><div></div><div></div>\r\n                            </div>\r\n                        )}\r\n                        { entryCandidates.map(ec => (\r\n                            <div className={\"fill-list-row-wrapper\" + (selectedEntry === ec.word ? \" fill-list-row-selected\" : \"\")} \r\n                                key={ec.word + (ec.iffyEntry || \"\")} data-word={ec.word} data-iffykey={ec.iffyWordKey || \"na\"}\r\n                                onClick={handleEntryCandidateClick} onMouseOver={handleEntryCandidateHover}>\r\n                                <div>{ec.word}</div>\r\n                                <div>{ec.score.toFixed(0)}</div>\r\n                                <div>{ec.iffyEntry || \"\"}</div>\r\n                            </div>\r\n                        ))}\r\n                    </div>\r\n                </div>\r\n                <div className=\"fill-list-box\" onMouseOut={handleSectionBlur}>\r\n                    <div className=\"fill-list-title section-color\">Sections</div>\r\n                    <div className=\"fill-list\" style={sectionsStyle}>\r\n                        <div className=\"fill-list-header\">Active</div>\r\n                        <div className=\"fill-list-header\">ID</div>\r\n                        <div className=\"fill-list-header\">Size</div>\r\n                        <div className=\"fill-list-header\">Conn</div>\r\n                        <div className=\"fill-list-header\">Fills</div>\r\n                        { sections.map(sec => (\r\n                            <div className={\"fill-list-row-wrapper\" + (sec.id === activeSection.id ? \" fill-list-row-selected\" : \"\")} \r\n                                key={sec.id} data-id={sec.id} onClick={handleSectionClick} onMouseOver={handleSectionHover}>\r\n                                <div><input type=\"checkbox\" className=\"section-checkbox\"\r\n                                    checked={selectedSectionIds.includes(sec.id)} onChange={handleSectionCheckClick} /></div>\r\n                                <div>{getPhoneticName(sec.id)}</div>\r\n                                <div>{sec.squares.size}</div>\r\n                                <div>{sec.connections.size}</div>\r\n                                <div>{sec.candidates.size}</div>\r\n                            </div>\r\n                        ))}\r\n                    </div>\r\n                </div>\r\n                <div className=\"fill-list-box\" onMouseOut={handleSectionCandidateBlur}>\r\n                    <div className=\"fill-list-title\">Fills {sectionCandidates.length > 0 ? `(${sectionCandidates.length})` : \"\"}</div>\r\n                    <div className=\"fill-list-button\" onClick={clearSectionCandidates}>Clear</div>\r\n                    <div className=\"fill-sec-checkbox\">\r\n                        <input type=\"checkbox\" className=\"section-checkbox\" id=\"show-fills-box\"\r\n                                    checked={showSectionCandidates} onChange={handleShowSectionCandidatesToggle} />\r\n                        <label htmlFor=\"show-fills-box\">Show</label>\r\n                    </div>\r\n                    <div className=\"fill-list\" style={fillsStyle}>\r\n                        <div className=\"fill-list-header\">Longest</div>\r\n                        <div className=\"fill-list-header\">Score</div>\r\n                        <div className=\"fill-list-header\">Iffy</div>\r\n                        {!showSectionCandidates && (\r\n                            <div className=\"fill-list-row-wrapper\">\r\n                                <div><i>Hidden</i></div><div></div><div></div>\r\n                            </div>\r\n                        )}\r\n                        {showSectionCandidates && Globals.fillStatus === FillStatus.Complete && sectionCandidates.length === 0 && (\r\n                            <div className=\"fill-list-row-wrapper\">\r\n                                <div><i>No fills found</i></div><div></div><div></div>\r\n                            </div>\r\n                        )}\r\n                        {showSectionCandidates && sectionCandidates.map(sc => {\r\n                            let entry = getLettersFromSquares(getSquaresForWord(sc.grid, getLongestStackWord(activeSection)));\r\n                            let candidateKey = sectionCandidateKey(activeSection, sc.grid);\r\n\r\n                            return (\r\n                            <div className={\"fill-list-row-wrapper\" + (selectedScKey === candidateKey ? \" fill-list-row-selected\" : \"\")}\r\n                                key={candidateKey} data-candidate-key={candidateKey}\r\n                                onClick={handleSectionCandidateClick} onMouseOver={handleSectionCandidateHover}>\r\n                                <div>{entry}</div>\r\n                                <div>{sc.score.toFixed(2)}</div>\r\n                                <div>{sc.iffyEntry || \"\"}</div>\r\n                            </div>\r\n                        )})}\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default FillView;\r\n","import { useEffect, useRef } from 'react';\r\n\r\nexport function useInterval(callback: () => void, delay: number | null) {\r\n  const savedCallback = useRef<() => void>();\r\n\r\n  // Remember the latest callback.\r\n  useEffect(() => {\r\n    savedCallback.current = callback;\r\n  }, [callback]);\r\n\r\n  // Set up the interval.\r\n  useEffect(() => {\r\n    function tick() {\r\n      if (savedCallback.current) savedCallback.current();\r\n    }\r\n    if (delay !== null) {\r\n      let id = setInterval(tick, delay);\r\n      return () => clearInterval(id);\r\n    }\r\n  }, [delay]);\r\n}\r\n","import React from 'react';\r\nimport { ContentType } from '../../models/ContentType';\r\nimport { QualityClass } from '../../models/QualityClass';\r\nimport { SquareType } from '../../models/SquareType';\r\nimport { SquareProps } from './SquareProps';\r\n\r\nfunction Square(props: SquareProps) {\r\n    return getSquareElement(props);\r\n}\r\n\r\nfunction getSquareElement(props: SquareProps) {\r\n    let content = props.content || \"\";\r\n    if (props.type === SquareType.White) {\r\n        return <div \r\n                    className={\"grid-square\" + \r\n                        (props.isSelected ? \" grid-square-selected\" : \r\n                        props.isInSelectedWord ? \" grid-square-selected-word\" : \r\n                        props.isInSelectedSection ? \" grid-square-selected-section\" : \"\") +\r\n                        (props.content ? \"\" :\r\n                        props.constraintSum === 0 ? \" grid-square-error-word\" :\r\n                        between(props.constraintSum, 1, 1) ? \" grid-square-constrained-5\" : \r\n                        between(props.constraintSum, 1, 3) ? \" grid-square-constrained-4\" : \r\n                        between(props.constraintSum, 1, 5) ? \" grid-square-constrained-3\" : \r\n                        between(props.constraintSum, 1, 10) ? \" grid-square-constrained-2\" : \r\n                        between(props.constraintSum, 1, 15) ? \" grid-square-constrained-1\" : \"\"\r\n                        )} \r\n                    data-row={props.row} data-col={props.col}>\r\n            {props.isCircled && \r\n                <div className=\"grid-square-circled\"></div>\r\n            }\r\n            <div className=\"grid-number\">{props.number ?? \"\"}</div>\r\n            <div className={\"grid-content\" + \r\n                        (content.length > 1 ? \" grid-content-rebus\" : \"\") +\r\n                        (props.content && props.contentType === ContentType.User ? \"\" :\r\n                         props.content && props.contentType === ContentType.ChosenWord ? \" grid-content-chosen-word\" :\r\n                         props.content && props.contentType === ContentType.HoverChosenWord ? \" grid-content-chosen-word-hover\" :\r\n                         props.content && props.contentType === ContentType.ChosenSection ? \" grid-content-chosen-section\" :\r\n                         props.content && props.contentType === ContentType.HoverChosenSection ? \" grid-content-chosen-section-hover\" :\r\n                         props.qualityClass === QualityClass.Lively ? \" grid-content-lively\" :\r\n                         props.qualityClass === QualityClass.Normal ? \" grid-content-normal\" :\r\n                         props.qualityClass === QualityClass.Crosswordese ? \" grid-content-crosswordese\" :\r\n                         props.qualityClass === QualityClass.Iffy ? \" grid-content-iffy\" :\r\n                         props.qualityClass === QualityClass.NotAThing ? \" grid-content-notathing\" : \"\"\r\n                        )}>\r\n                    {content}\r\n            </div>\r\n        </div>\r\n    }\r\n    else {\r\n        return <div className={\"grid-square-black\" + (props.isSelected ? \" grid-square-black-selected\" : \"\")} \r\n            data-row={props.row} data-col={props.col}>\r\n        </div>\r\n    }\r\n}\r\n\r\nfunction between(input: number, min: number, max: number): boolean {\r\n    return input >= min && input <= max;\r\n}\r\n\r\nexport default Square;\r\n","import React, { useContext, useState } from 'react';\r\nimport { SquareType } from '../../models/SquareType';\r\nimport { SquareProps } from '../Square/SquareProps';\r\nimport \"./Grid.scss\";\r\nimport Square from '../Square/Square';\r\nimport { GridState } from '../../models/GridState';\r\nimport { WordDirection } from '../../models/WordDirection';\r\nimport Globals from '../../lib/windowService';\r\nimport { compareTuples, doesWordContainSquare, getGrid, getSection, getSelectedWord, getSquaresForWord, \r\n    getWordAtSquare, initializeSessionGlobals, isWordFull, mapValues, otherDir, \r\n    squareKey, wordKey } from '../../lib/util';\r\nimport { clearFill, eraseGridSquare, getLettersFromSquares, getSymmetrySquares, getUncheckedSquareDir, populateWords, \r\n    updateGridConstraintInfo, updateManualEntryCandidates } from '../../lib/grid';\r\nimport { GridWord } from '../../models/GridWord';\r\nimport { AppContext } from '../../AppContext';\r\nimport { ContentType } from '../../models/ContentType';\r\nimport { updateSectionFilters } from '../../lib/section';\r\nimport { QualityClass } from '../../models/QualityClass';\r\nimport { GridSquare } from '../../models/GridSquare';\r\nimport { Section } from '../../models/Section';\r\n\r\nfunction Grid() {\r\n    const [selectedSquare, setSelectedSquare] = useState([-1, -1] as [number, number]);\r\n    const appContext = useContext(AppContext);\r\n\r\n    function handleClick(event: any) {\r\n        let target = event.target;\r\n        while (target.classList.length < 1 || ![\"grid-square\", \"grid-square-black\"].includes(target.classList[0])) {\r\n            target = target.parentElement;\r\n            if (!target) return;\r\n        }\r\n\r\n        let row = +target.attributes[\"data-row\"].value;\r\n        let col = +target.attributes[\"data-col\"].value;\r\n        let grid = getGrid();\r\n        \r\n        let newDirection = Globals.selectedWordDir || WordDirection.Across;\r\n\r\n        let uncheckedSquareDir = getUncheckedSquareDir(grid, row, col);\r\n        if (uncheckedSquareDir !== undefined) {\r\n            newDirection = uncheckedSquareDir;\r\n            setSelectedSquare([row, col]);\r\n        }\r\n        else if (compareTuples([row, col], selectedSquare)) {\r\n            newDirection = otherDir(newDirection);\r\n        }\r\n        else {\r\n            setSelectedSquare([row, col]);\r\n        }\r\n\r\n        Globals.selectedWordDir = newDirection;\r\n        setSelWordAtSelSquare([row, col]);\r\n\r\n        updateManualEntryCandidates(grid);\r\n\r\n        appContext.triggerUpdate();\r\n    }\r\n    \r\n    function handleKeyDown(event: any) {\r\n        if (!isSquareSelected()) return;\r\n\r\n        let grid = getGrid();\r\n        let row = selectedSquare[0];\r\n        let col = selectedSquare[1];\r\n\r\n        let key: string = event.key.toUpperCase();\r\n        let letterChanged = false;\r\n        let blackSquareChanged = false;\r\n        let sq = grid.squares[row][col];\r\n        let newSelSq = [-1,-1] as [number, number];\r\n\r\n        if (key.match(/^[A-Z]$/)) {\r\n            newSelSq = advanceCursor();\r\n\r\n            if (sq.type === SquareType.Black) return;\r\n            if (sq.content === key && sq.contentType === ContentType.User) return;\r\n\r\n            letterChanged = true;\r\n            if (sq.content !== key && sq.contentType !== ContentType.User)\r\n                eraseGridSquare(grid, sq, Globals.selectedWordDir!);\r\n\r\n            sq = grid.squares[row][col];\r\n            sq.content = key;\r\n            sq.contentType = ContentType.User;\r\n        }\r\n        if (key === \"BACKSPACE\") {\r\n            newSelSq = backupCursor();\r\n\r\n            if (sq.content !== undefined) {\r\n                eraseGridSquare(grid, sq, Globals.selectedWordDir!);\r\n                letterChanged = true;\r\n            }\r\n                \r\n            if (sq.type === SquareType.Black) {\r\n                getSymmetrySquares([row, col]).forEach(res => {\r\n                    let resSq = grid.squares[res[0]][res[1]];\r\n                    resSq.type = SquareType.White;\r\n                });\r\n\r\n                blackSquareChanged = true;\r\n            }\r\n        }\r\n        // toggle black square\r\n        if (key === \".\") {\r\n            newSelSq = advanceCursor();\r\n\r\n            eraseGridSquare(grid, sq, Globals.selectedWordDir!);\r\n\r\n            let newSquareType = sq.type === SquareType.White ? SquareType.Black : SquareType.White;\r\n            getSymmetrySquares([row, col]).forEach(res => {\r\n                let resSq = grid.squares[res[0]][res[1]];\r\n                resSq.type = newSquareType;\r\n            });\r\n\r\n            blackSquareChanged = true;\r\n        }\r\n        // toggle circled square\r\n        if (key === \",\") {\r\n            if (sq.type === SquareType.Black) return;\r\n            sq.isCircled = !sq.isCircled;\r\n            newSelSq = advanceCursor();\r\n            setSelWordAtSelSquare(newSelSq);\r\n        }\r\n\r\n        if (blackSquareChanged) {\r\n            populateWords(grid);\r\n            initializeSessionGlobals();\r\n            clearFill(grid);\r\n            setSelWordAtSelSquare(newSelSq);\r\n            updateGridConstraintInfo(grid);\r\n        }\r\n        else if (letterChanged)  {\r\n            updateSectionFilters();\r\n            updateGridConstraintInfo(grid);\r\n        }\r\n\r\n        updateManualEntryCandidates(grid);\r\n\r\n        appContext.triggerUpdate();\r\n    }\r\n\r\n    function advanceCursor(): [number, number] {\r\n        let selSq = selectedSquare;\r\n        if (!isSquareSelected()) return selSq;\r\n    \r\n        let grid = getGrid();\r\n        let dir = Globals.selectedWordDir!;\r\n        if ((dir === WordDirection.Across && selSq[1] === grid.width-1) || (dir === WordDirection.Down && selSq[0] === grid.height-1))\r\n            return selSq;\r\n\r\n        let newSelSq = (dir === WordDirection.Across ? [selSq[0], selSq[1] + 1] : [selSq[0] + 1, selSq[1]]) as [number, number];\r\n        setSelectedSquare(newSelSq);\r\n        setSelWordAtSelSquare(newSelSq);\r\n        return newSelSq;\r\n    }\r\n    \r\n    function backupCursor(): [number, number] {\r\n        let selSq = selectedSquare;\r\n        if (!isSquareSelected()) return selSq;\r\n    \r\n        let dir = Globals.selectedWordDir!;\r\n        if ((dir === WordDirection.Across && selSq[1] === 0) || (dir === WordDirection.Down && selSq[0] === 0))\r\n            return selSq;\r\n\r\n        let newSelSq = (dir === WordDirection.Across ? [selSq[0], selSq[1] - 1] : [selSq[0] - 1, selSq[1]]) as [number, number];\r\n        setSelectedSquare(newSelSq);\r\n        setSelWordAtSelSquare(newSelSq);\r\n        return newSelSq;\r\n    }\r\n\r\n    function isSquareSelected(): boolean {\r\n        return selectedSquare[0] > -1;\r\n    }\r\n    \r\n    function isWordSelected(): boolean {\r\n        return !!getSelectedWord();\r\n    }\r\n\r\n    function isSquareInSection(section: Section, sq: GridSquare): boolean {\r\n        return section.squares.has(squareKey(sq));\r\n    }\r\n\r\n    function setSelWordAtSelSquare(newSelSquare: [number, number]) {\r\n        let grid = getGrid();\r\n        let word = getWordAtSquare(grid, newSelSquare[0], newSelSquare[1], Globals.selectedWordDir!);\r\n        Globals.selectedWordKey = word ? wordKey(word) : undefined;\r\n    }\r\n\r\n    function getSquareProps(grid: GridState, row: number, col: number, \r\n        selectedSquare: [number, number], selectedWord: GridWord | undefined): SquareProps {\r\n        let square = grid.squares[row][col];\r\n    \r\n        return {\r\n            key: `${row},${col}`,\r\n            row: row,\r\n            col: col,\r\n            number: square.number,\r\n            type: square.type,\r\n            content: square.content,\r\n            contentType: square.contentType,\r\n            qualityClass: qualityClassMap.get(squareKey(square)) || QualityClass.Normal,\r\n            isSelected: isSquareSelected() && compareTuples(selectedSquare, [row, col]),\r\n            isInSelectedWord: isWordSelected() && doesWordContainSquare(selectedWord!, row, col),\r\n            isInSelectedSection: (Globals.activeSectionId !== 0 && isSquareInSection(getSection(), square)) ||\r\n                (Globals.hoverSectionId !== undefined && isSquareInSection(Globals.sections!.get(Globals.hoverSectionId)!, square)),\r\n            constraintSum: square.viableLetters ? square.viableLetters.length : 26,\r\n            isCircled: square.isCircled,\r\n        };\r\n    }\r\n\r\n    function getSquareElement(props: SquareProps) {\r\n        return <Square {...props}></Square>\r\n    }\r\n\r\n    function suppressEnterKey(event: any) {\r\n        let keyPressed: string = event.key.toUpperCase();\r\n\r\n        if (keyPressed === \"ENTER\") {\r\n            event.preventDefault();\r\n        }\r\n    }\r\n\r\n    function handleFocus(event: any) {\r\n        selectElementContents(event.target);\r\n    }\r\n\r\n    // https://stackoverflow.com/questions/6139107/programmatically-select-text-in-a-contenteditable-html-element/6150060#6150060\r\n    function selectElementContents(el: any) {\r\n        var range = document.createRange();\r\n        range.selectNodeContents(el);\r\n        var sel = window.getSelection();\r\n        sel!.removeAllRanges();\r\n        sel!.addRange(range);\r\n    }\r\n\r\n    function setTitle() {\r\n        let newTitle = document.getElementById(\"puzzleTitle\")!.innerText;\r\n        Globals.puzzle!.title = newTitle === \"(title)\" ? \"Untitled\" : newTitle;\r\n    }\r\n\r\n    function setAuthor() {\r\n        let newAuthor = document.getElementById(\"puzzleAuthor\")!.innerText;\r\n        Globals.puzzle!.author = newAuthor === \"(author)\" ? \"\" : newAuthor;\r\n    }\r\n\r\n    function setCopyright() {\r\n        let newCopyright = document.getElementById(\"puzzleCopyright\")!.innerText;\r\n        Globals.puzzle!.copyright = newCopyright === \"© copyright\" ? \"\" : newCopyright;\r\n    }\r\n\r\n    function setNotes() {\r\n        let newNotes = document.getElementById(\"puzzleNotes\")!.innerText;\r\n        Globals.puzzle!.notes = newNotes === \"(notes)\" ? \"\" : newNotes;\r\n    }\r\n\r\n    function generateQualityClassMap(grid: GridState): Map<string, QualityClass> {\r\n        let ret = new Map<string, QualityClass>();\r\n\r\n        let acrossWords = mapValues(grid.words).filter(w => w.direction === WordDirection.Across);\r\n        acrossWords.forEach(w => {\r\n            let squares = getSquaresForWord(grid, w);\r\n            if (isWordFull(squares)) {\r\n                let letters = getLettersFromSquares(squares);\r\n                let qc = Globals.qualityClasses ? Globals.qualityClasses!.get(letters) : QualityClass.Normal;\r\n                squares.forEach(sq => {\r\n                    if (sq.contentType === ContentType.Autofill)\r\n                        ret.set(squareKey(sq), qc || QualityClass.Iffy);\r\n                });\r\n            }\r\n        });\r\n\r\n        let downWords = mapValues(grid.words).filter(w => w.direction === WordDirection.Down);\r\n        downWords.forEach(w => {\r\n            let squares = getSquaresForWord(grid, w);\r\n            if (isWordFull(squares)) {\r\n                let letters = getLettersFromSquares(squares);\r\n                let qc = Globals.qualityClasses ? Globals.qualityClasses!.get(letters) : QualityClass.Normal;\r\n                squares.forEach(sq => {\r\n                    if (sq.contentType === ContentType.Autofill) {\r\n                        let curQc = ret.get(squareKey(sq)) || QualityClass.Normal;\r\n                        if (!qc || qc < curQc)\r\n                            ret.set(squareKey(sq), qc || QualityClass.Iffy);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n\r\n        return ret;\r\n    }\r\n\r\n    let puzzle = Globals.puzzle!;\r\n    let grid = Globals.hoverGrid ? Globals.hoverGrid! : getGrid();\r\n    let qualityClassMap = generateQualityClassMap(grid);\r\n\r\n    let squareElements = [];\r\n    for (let row = 0; row < grid.height; row++) {\r\n        for (let col = 0; col < grid.width; col++) {\r\n            let sqProps = getSquareProps(grid, row, col, selectedSquare, getSelectedWord());\r\n            squareElements.push(getSquareElement(sqProps));\r\n        }\r\n    }\r\n\r\n    let columnTemplateStyle = {\r\n        gridTemplateColumns: `repeat(${grid.width}, 1fr)`\r\n    } as React.CSSProperties;\r\n\r\n    return (\r\n        <>\r\n            <div className=\"puzzle-author-by\">&nbsp;</div>\r\n            <div id=\"puzzleTitle\" className=\"puzzle-title editable\" contentEditable={true} suppressContentEditableWarning={true}\r\n                onKeyDown={suppressEnterKey} onBlur={setTitle} onFocusCapture={handleFocus}>{puzzle.title || \"(title)\"}</div>\r\n            <div className=\"puzzle-author-by\">by&nbsp;</div>\r\n            <div id=\"puzzleAuthor\" className=\"puzzle-author editable\" contentEditable={true} suppressContentEditableWarning={true}\r\n                onKeyDown={suppressEnterKey} onBlur={setAuthor} onFocusCapture={handleFocus}>{puzzle.author || \"(author)\"}</div>\r\n            <div className=\"puzzle-author-by\">&nbsp;</div>\r\n            <div id=\"puzzleCopyright\" className=\"puzzle-copyright editable\" contentEditable={true} suppressContentEditableWarning={true}\r\n                onKeyDown={suppressEnterKey} onBlur={setCopyright} onFocusCapture={handleFocus}>{puzzle.copyright || \"© copyright\"}</div>\r\n            \r\n            <div id=\"Grid\" className=\"grid-container\" style={columnTemplateStyle}\r\n                onClick={handleClick} onKeyDown={handleKeyDown} tabIndex={0}>\r\n                {squareElements}\r\n            </div>\r\n\r\n            <div className=\"puzzle-notes-label\">Notes:</div>\r\n            <div id=\"puzzleNotes\" className=\"puzzle-notes editable\" contentEditable={true} suppressContentEditableWarning={true}\r\n                onKeyDown={suppressEnterKey} onBlur={setNotes} onFocusCapture={handleFocus}>{puzzle.notes || \"(notes)\"}</div>\r\n        </>\r\n    );\r\n}\r\n\r\nexport default Grid;\r\n","import { ContentType } from \"../models/ContentType\";\r\nimport { GridWord } from \"../models/GridWord\";\r\nimport { Puzzle } from \"../models/Puzzle\";\r\nimport { SquareType } from \"../models/SquareType\";\r\nimport { WordDirection } from \"../models/WordDirection\";\r\nimport { createNewGrid, populateWords } from \"./grid\";\r\nimport { deepClone, getGrid, mapValues, newPuzzle, wordKey } from \"./util\";\r\nimport Globals from '../lib/windowService';\r\n\r\n// https://code.google.com/archive/p/puz/wikis/FileFormat.wiki\r\n\r\nexport async function loadPuzFile(url: string): Promise<Puzzle | undefined> {\r\n    let response = await fetch(url);\r\n    let data: Blob = await response.blob();\r\n\r\n    return processPuzData(data);\r\n}\r\n\r\nexport async function processPuzData(data: Blob): Promise<Puzzle | undefined> {\r\n    let magicString = await data.slice(0x02, 0x0e).text();\r\n    if (magicString !== \"ACROSS&DOWN\\0\") return undefined;\r\n\r\n    let width = new Uint8Array(await data.slice(0x2c, 0x2d).arrayBuffer())[0];\r\n    let height = new Uint8Array(await data.slice(0x2d, 0x2e).arrayBuffer())[0];\r\n\r\n    let puzzle = newPuzzle();\r\n    let restOfFile = await blobToText(await data.slice(0x34, data.size));\r\n    let grid = createNewGrid(width, height);\r\n\r\n    let i = 0;\r\n    for (let row = 0; row < height; row++) {\r\n        for (let col = 0; col < width; col++) {\r\n            let curChar = restOfFile[i];\r\n            let square = grid.squares[row][col];\r\n            if (curChar === \".\")\r\n                square.type = SquareType.Black;\r\n            if (curChar === \"-\") {} // no data entered\r\n            if (curChar.match(/[A-Z]/)) {\r\n                square.content = curChar;\r\n                square.contentType = ContentType.User;\r\n            }\r\n            i++;\r\n        }\r\n    }\r\n    i *= 2; // skip over user progress\r\n\r\n    populateWords(grid);\r\n    \r\n    [puzzle.title, i] = getNextString(restOfFile, i);\r\n    [puzzle.author, i] = getNextString(restOfFile, i);\r\n    [puzzle.copyright, i] = getNextString(restOfFile, i);\r\n\r\n    let sortedWords = sortWordsForPuz(mapValues(grid.words));\r\n    sortedWords.forEach(word => {\r\n        let clue = \"\";\r\n        [clue, i] = getNextString(restOfFile, i);\r\n        let key = wordKey(word);\r\n        puzzle.clues.set(key, clue);\r\n    });\r\n\r\n    [puzzle.notes, i] = getNextString(restOfFile, i);\r\n\r\n    let rebusSquareMappings = new Map<string, number>();\r\n    let rebusValues = new Map<number, string>();\r\n\r\n    while (i < restOfFile.length) {\r\n        let sectionType = restOfFile.slice(i, i+4);\r\n        i += 4;\r\n        let dlI = 0x34 + i;\r\n        let dataLength = new Uint16Array(await data.slice(dlI, dlI+2).arrayBuffer())[0];\r\n        i += 2;\r\n        i += 2; // skip checksum\r\n\r\n        if (sectionType === \"GRBS\") { // rebus grid\r\n            let secI = 0x34 + i;\r\n            for (let row = 0; row < height; row++) {\r\n                for (let col = 0; col < width; col++) {\r\n                    let n = new Uint8Array(await data.slice(secI, secI + 1).arrayBuffer())[0];\r\n                    secI++;\r\n                    if (n > 0) {\r\n                        rebusSquareMappings.set(`${row},${col}`, n-1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (sectionType === \"RTBL\") { // rebus values\r\n            let valuesStr = restOfFile.slice(i, i + dataLength);\r\n            let valueStrs = valuesStr.split(\";\");\r\n            valueStrs.forEach(str => {\r\n                let tokens = str.split(\":\");\r\n                let n = +tokens[0].trim();\r\n                let val = tokens[1];\r\n                if (n > 0) rebusValues.set(n, val);\r\n            });\r\n        }\r\n        if (sectionType === \"GEXT\") { // extra flags\r\n            let secI = 0x34 + i;\r\n            for (let row = 0; row < height; row++) {\r\n                for (let col = 0; col < width; col++) {\r\n                    let n = new Uint8Array(await data.slice(secI, secI + 1).arrayBuffer())[0];\r\n                    secI++;\r\n                    if (n & 0x80) {\r\n                        grid.squares[row][col].isCircled = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        i += dataLength + 1;\r\n    }\r\n\r\n    if (rebusSquareMappings.size > 0) {\r\n        rebusSquareMappings.forEach((v, k) => {\r\n            let tokens = k.split(\",\");\r\n            let square = grid.squares[+tokens[0]][+tokens[1]];\r\n            square.content = rebusValues.get(v)![0]; // TODO: Use full value when we have rebus support\r\n            square.contentType = ContentType.User;\r\n        });\r\n    }\r\n\r\n    Globals.activeGrid = grid;\r\n    return puzzle;\r\n}\r\n\r\nasync function blobToText(blob: Blob): Promise<string> {\r\n    let arr = Array.from(new Uint8Array(await blob.arrayBuffer()));\r\n    return arr.map(x => String.fromCharCode(x)).join(\"\");\r\n}\r\n\r\nfunction getNextString(data: string, i: number): [string, number] {\r\n    let ret = \"\";\r\n    while(data[i] !== \"\\0\") {\r\n        ret += data[i];\r\n        i++;\r\n    }\r\n    i++;\r\n    return [ret.trim(), i];\r\n}\r\n\r\nexport function generatePuzFile(puzzle: Puzzle): Blob {\r\n    let grid = getGrid();\r\n    let bytes = new Uint8Array(128_000);\r\n    insertString(bytes, \"ACROSS&DOWN\\0\", 0x02);\r\n    insertString(bytes, \"1.3\\0\", 0x18);\r\n\r\n    insertNumber(bytes, grid.width, 0x2c, 1);\r\n    insertNumber(bytes, grid.height, 0x2d, 1);\r\n    insertNumber(bytes, grid.words.size, 0x2e, 2);\r\n    insertNumber(bytes, 1, 0x30, 2);\r\n    insertNumber(bytes, 0, 0x32, 2);\r\n\r\n    let pos = 0x34;\r\n    let solutionPos = pos;\r\n    let areCircledSquares = false;\r\n    for (let row = 0; row < grid.height; row++) {\r\n        for (let col = 0; col < grid.width; col++) {\r\n            let sq = grid.squares[row][col];\r\n            let char = sq.type === SquareType.Black ? \".\" : sq.content ? sq.content : \" \";\r\n            insertString(bytes, char, pos);\r\n            pos++;\r\n\r\n            if (sq.isCircled) areCircledSquares = true;\r\n        }\r\n    }\r\n    let gridPos = pos;\r\n    for (let row = 0; row < grid.height; row++) {\r\n        for (let col = 0; col < grid.width; col++) {\r\n            let sq = grid.squares[row][col];\r\n            let char = sq.type === SquareType.Black ? \".\" : \"-\";\r\n            insertString(bytes, char, pos);\r\n            pos++;\r\n        }\r\n    }\r\n\r\n    let titlePos = pos;\r\n    insertString(bytes, puzzle.title + \"\\0\", pos);\r\n    pos += puzzle.title.length + 1;\r\n    let authorPos = pos;\r\n    insertString(bytes, puzzle.author + \"\\0\", pos);\r\n    pos += puzzle.author.length + 1;\r\n    let copyrightPos = pos;\r\n    insertString(bytes, puzzle.copyright + \"\\0\", pos);\r\n    pos += puzzle.copyright.length + 1;\r\n\r\n    let orderedClues = [] as string[];\r\n    let sortedWords = sortWordsForPuz(mapValues(grid.words));\r\n    sortedWords.forEach(word => {\r\n        let key = wordKey(word);\r\n        orderedClues.push(puzzle.clues.get(key)! || \"\");\r\n    });\r\n\r\n    let cluesPos = pos;\r\n    orderedClues.forEach(oc => {\r\n        insertString(bytes, oc + \"\\0\", pos);\r\n        pos += oc.length + 1;\r\n    });\r\n\r\n    insertString(bytes, puzzle.notes + \"\\0\", pos);\r\n    pos++;\r\n\r\n    if (areCircledSquares) {\r\n        let sectionSize = grid.width * grid.height;\r\n        insertString(bytes, \"GEXT\", pos);\r\n        pos += 4;\r\n        insertNumber(bytes, sectionSize, pos, 2);\r\n        pos += 2;\r\n        let checksumPos = pos;\r\n        pos += 2;\r\n        for (let row = 0; row < grid.height; row++) {\r\n            for (let col = 0; col < grid.width; col++) {\r\n                let sq = grid.squares[row][col];\r\n                insertNumber(bytes, sq.isCircled ? 0x80 : 0, pos, 1);\r\n                pos++;\r\n            }\r\n        }\r\n        insertString(bytes, \"\\0\", pos);\r\n        pos++;\r\n\r\n        let cksum = cksum_region(bytes, checksumPos + 2, sectionSize, 0);\r\n        insertNumber(bytes, cksum, checksumPos, 2);\r\n    }\r\n\r\n    let c_cib = cksum_region(bytes, 0x2c, 8, 0);\r\n    let cksum = c_cib;\r\n    let squaresTotal = grid.width*grid.height;\r\n    cksum = cksum_region(bytes, solutionPos, squaresTotal, cksum);\r\n    cksum = cksum_region(bytes, gridPos, squaresTotal, cksum);\r\n    if (puzzle.title.length > 0) cksum = cksum_region(bytes, titlePos, puzzle.title.length+1, cksum);\r\n    if (puzzle.author.length > 0) cksum = cksum_region(bytes, authorPos, puzzle.author.length+1, cksum);\r\n    if (puzzle.copyright.length > 0) cksum = cksum_region(bytes, copyrightPos, puzzle.copyright.length+1, cksum);\r\n    let cluePos = cluesPos;\r\n    for(let i = 0; i < orderedClues.length; i++) {\r\n        let clue = orderedClues[i];\r\n        cksum = cksum_region(bytes, cluePos, clue.length, cksum);\r\n        cluePos += clue.length+1;\r\n    }\r\n    insertNumber(bytes, c_cib, 0x0e, 2);\r\n    insertNumber(bytes, cksum, 0x00, 2);\r\n\r\n    let c_sol = cksum_region(bytes, solutionPos, squaresTotal, 0);\r\n    let c_grid = cksum_region(bytes, gridPos, squaresTotal, 0);\r\n    let c_part = 0;\r\n    if (puzzle.title.length > 0) c_part = cksum_region(bytes, titlePos, puzzle.title.length+1, c_part);\r\n    if (puzzle.author.length > 0) c_part= cksum_region(bytes, authorPos, puzzle.author.length+1, c_part);\r\n    if (puzzle.copyright.length > 0) c_part = cksum_region(bytes, copyrightPos, puzzle.copyright.length+1, c_part);\r\n    cluePos = cluesPos;\r\n    for(let i = 0; i < orderedClues.length; i++) {\r\n        let clue = orderedClues[i];\r\n        c_part = cksum_region(bytes, cluePos, clue.length, c_part);\r\n        cluePos += clue.length+1;\r\n    }\r\n    insertNumber(bytes, 0x49 ^ (c_cib & 0xFF), 0x10, 1);\r\n    insertNumber(bytes, 0x43 ^ (c_sol & 0xFF), 0x11, 1);\r\n    insertNumber(bytes, 0x48 ^ (c_grid & 0xFF), 0x12, 1);\r\n    insertNumber(bytes, 0x45 ^ (c_part & 0xFF), 0x13, 1);\r\n    insertNumber(bytes, 0x41 ^ ((c_cib & 0xFF00) >> 8), 0x14, 1);\r\n    insertNumber(bytes, 0x54 ^ ((c_sol & 0xFF00) >> 8), 0x15, 1);\r\n    insertNumber(bytes, 0x45 ^ ((c_grid & 0xFF00) >> 8), 0x16, 1);\r\n    insertNumber(bytes, 0x44 ^ ((c_part & 0xFF00) >> 8), 0x17, 1);\r\n\r\n    let finalArray = bytes.slice(0, pos);\r\n    return new Blob([finalArray], {type: \"application/octet-stream; charset=ISO-8859-1\"});\r\n}\r\n\r\n// http://www.keiranking.com/phil/\r\nfunction cksum_region(bytes: Uint8Array, startPos: number, len: number, cksum: number) {\r\n    for (let i = 0; i < len; i++) {\r\n        cksum = (cksum >> 1) | ((cksum & 1) << 15);\r\n        cksum = (cksum + bytes[startPos + i]) & 0xffff;\r\n    }\r\n    \r\n    return cksum; \r\n}\r\n\r\nfunction insertString(bytes: Uint8Array, str: string, pos: number) {\r\n    for (let i = 0; i < str.length; i++) {\r\n        bytes[pos] = str[i].charCodeAt(0);\r\n        pos++;\r\n    }\r\n}\r\n\r\nfunction insertNumber(bytes: Uint8Array, n: number, pos: number, size: number) {\r\n    for (var index = size-1; index >= 0; --index) {\r\n      bytes[pos] = n % 256;\r\n      n = n >> 8;\r\n      pos++;\r\n    }\r\n}\r\n\r\nfunction sortWordsForPuz(words: GridWord[]): GridWord[] {\r\n    let sortedWords = (deepClone(words) as GridWord[]).sort((a, b) => {\r\n        if (a.start[0] !== b.start[0]) return a.start[0] - b.start[0];\r\n        if (a.start[1] !== b.start[1]) return a.start[1] - b.start[1];\r\n        return a.direction === WordDirection.Across ? -1 : 1;\r\n    });\r\n    return sortedWords;\r\n}\r\n","import React, { createRef, useContext, useRef } from 'react';\r\nimport \"./Menu.scss\";\r\nimport { MenuProps } from './MenuProps';\r\nimport { AppContext } from '../../AppContext';\r\nimport { processPuzData } from '../../lib/puzFiles';\r\n\r\nfunction Menu(props: MenuProps) {\r\n    const appContext = useContext(AppContext);\r\n    const sizeRefs = useRef([createRef(), createRef()] as any[]);\r\n\r\n    function handleViewChange(event: any) {\r\n        let target = event.target;\r\n        let newView = target.attributes[\"data-view-id\"].value;\r\n        \r\n        appContext.switchActiveView(newView);\r\n    }\r\n\r\n    function handleNewPuzzle() {\r\n        if (!window.confirm(\"Are you sure you want to start a new puzzle?\")) return;\r\n\r\n        let newWidth = +sizeRefs.current[0].current.value;\r\n        let newHeight = +sizeRefs.current[1].current.value;\r\n\r\n        appContext.createNewPuzzle(newWidth, newHeight);\r\n    }\r\n\r\n    function handleLoadPuz() {\r\n        document.getElementById(\"open-puzzle-input\")!.click();\r\n    }\r\n\r\n    function handleExportPuz() {\r\n        appContext.exportPuz();\r\n    }\r\n\r\n    function handleFocus(event: any) {\r\n        event.target.select();\r\n    }\r\n\r\n    function onFileUpload(event: any) {\r\n        let file = event.target.files[0];\r\n        event.target.value = null;\r\n\r\n        processPuzData(file).then(puzzle => {\r\n            if (puzzle) {\r\n                appContext.setPuzzle(puzzle);\r\n            }\r\n        });\r\n    }\r\n\r\n    return (\r\n        <div id=\"Menu\">\r\n            <input id=\"open-puzzle-input\" hidden type=\"file\" accept=\".puz\" onChange={onFileUpload} />\r\n\r\n            <div className=\"site-title\">CrossHatch</div>\r\n\r\n            <div className=\"menu-label\">View: </div>\r\n            <div className=\"btn-group\" role=\"group\" id=\"view-change-group\">\r\n                <button type=\"button\" data-view-id=\"Clues\"\r\n                    className={\"btn\" + (props.openView === \"Clues\" ? \" btn-primary\" : \" btn-secondary\")}\r\n                    onClick={handleViewChange}>\r\n                    Clues\r\n                </button>\r\n                <button type=\"button\" data-view-id=\"Fill\"\r\n                    className={\"btn\" + (props.openView === \"Fill\" ? \" btn-primary\" : \" btn-secondary\")}\r\n                    onClick={handleViewChange}>\r\n                    Fill\r\n                </button>\r\n            </div>\r\n            \r\n            <div className=\"new-grid-group\">\r\n                <div className=\"btn btn-primary\" onClick={handleNewPuzzle}>New Puzzle</div>\r\n                <input type=\"text\" className=\"form-control\" defaultValue={props.gridWidth} onFocus={handleFocus}\r\n                    ref={sizeRefs.current[0]}></input>\r\n                <div className=\"menu-gridsize-sep\"><div style={{height:\"6px\", float:\"none\"}}></div>x</div>\r\n                <input type=\"text\" className=\"form-control\" defaultValue={props.gridHeight} onFocus={handleFocus}\r\n                    ref={sizeRefs.current[1]}></input>\r\n            </div>\r\n            \r\n            <div id=\"loadPuz\" className=\"btn btn-primary menu-button\" onClick={handleLoadPuz}>Load .puz</div>\r\n            <div id=\"exportPuz\" className=\"btn btn-primary menu-button\" onClick={handleExportPuz}>Export .puz</div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Menu;\r\n","import React, { useEffect, useState } from 'react';\r\nimport { AppContext } from './AppContext';\r\nimport { AppProps } from './AppProps';\r\nimport CluesView from './components/CluesView/CluesView';\r\nimport FillView from './components/FillView/FillView';\r\nimport Grid from './components/Grid/Grid';\r\nimport Menu from './components/Menu/Menu';\r\nimport Globals from './lib/windowService';\r\nimport \"./App.scss\";\r\nimport { Puzzle } from './models/Puzzle';\r\nimport { getGrid, initializeSessionGlobals, newPuzzle } from './lib/util';\r\nimport { generatePuzFile } from './lib/puzFiles';\r\nimport { SymmetryType } from './models/SymmetryType';\r\nimport { clearFill, createNewGrid } from './lib/grid';\r\nimport { WordDirection } from './models/WordDirection';\r\nimport { FillStatus } from './models/FillStatus';\r\n\r\nfunction App(props: AppProps) {\r\n  const [activeView, setActiveView] = useState(props.activeView);\r\n  const [gridWidth, setGridWidth] = useState(7);\r\n  const [gridHeight, setGridHeight] = useState(7);\r\n  const [updateSemaphore, setUpdateSemaphore] = useState(0);\r\n  const [appState, setAppState] = useState(getAppContext());\r\n\r\n  useEffect(() => {\r\n    setAppState(getAppContext());\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [updateSemaphore]);\r\n\r\n  function getAppContext() {\r\n    return { \r\n      triggerUpdate: triggerUpdate,\r\n      switchActiveView: switchActiveView,\r\n      setPuzzle: setPuzzle,\r\n      createNewPuzzle: createNewPuzzle,\r\n      exportPuz: exportPuz,\r\n    }\r\n  }\r\n\r\n  function triggerUpdate() {\r\n    setUpdateSemaphore(updateSemaphore + 1);\r\n  }\r\n\r\n  function switchActiveView(newView: string) {\r\n    setActiveView(newView);\r\n  }\r\n\r\n  function createNewPuzzle(width: number, height: number) {\r\n    initializeGlobals(undefined, width, height);\r\n    triggerUpdate();\r\n  }\r\n\r\n  function setPuzzle(puzzle: Puzzle) {\r\n    let grid = getGrid();\r\n    initializeGlobals(puzzle, grid.width, grid.height);\r\n    triggerUpdate();\r\n  }\r\n\r\n  function exportPuz() {\r\n    let puzzle = Globals.puzzle!;\r\n    let blob = generatePuzFile(puzzle);\r\n    let filename = (puzzle.title || \"Untitled\")+\".puz\";\r\n    let file = new File([blob], filename);\r\n    const url= window.URL.createObjectURL(file);\r\n    let puzzleLink = document.getElementById(\"download-puzzle-link\");\r\n    puzzleLink!.setAttribute(\"href\", url);\r\n    puzzleLink!.setAttribute(\"download\", filename);\r\n    puzzleLink!.click();\r\n  }\r\n\r\n  function initializeGlobals(puzzle?: Puzzle, width?: number, height?: number) {\r\n    let isNewPuzzle = !!puzzle;\r\n    Globals.puzzle = puzzle || newPuzzle();\r\n    if (width === undefined) width = gridWidth;\r\n    if (height === undefined) height = gridHeight;\r\n    if (!Globals.activeGrid || !isNewPuzzle)\r\n      Globals.activeGrid = createNewGrid(width, height);\r\n    Globals.hoverGrid = undefined;\r\n    Globals.selectedWordKey = undefined;\r\n    Globals.selectedWordDir = WordDirection.Across;\r\n    if (!Globals.gridSymmetry) Globals.gridSymmetry = SymmetryType.Rotate180;\r\n    if (Globals.useManualHeuristics === undefined) Globals.useManualHeuristics = true;\r\n    if (Globals.maxIffyLength === undefined) Globals.maxIffyLength = 0;\r\n    Globals.selectedWordNode = undefined;\r\n    Globals.curChainId = 1;\r\n    if (Globals.wordLists === undefined) Globals.wordLists = [];\r\n    Globals.fillStatus = Globals.wordList !== undefined ? FillStatus.Ready : FillStatus.NoWordList;\r\n\r\n    initializeSessionGlobals();\r\n    clearFill(Globals.activeGrid!);\r\n\r\n    setGridWidth(width);\r\n    setGridHeight(height);\r\n  }\r\n\r\n  if (!Globals.puzzle) {\r\n    initializeGlobals();\r\n    triggerUpdate();\r\n  }\r\n\r\n  return (\r\n    <AppContext.Provider value={appState}>\r\n      <a id=\"download-puzzle-link\" href=\"http://www.example.com\" style={{display: \"none\"}}>stuff</a>\r\n\r\n      <Menu gridHeight={gridHeight} gridWidth={gridWidth} openView={activeView}></Menu>\r\n\r\n      <div className=\"left-panel\">\r\n        {activeView === \"Clues\" && \r\n            <CluesView updateSemaphore={updateSemaphore}></CluesView>\r\n        }\r\n        {activeView === \"Fill\" && \r\n            <FillView></FillView>\r\n        }\r\n      </div>\r\n      \r\n      <div className=\"right-panel\">\r\n        <Grid></Grid>\r\n      </div>\r\n    </AppContext.Provider>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\nimport 'bootstrap/dist/css/bootstrap.css';\r\n\r\n// import { loadWordListFromLocalhost } from './lib/wordList';\r\n// import Globals from './lib/windowService';\r\n// import { FillStatus } from './models/FillStatus';\r\n// loadWordListFromLocalhost(\"http://localhost/classifier/mainBrodaEntries.txt\").then(() => {\r\n//   Globals.fillStatus = FillStatus.Ready;\r\n// });\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App activeView=\"Fill\" />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n"],"sourceRoot":""}